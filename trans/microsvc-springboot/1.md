# 第一章。与 Spring Boot 一起构建微服务

正如我们在上一课中所讨论的，我们正在向具有更小的、可独立部署的微服务的架构发展。这意味着将会有大量更小的微服务被开发出来。

一个重要的结果是，我们需要能够快速启动，并使用新的组件运行。

Spring Boot 的目标是用一种新的部件来解决快速起飞的问题。在本课中，我们将从了解 Spring Boot 带来的能力开始。我们将回答以下问题:

*   为什么是 Spring Boot？
*   Spring Boot 有什么特色？
*   什么是自动配置？
*   Spring Boot 不是什么？
*   当你使用 Spring Boot 时，后台会发生什么？
*   如何使用 Spring Initializr 创建新的 Spring Boot 项目？
*   你如何用 Spring Boot 创建基本的 RESTful 服务？

# 什么是 Spring Boot？

首先，让我们先澄清一些对 Spring Boot 的误解:

*   Spring Boot 不是一个代码生成框架。它不生成任何代码。
*   Spring Boot 既不是应用服务器，也不是 web 服务器。它提供了与不同范围的应用和 web 服务器的良好集成。
*   Spring Boot 没有实现任何特定的框架或规范。

这些问题仍然存在:

*   什么是 Spring Boot？
*   为什么它在最近几年变得如此受欢迎？

为了回答这些问题，让我们构建一个简单的例子。让我们考虑一个您想要快速构建原型的示例应用。

## 构建微服务的快速原型

假设我们想用 Spring MVC 构建一个微服务，用 JPA(用 Hibernate 作为实现)连接数据库。

让我们考虑一下建立这样一个应用的步骤:

1.  决定用哪个版本的 Spring MVC，JPA，Hibernate。
2.  设置一个 Spring 上下文，将所有不同的层连接在一起。
3.  用 Spring MVC 设置一个 web 层(包括 Spring MVC 配置):

    *   为 DispatcherServlet、handler、resolver、view resolvers 等配置 bean

4.  在数据层设置 Hibernate:

    *   为 SessionFactory、数据源等配置 bean

    
5.  决定并实现如何存储您的应用配置，这在不同的环境中会有所不同。
6.  决定你想如何进行单元测试。
7.  决定并实施您的事务管理策略。
8.  决定并实现如何实现安全性。
9.  设置您的日志框架。
10.  决定并实现您希望如何在生产中监控您的应用。
11.  决定并实施指标管理系统，以提供有关应用的统计信息。
12.  决定并实现如何将您的应用部署到 web 或应用服务器。

在我们开始构建我们的业务逻辑之前，至少需要完成前面提到的几个步骤。这至少需要几周时间。

当我们构建微服务时，我们希望快速起步。前面所有的步骤都不会使微服务的开发变得容易。这就是 Spring Boot 想要解决的问题。

以下引文摘自 Spring Boot 网站([http://docs . spring . io/spring-boot/docs/current-SNAPSHOT/reference/html single/# boot-documentation](http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation)):

> Spring Boot 使得创建独立的、生产级的基于 Spring 的应用变得容易，你可以“直接运行”。我们对 Spring 平台和第三方库有自己的看法，所以你可以毫不费力地开始。大多数 Spring Boot 应用需要很少的Spring配置
> 
> Spring Boot 使开发人员能够专注于他们的微服务背后的业务逻辑。它旨在处理开发微服务所涉及的所有基本技术细节。

## 主要目标

Spring Boot 的主要目标如下:

*   让基于 Spring 的项目快速起步。
*   固执己见。根据通常的用法进行默认假设。提供配置选项来处理与默认值的偏差。
*   提供大量现成的非功能特性。
*   不要使用代码生成，避免使用大量的 XML 配置。

## 非功能特性

Spring Boot 提供的一些非功能特性如下:

*   各种框架、服务器和规范的版本和配置的默认处理
*   应用安全性的默认选项
*   可以扩展的默认应用指标
*   使用运行状况检查的基本应用监控
*   外部化配置的多个选项

# Spring Boot 你好世界

在本课中，我们将从构建第一个 Spring Boot 应用开始。我们将使用 Maven 来管理依赖性。

启动 Spring Boot 应用涉及以下步骤:

1.  在您的`pom.xml`文件中配置`spring-boot-starter-parent`。
2.  用所需的启动项目配置`pom.xml`文件。
3.  配置`spring-boot-maven-plugin`能够运行应用。
4.  创建您的第一个 Spring Boot 启动类。

让我们从步骤 1 开始，配置启动项目。

## 配置Spring-启动-启动-父母

让我们从一个简单的带有`spring-boot-starter-parent`的`pom.xml`文件开始:

```
    <project 

     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0

     http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <groupId>com.mastering.spring</groupId> 

    <artifactId>springboot-example</artifactId> 

    <version>0.0.1-SNAPSHOT</version> 

    <name>First Spring Boot Example</name> 

    <packaging>war</packaging>

    <parent> 

      <groupId>org.springframework.boot</groupId> 

      <artifactId>spring-boot-starter-parent</artifactId>  

      <version>2.0.0.M1</version>

    </parent>

    <properties> 

      <java.version>1.8</java.version> 

    </properties>

   <repositories>

    <repository>

      <id>spring-milestones</id>

      <name>Spring Milestones</name>

      <url>https://repo.spring.io/milestone</url>

      <snapshots>

        <enabled>false</enabled>

      </snapshots>

    </repository>

   </repositories>

   <pluginRepositories>

    <pluginRepository>

      <id>spring-milestones</id>

      <name>Spring Milestones</name>

      <url>https://repo.spring.io/milestone</url>

        <snapshots>

          <enabled>false</enabled>

        </snapshots>

     </pluginRepository>

    </pluginRepositories>

</project>
```

第一个问题是:我们为什么需要`spring-boot-starter-parent`？

一个`spring-boot-starter-parent`依赖关系包含要使用的 Java 的默认版本，Spring Boot 使用的依赖关系的默认版本，以及 Maven 插件的默认配置。

### 注意

`spring-boot-starter-parent`依赖关系是为基于 Spring Boot 的应用提供依赖关系和插件管理的父 POM。

让我们看看`spring-boot-starter-parent`里面的一些代码，对`spring-boot-starter-parent`有更深入的了解。

## Spring-启动-起动器-父母

`spring-boot-starter-parent`依赖项继承自`spring-boot-dependencies`，它在 POM 的顶部定义。下面的代码片段显示了来自`spring-boot-starter-parent`的摘录:

```
    <parent>

      <groupId>org.springframework.boot</groupId>

      <artifactId>spring-boot-dependencies</artifactId>

      <version>2.0.0.M1</version>

      <relativePath>../../spring-boot-dependencies</relativePath>

   </parent>
```

`spring-boot-dependencies`为 Spring Boot 使用的所有依赖项提供默认的依赖项管理。以下代码显示了在`spring-boot-dependencies`中配置的各种依赖关系的不同版本:

```
<activemq.version>5.13.4</activemq.version>

<aspectj.version>1.8.9</aspectj.version>

<ehcache.version>2.10.2.2.21</ehcache.version>

<elasticsearch.version>2.3.4</elasticsearch.version>

<gson.version>2.7</gson.version>

<h2.version>1.4.192</h2.version>

<hazelcast.version>3.6.4</hazelcast.version>

<hibernate.version>5.0.9.Final</hibernate.version>

<hibernate-validator.version>5.2.4.Final</hibernate

  validator.version>

<hsqldb.version>2.3.3</hsqldb.version>

<htmlunit.version>2.21</htmlunit.version>

<jackson.version>2.8.1</jackson.version>

<jersey.version>2.23.1</jersey.version>

<jetty.version>9.3.11.v20160721</jetty.version>

<junit.version>4.12</junit.version>

<mockito.version>1.10.19</mockito.version>

<selenium.version>2.53.1</selenium.version>

<servlet-api.version>3.1.0</servlet-api.version>

<spring.version>4.3.2.RELEASE</spring.version>

<spring-amqp.version>1.6.1.RELEASE</spring-amqp.version>

<spring-batch.version>3.0.7.RELEASE</spring-batch.version>

<spring-data-releasetrain.version>Hopper-SR2</spring-

  data-releasetrain.version>

<spring-hateoas.version>0.20.0.RELEASE</spring-hateoas.version>

<spring-restdocs.version>1.1.1.RELEASE</spring-restdocs.version>

<spring-security.version>4.1.1.RELEASE</spring-security.version>

<spring-session.version>1.2.1.RELEASE</spring-session.version>

<spring-ws.version>2.3.0.RELEASE</spring-ws.version>

<thymeleaf.version>2.1.5.RELEASE</thymeleaf.version>

<tomcat.version>8.5.4</tomcat.version>

<xml-apis.version>1.4.01</xml-apis.version>
```

如果我们想要覆盖依赖项的特定版本，我们可以通过在应用的`pom.xml`文件中提供一个具有正确名称的属性来实现。下面的代码片段展示了一个将我们的应用配置为使用 1.10.20 版的 Mockito 的示例:

```
    <properties>

     <mockito.version>1.10.20</mockito.version>

    </properties>
```

以下是`spring-boot-starter-parent`中定义的一些其他内容:

*   默认的 Java 版本`<java.version>1.8</java.version>`
*   Maven 插件的默认配置:

    *   `maven-failsafe-plugin`
    *   `maven-surefire-plugin`
    *   `git-commit-id-plugin`

不同版本框架之间的兼容性是开发人员面临的主要问题之一。如何找到与特定 Spring 版本兼容的最新 Spring Session 版本？通常的答案是阅读文档。然而，如果我们使用 Spring Boot，这是由`spring-boot-starter-parent`变得简单。如果我们想升级到一个更新的 Spring 版本，我们需要做的就是找到那个 Spring 版本的`spring-boot-starter-parent`依赖项。一旦我们升级我们的应用来使用特定版本的`spring-boot-starter-parent`，我们将把所有其他依赖项升级到与新的 Spring 版本兼容的版本。开发人员要处理的问题少了一个。总是让我开心。

## 用所需的起始项目配置 pom.xml

每当我们想在 Spring Boot 构建一个应用时，我们都需要开始寻找启动项目。让我们重点了解一下什么是入门项目。

### 了解启动项目

起始符是为不同目的定制的简化的依赖描述符。例如，`spring-boot-starter-web`是使用 Spring MVC 构建 web 应用(包括 RESTful)的起点。它使用 Tomcat 作为默认的嵌入式容器。如果我想使用 Spring MVC 开发一个 web 应用，我们需要做的就是将`spring-boot-starter-web`包含在我们的依赖项中，然后我们会自动预配置以下内容:

*   Spring MVC
*   兼容版本的`jackson-databind`(用于绑定)和 hibernate-validator(用于表单验证)
*   `spring-boot-starter-tomcat`(Tomcat 的启动项目)

下面的代码片段显示了在`spring-boot-starter-web`中配置的一些依赖关系:

```
    <dependencies>

        <dependency>

          <groupId>org.springframework.boot</groupId>

          <artifactId>spring-boot-starter</artifactId>

        </dependency>

        <dependency>

          <groupId>org.springframework.boot</groupId>

          <artifactId>spring-boot-starter-tomcat</artifactId>

        </dependency>

        <dependency>

          <groupId>org.hibernate</groupId>

          <artifactId>hibernate-validator</artifactId>

        </dependency>

        <dependency>

          <groupId>com.fasterxml.jackson.core</groupId>

          <artifactId>jackson-databind</artifactId>

        </dependency>

        <dependency>

          <groupId>org.springframework</groupId>

          <artifactId>spring-web</artifactId>

        </dependency>

        <dependency>

          <groupId>org.springframework</groupId>

          <artifactId>spring-webmvc</artifactId>

       </dependency>

    </dependencies>
```

正如我们在前面的代码片段中看到的，当我们使用`spring-boot-starter-web`时，我们得到了许多自动配置的框架。

对于我们想要构建的 web 应用，我们还想做一些好的单元测试，并将其部署在 Tomcat 上。下面的代码片段显示了我们需要的不同的 starter 依赖项。我们需要将它添加到我们的`pom.xml`文件中:

```
    <dependencies>

      <dependency>

        <groupId>org.springframework.boot</groupId>

        <artifactId>spring-boot-starter-web</artifactId>

     </dependency>

     <dependency>

       <groupId>org.springframework.boot</groupId>

       <artifactId>spring-boot-starter-test</artifactId>

       <scope>test</scope>

     </dependency>

     <dependency>

       <groupId>org.springframework.boot</groupId>

       <artifactId>spring-boot-starter-tomcat</artifactId>

       <scope>provided</scope>

     </dependency>

    </dependencies>
```

我们添加了三个初始项目:

*   我们已经讨论过`spring-boot-starter-web`。它为我们提供了用 Spring MVC 构建 web 应用所需的框架。
*   `spring-boot-starter-test`依赖项提供了单元测试所需的以下测试框架:

    *   **JUnit** :基本单元测试框架
    *   **Mockito** :用于模拟
    *   **Hamcrest** 、 **AssertJ** :用于可读断言
    *   **Spring Test** :基于 Spring 上下文的应用的单元测试框架

*   `spring-boot-starter-tomcat`依赖项是运行 web 应用的默认设置。为了清楚起见，我们将它包括在内。`spring-boot-starter-tomcat`是使用 Tomcat 作为嵌入式 servlet 容器的起点。

我们现在已经用 starter 父文件和所需的 starter 项目配置了我们的`pom.xml`文件。现在让我们添加`spring-boot-maven-plugin`，这将使我们能够运行 Spring Boot 应用。

## 配置 spring-boot-maven-plugin

当我们使用 Spring Boot 构建应用时，有几种情况是可能的:

*   我们希望在不构建 JAR 或 WAR 的情况下就地运行应用
*   我们希望构建一个 JAR 和一个 WAR，以便以后部署

`spring-boot-maven-plugin`依赖关系为前面两种情况提供了能力。下面的代码片段显示了我们如何在应用中配置`spring-boot-maven-plugin`:

```
    <build>

     <plugins>

      <plugin>

        <groupId>org.springframework.boot</groupId>

        <artifactId>spring-boot-maven-plugin</artifactId>

      </plugin>

     </plugins>

    </build>
```

`spring-boot-maven-plugin`依赖关系为 Spring Boot 应用提供了几个目标。最流行的目标是 run(这可以在命令提示符下从项目的根文件夹中作为`mvn spring-boot:run`执行)。

## 创建您的第一个 Spring Boot 发布类

下面的类解释了如何创建一个简单的 Spring Boot 启动类。它使用来自`SpringApplication`类的静态 run 方法，如下面的代码片段所示:

```
    package com.mastering.spring.springboot;

    import org.springframework.boot.SpringApplication;

    import org.springframework.boot

    autoconfigure.SpringBootApplication;

    import org.springframework.context.ApplicationContext;

    @SpringBootApplication public class Application {

       public static void main(String[] args)

        { 

         ApplicationContext ctx = SpringApplication.run

         (Application.class,args);

        }

     }
```

前面的代码是一个简单的 Java `main`方法，在`SpringApplication`类上执行静态`run`方法。

### spring application 类

`SpringApplication`类可用于从 Java `main`方法引导和启动 Spring 应用。

以下是引导 Spring Boot 应用时通常执行的步骤:

1.  创建 Spring 的`ApplicationContext`实例。
2.  启用接受命令行参数并将其作为 Spring 属性公开的功能。
3.  根据配置加载所有的 Spring beans。

### @ spring boot application 注释

`@SpringBootApplication`注释是三个注释的快捷方式:

*   `@Configuration`:表示这是一个 Spring 应用上下文配置文件。
*   启用自动配置，这是 Spring Boot 的一项重要功能。我们将在后面的单独章节中讨论自动配置。
*   `@ComponentScan`:启用对该类及其所有子包中的 Spring beans 的扫描。

## 运行我们的 Hello World 应用

我们可以用多种方式运行 Hello World 应用。让我们从最简单的选项开始运行它——作为 Java 应用运行。在您的 IDE 中，右键单击应用**类**，并将其作为 **Java 应用**运行。下面的截图显示了运行我们的`Hello World`应用的一些日志:

![Running Our Hello World Application](graphics/1.1.jpg)

以下是需要注意的关键事项:

*   Tomcat 服务器在`8080` - `Tomcat started on port(s): 8080 (http)`端口启动。
*   `DispatcherServlet`已配置。这意味着 Spring MVC 框架已经准备好接受请求- `Mapping servlet: 'dispatcherServlet' to [/]`。
*   默认情况下，`characterEncodingFilter`、`hiddenHttpMethodFilter`、`httpPutFormContentFilter`和`requestContextFilter`四个过滤器处于启用状态
*   默认错误页面配置- `Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)`
*   WebJars 是自动配置的。WebJars 支持静态依赖的依赖管理，如引导和查询- `Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]`

以下截图显示了截至目前的应用布局。我们只有两个文件，`pom.xml`和`Application.java`:

![Running Our Hello World Application](graphics/1.2.jpg)

通过一个简单的`pom.xml`文件和一个 Java 类，我们能够启动 Spring MVC 应用，并具有前面描述的所有功能。关于 Spring Boot，最重要的是了解背景发生了什么。首先要理解前面的启动日志。让我们来看看 Maven 的依赖关系，以获得更深入的了解。

下面的屏幕截图显示了我们创建的`pom.xml`文件中使用基本配置配置的一些依赖项:

![Running Our Hello World Application](graphics/1.3.jpg)

Spring Boot 会很多魔法。一旦您配置并运行了应用，我建议您尝试一下，以获得更深入的理解，这在您调试问题时会很有用。

正如蜘蛛侠所说，能力越大，责任越大。在 Spring Boot 的情况下，这是绝对正确的。在未来的时间里，使用 Spring Boot 的最好的开发人员应该是那些理解后台发生的事情的人——依赖性和自动配置。

## 自动配置

为了使我们能够进一步理解自动配置，让我们扩展我们的应用类，以包括多几行代码:

```
    ApplicationContext ctx = SpringApplication.run(Application.class,

     args);

    String[] beanNames = ctx.getBeanDefinitionNames();

    Arrays.sort(beanNames);

   for (String beanName : beanNames) {

     System.out.println(beanName);

    }
```

我们获取 Spring 应用上下文中定义的所有 beans，并打印它们的名称。当`Application.java`作为 Java 程序运行时，它打印 beans 列表，如以下输出所示:

```
application

basicErrorController

beanNameHandlerMapping

beanNameViewResolver

characterEncodingFilter

conventionErrorViewResolver

defaultServletHandlerMapping

defaultViewResolver

dispatcherServlet

dispatcherServletRegistration

duplicateServerPropertiesDetector

embeddedServletContainerCustomizerBeanPostProcessor

error

errorAttributes

errorPageCustomizer

errorPageRegistrarBeanPostProcessor

faviconHandlerMapping

faviconRequestHandler

handlerExceptionResolver

hiddenHttpMethodFilter

httpPutFormContentFilter

httpRequestHandlerAdapter

jacksonObjectMapper

jacksonObjectMapperBuilder

jsonComponentModule

localeCharsetMappingsCustomizer

mappingJackson2HttpMessageConverter

mbeanExporter

mbeanServer

messageConverters

multipartConfigElement

multipartResolver

mvcContentNegotiationManager

mvcConversionService

mvcPathMatcher

mvcResourceUrlProvider

mvcUriComponentsContributor

mvcUrlPathHelper

mvcValidator

mvcViewResolver

objectNamingStrategy

autoconfigure.AutoConfigurationPackages

autoconfigure.PropertyPlaceholderAutoConfiguration

autoconfigure.condition.BeanTypeRegistry

autoconfigure.context.ConfigurationPropertiesAutoConfiguration

autoconfigure.info.ProjectInfoAutoConfiguration

autoconfigure.internalCachingMetadataReaderFactory

autoconfigure.jackson.JacksonAutoConfiguration

autoconfigure.jackson.JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration

autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration

autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration

autoconfigure.jmx.JmxAutoConfiguration

autoconfigure.web.DispatcherServletAutoConfiguration

autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletConfiguration

autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration

autoconfigure.web.EmbeddedServletContainerAutoConfiguration

autoconfigure.web.EmbeddedServletContainerAutoConfiguration$EmbeddedTomcat

autoconfigure.web.ErrorMvcAutoConfiguration

autoconfigure.web.ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration

autoconfigure.web.HttpEncodingAutoConfiguration

autoconfigure.web.HttpMessageConvertersAutoConfiguration

autoconfigure.web.HttpMessageConvertersAutoConfiguration$StringHttpMessageConverterConfiguration

autoconfigure.web.JacksonHttpMessageConvertersConfiguration

autoconfigure.web.JacksonHttpMessageConvertersConfiguration$MappingJackson2HttpMessageConverterConfiguration

autoconfigure.web.MultipartAutoConfiguration

autoconfigure.web.ServerPropertiesAutoConfiguration

autoconfigure.web.WebClientAutoConfiguration

autoconfigure.web.WebClientAutoConfiguration$RestTemplateConfiguration

autoconfigure.web.WebMvcAutoConfiguration

autoconfigure.web.WebMvcAutoConfiguration$EnableWebMvcConfiguration

autoconfigure.web.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter

autoconfigure.web.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter$FaviconConfiguration

autoconfigure.websocket.WebSocketAutoConfiguration

autoconfigure.websocket.WebSocketAutoConfiguration$TomcatWebSocketConfiguration

context.properties.ConfigurationPropertiesBindingPostProcessor

context.properties.ConfigurationPropertiesBindingPostProcessor.store

annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor

annotation.ConfigurationClassPostProcessor.importAwareProcessor

annotation.internalAutowiredAnnotationProcessor

annotation.internalCommonAnnotationProcessor

annotation.internalConfigurationAnnotationProcessor

annotation.internalRequiredAnnotationProcessor

event.internalEventListenerFactory

event.internalEventListenerProcessor

preserveErrorControllerTargetClassPostProcessor

propertySourcesPlaceholderConfigurer

requestContextFilter

requestMappingHandlerAdapter

requestMappingHandlerMapping

resourceHandlerMapping

restTemplateBuilder

serverProperties

simpleControllerHandlerAdapter

spring.http.encoding-autoconfigure.web.HttpEncodingProperties

spring.http.multipart-autoconfigure.web.MultipartProperties

spring.info-autoconfigure.info.ProjectInfoProperties

spring.jackson-autoconfigure.jackson.JacksonProperties

spring.mvc-autoconfigure.web.WebMvcProperties

spring.resources-autoconfigure.web.ResourceProperties

standardJacksonObjectMapperBuilderCustomizer

stringHttpMessageConverter

tomcatEmbeddedServletContainerFactory

viewControllerHandlerMapping

viewResolver

websocketContainerCustomizer
```

需要考虑的重要事项如下:

*   这些 beans 是在哪里定义的？
*   这些豆子是怎么创造出来的？

这就是 Spring 自动配置的神奇之处。

每当我们向 Spring Boot 项目添加一个新的依赖项时，Spring Boot 自动配置会自动尝试基于依赖项来配置 beans。

例如，当我们在`spring-boot-starter-web`中添加依赖项时，会自动配置以下 beans:

*   `basicErrorController`、`handlerExceptionResolver`:是基本的异常处理。当异常发生时，它显示一个默认的错误页面。
*   `beanNameHandlerMapping`:用于解析处理程序(控制器)的路径。
*   `characterEncodingFilter`:提供默认字符编码 UTF-8。
*   `dispatcherServlet`:它是 Spring MVC 应用中的前端控制器。
*   `jacksonObjectMapper`:将对象翻译成 JSON，JSON 翻译成 REST 服务中的对象。
*   `messageConverters`:默认的消息转换器是将对象转换成 XML 或 JSON，反之亦然。
*   `multipartResolver`:支持在 web 应用中上传文件。
*   `mvcValidator`:支持 HTTP 请求的验证。
*   `viewResolver`:将逻辑视图名解析为物理视图。
*   `propertySourcesPlaceholderConfigurer`:支持应用配置的外部化。
*   `requestContextFilter`:默认为请求过滤器。
*   `restTemplateBuilder`:用于调用 REST 服务。
*   Tomcat 是基于 Spring Boot 的 web 应用的默认嵌入式 servlet 容器。

在下一节中，让我们看看一些启动项目和它们提供的自动配置。

## 启动项目

下表显示了 Spring Boot 提供的一些重要的启动项目:

| 

启动器

 | 

描述

 |
| --- | --- |
| `spring-boot-starter-webservices` | 这是一个开发基于 XML 的 web 服务的入门项目。 |
| `spring-boot-starter-web` | 这是一个构建基于 Spring MVC 的 web 应用或 RESTful 应用的入门项目。它使用 Tomcat 作为默认的嵌入式 servlet 容器。 |
| `spring-boot-starter-activemq` | 这支持在 ActiveMQ 上使用 JMS 进行基于消息的通信。 |
| `spring-boot-starterintegration` | 这支持为企业集成模式提供实现的 Spring 集成框架。 |
| `spring-boot-starter-test` | 这为各种单元测试框架提供了支持，比如 JUnit、Mockito 和 Hamcrest matchers。 |
| `spring-boot-starter-jdbc` | 这为使用 Spring JDBC 提供了支持。默认情况下，它配置一个 Tomcat JDBC 连接池。 |
| `spring-boot-startervalidation` | 这为 Java Bean 验证 API 提供了支持。它的默认实现是 hibernate-validator。 |
| `spring-boot-starter-hateoas` | HATEOAS 表示超媒体是应用状态的引擎。使用 HATEOAS 的 RESTful 服务除了返回数据之外，还返回与当前上下文相关的其他资源的链接。 |
| `spring-boot-starter-jersey` | JAX-RS 是开发 REST APIs 的 Java EE 标准。Jersey 是默认实现。这个入门项目为构建基于 JAX RS 的 REST APIs 提供了支持。 |
| `spring-boot-starterwebsocket` | HTTP 是无状态的。WebSockets 允许您保持服务器和浏览器之间的连接。这个起始项目提供了对 Spring WebSockets 的支持。 |
| `spring-boot-starter-aop` | 这为面向方面的编程提供了支持。它还支持 AspectJ 进行高级的面向方面编程。 |
| `spring-boot-starter-amqp` | 默认情况下，RabbitMQ 是这个 starter 项目提供的 AMQP 消息传递。 |
| `spring-boot-starter-security` | 这个 starter 项目支持 Spring 安全性的自动配置。 |
| `spring-boot-starter-data-jpa` | 这为 Spring 数据 JPA 提供了支持。它的默认实现是 Hibernate。 |
| `spring-boot-starter` | 这是 Spring Boot 应用的基础入门。它支持自动配置和日志记录。 |
| `spring-boot-starter-batch` | 这为使用 Spring Batch 开发批处理应用提供了支持。 |
| `spring-boot-starter-cache` | 这是使用 Spring 框架进行缓存的基本支持。 |
| `spring-boot-starter-datarest` | 这是对使用 Spring Data REST 公开 REST 服务的支持。 |

到目前为止，我们已经建立了一个基本的 web 应用，并了解了一些与 Spring Boot 相关的重要概念:

*   自动配置
*   启动项目
*   `spring-boot-maven-plugin`
*   `spring-boot-starter-parent`
*   注释`@SpringBootApplication`

现在让我们把注意力转移到理解什么是 REST 和构建 REST 服务上来。

# 什么是休息？

代表性状态转移基本上是 web 的一种架构风格。REST 指定了一组约束。这些约束确保客户端(服务消费者和浏览器)能够以灵活的方式与服务器交互。

让我们先了解一些常用术语:

*   **服务器**:服务提供商。公开可供客户端使用的服务。
*   **客户端**:服务消费者。可能是浏览器或其他系统。
*   **资源**:任何信息都可以是资源:一个人，一张图片，一段视频，或者你想卖的一个产品。
*   **表示**:资源的一种特定表示方式。例如，产品资源可以用 JSON、XML 或 HTML 来表示。不同的客户端可能会请求不同的资源表示。

下面列出了一些重要的 REST 约束:

*   **客户端-服务器**:应该有一个服务器(服务提供者)和一个客户端(服务消费者)。随着新技术的出现，这使得服务器和客户机能够松散耦合和独立发展。
*   **无状态**:每个服务应该是无状态的。后续请求不应依赖于临时存储的前一个请求的某些数据。消息应该是自我描述的。
*   **统一接口**:每个资源都有一个资源标识符。在 web 服务的情况下，我们使用这个 URI 的例子:`/users/Jack/todos/1`。在这里，URI·杰克是用户的名字。`1`是我们想要检索的待办事项的 ID。
*   **可缓存**:服务响应应该是可缓存的。每个响应都应该指出它是否可缓存。
*   **分层系统**:服务的消费者不应该假设直接连接到服务提供者。因为请求可以被缓存，所以客户端可能从中间层获得缓存的响应。
*   **通过表现操纵资源**:一个资源可以有多个表现。应该可以通过具有这些表示的消息来修改资源。
*   作为应用状态引擎的超媒体:RESTful 应用的消费者应该只知道一个固定的服务 URL。所有后续资源都应该可以从资源表示中包含的链接中发现。

这里显示了 HATEOAS 链接的示例响应。这是对检索所有待办事项请求的响应:

```
    {  

"_embedded":{ 

"todos":[ 

{ 

"user":"Jill",

"desc":"Learn Hibernate",

"done":false,

"_links":{ 

"self":{ 

"href":"http://localhost:8080/todos/1"

                  },

"todo":{ 

"href":"http://localhost:8080/todos/1"

}

}

}

]

},

"_links":{ 

"self":{ 

"href":"http://localhost:8080/todos"

},

"profile":{ 

"href":"http://localhost:8080/profile/todos"

},

"search":{ 

"href":"http://localhost:8080/todos/search"

}

}

    }
```

上述响应包括指向以下内容的链接:

*   特定的待办事项(`http://localhost:8080/todos/1`)
*   搜索`resource` ( `http://localhost:8080/todos/search`)

如果服务消费者想要进行搜索，可以选择从响应中获取搜索 URL，并向其发送搜索请求。这将减少服务提供者和服务消费者之间的耦合。

我们开发的初始服务不会遵守所有这些约束。随着我们继续下一课，我们将向您介绍这些约束的细节，并将它们添加到服务中，使它们更加 RESTful。

# 先休息服务

让我们从创建一个返回欢迎消息的简单 REST 服务开始。我们将创建一个简单的 POJO `WelcomeBean`类，它有一个名为 message 的成员字段和一个参数构造函数，如下面的代码片段所示:

```
    package com.mastering.spring.springboot.bean;

    public class WelcomeBean {

      private String message;

       public WelcomeBean(String message) {

         super();

         this.message = message;

       }

      public String getMessage() {

        return message;

      }

    }
```

## 返回字符串的简单方法

让我们从创建一个返回字符串的简单 REST 控制器方法开始:

```
    @RestController

    public class BasicController {

      @GetMapping("/welcome")

      public String welcome() {

        return "Hello World";

      }

    }
```

需要注意的一些重要事项如下:

*   `@RestController`:`@RestController`注释提供了`@ResponseBody`和`@Controller`注释的组合。这通常用于创建静止控制器。
*   `@GetMapping("welcome")` : `@GetMapping`是`@RequestMapping(method = RequestMethod.GET)`的快捷方式。这个注释是一个可读的选择。带有该注释的方法将处理对`welcome` URI 的 Get 请求。

如果我们将`Application.java`作为 Java 应用运行，它将启动嵌入式 Tomcat 容器。我们可以在浏览器中启动该 URL，如下面的屏幕截图所示:

![Simple Method Returning String](graphics/01_03.jpg)

### 单元测试

让我们快速编写一个单元测试来测试前面的`controller`方法:

```
    @RunWith(SpringRunner.class)

    @WebMvcTest(BasicController.class)

    public class BasicControllerTest {

      @Autowired

      private MockMvc mvc;

      @Test

      public void welcome() throws Exception {

        mvc.perform(

        MockMvcRequestBuilders.get("/welcome")

       .accept(MediaType.APPLICATION_JSON))

       .andExpect(status().isOk())

       .andExpect(content().string(

       equalTo("Hello World")));

      }

    }
```

在前面的单元测试中，我们将使用`BasicController`启动一个模拟 MVC 实例。需要注意的一些快速事项如下:

*   `@RunWith(SpringRunner.class)` : SpringRunner 是`SpringJUnit4ClassRunner`注释的快捷方式。这为单元测试启动了一个简单的 Spring 上下文。
*   `@WebMvcTest(BasicController.class)`:这个注释可以和 SpringRunner 一起使用，为 Spring MVC 控制器编写简单的测试。这将只加载用 Spring-MVC 相关注释注释的 beans。在这个例子中，我们启动了一个 Web MVC 测试上下文，测试中的类是 BasicController。
*   `@Autowired private MockMvc mvc`:自动连接可用于发出请求的 MockMvc bean。
*   `mvc.perform(MockMvcRequestBuilders.get("/welcome").accept(MediaType.APPLICATION_JSON))`:用`Accept`头值`application/json`执行对`/welcome`的请求。
*   `andExpect(status().isOk())`:期望响应的状态为 200(成功)。
*   `andExpect(content().string(equalTo("Hello World")))`:期望响应的内容等于`"Hello World"`。

### 集成测试

当我们进行集成测试时，我们会希望启动带有所有已配置的控制器和 beans 的嵌入式服务器。这段代码片段展示了我们如何创建一个简单的集成测试:

```
    @RunWith(SpringRunner.class)

    @SpringBootTest(classes = Application.class, 

    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)

    public class BasicControllerIT {

      private static final String LOCAL_HOST = 

      "http://localhost:";

      @LocalServerPort

      private int port;

      private TestRestTemplate template = new TestRestTemplate();

      @Test

      public void welcome() throws Exception {

        ResponseEntity<String> response = template

       .getForEntity(createURL("/welcome"), String.class);

        assertThat(response.getBody(), equalTo("Hello World"));

       }

      private String createURL(String uri) {

        return LOCAL_HOST + port + uri;

      }

    }
```

需要注意的一些重要事项如下:

*   `@SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`:它在Spring`TestContext`之上提供了额外的功能。支持配置端口以完全运行容器和`TestRestTemplate`(执行请求)。
*   `@LocalServerPort private int port`:`SpringBootTest`将确保容器运行的端口自动连接到`port`变量中。
*   `private String createURL(String uri)`:将本地主机 URL 和端口附加到 URI 上创建完整 URL 的方法。
*   `private TestRestTemplate template = new TestRestTemplate()`:`TestRestTemplate`通常用于集成测试。它在`RestTemplate`之上提供了额外的功能，这在集成测试环境中特别有用。它不遵循重定向，因此我们可以断言响应位置。
*   对给定的 URI 执行一个 get 请求。
*   `assertThat(response.getBody(), equalTo("Hello World"))`:断言响应体内容为`"Hello World"`。

## 返回对象的简单 REST 方法

在前面的方法中，我们返回了一个字符串。让我们创建一个返回正确 JSON 响应的方法。看看下面的方法:

```
    @GetMapping("/welcome-with-object")

    public WelcomeBean welcomeWithObject() {

      return new WelcomeBean("Hello World");

    }
```

前面的方法返回一个简单的用消息`"Hello World"`初始化的`WelcomeBean`。

### 执行请求

让我们发送一个测试请求，看看会得到什么样的响应。以下屏幕截图显示了输出:

![Executing a Request](graphics/01_04.jpg)

对`http://localhost:8080/welcome-with-object` URL 的响应如下所示:

```
    {"message":"Hello World"}
```

需要回答的问题是:我们返回的`WelcomeBean`对象如何被转换成 JSON？

再次，这是 Spring Boot 自动配置的魔力。如果 Jackson 在应用的类路径上，那么默认对象到 JSON(反之亦然)转换器的实例将由 Spring Boot 自动配置。

### 单元测试

让我们快速编写一个检查 JSON 响应的单元测试。让我们将测试添加到`BasicControllerTest`:

```
    @Test

    public void welcomeWithObject() throws Exception {

      mvc.perform(

       MockMvcRequestBuilders.get("/welcome-with-object")

      .accept(MediaType.APPLICATION_JSON))

      .andExpect(status().isOk())

      .andExpect(content().string(containsString("Hello World")));

    }
```

这个测试与前面的单元测试非常相似，除了我们使用`containsString`来检查内容是否包含子串`"Hello World"`。稍后我们将学习如何编写合适的 JSON 测试。

### 集成测试

让我们将注意力转移到编写集成测试上来。让我们给`BasicControllerIT`添加一个方法，如下面的代码片段所示:

```
    @Test

    public void welcomeWithObject() throws Exception {

      ResponseEntity<String> response = 

      template.getForEntity(createURL("/welcome-with-object"), 

      String.class);

      assertThat(response.getBody(), 

      containsString("Hello World"));

    }
```

这个方法类似于前面的集成测试，除了我们使用`String`方法断言一个子字符串。

## 用路径变量获取方法

让我们把注意力转移到路径变量上。路径变量用于将 URI 中的值绑定到控制器方法中的变量。在下面的示例中，我们希望参数化名称，以便我们可以使用名称自定义欢迎消息:

```
    private static final String helloWorldTemplate = "Hello World, 

    %s!";

   @GetMapping("/welcome-with-parameter/name/{name}")

   public WelcomeBean welcomeWithParameter(@PathVariable String name) 

    {

       return new WelcomeBean(String.format(helloWorldTemplate, name));

    }
```

需要注意的一些重要事项如下:

*   `@GetMapping("/welcome-with-parameter/name/{name}")` : `{name}`表示该值将是变量。在一个 URI 中，我们可以有多个变量模板。
*   `welcomeWithParameter(@PathVariable String name)` : `@PathVariable`确保来自 URI 的变量值被绑定到变量名。
*   `String.format(helloWorldTemplate, name)`:一个简单的字符串格式，用名称替换模板中的`%s`。

### 执行请求

让我们发送一个测试请求，看看会得到什么样的响应。以下截图显示了回应:

![Executing a Request](graphics/01_05.jpg)

对`http://localhost:8080/welcome-with-parameter/name/Buddy` URL 的响应如下:

```
    {"message":"Hello World, Buddy!"}
```

正如所料，URI 中的名称用于形成响应中的消息。

### 单元测试

让我们快速地为前面的方法编写一个单元测试。我们希望传递一个名字作为 URI 的一部分，并检查响应是否包含这个名字。以下代码显示了我们如何做到这一点:

```
    @Test

    public void welcomeWithParameter() throws Exception {

      mvc.perform(

      MockMvcRequestBuilders.get("/welcome-with-parameter/name/Buddy")

     .accept(MediaType.APPLICATION_JSON))

     .andExpect(status().isOk())

     .andExpect(

     content().string(containsString("Hello World, Buddy")));

    }
```

需要注意的一些重要事项如下:

*   `MockMvcRequestBuilders.get("/welcome-with-parameter/name/Buddy")`:匹配 URI 中的变量模板。我们传入名字`Buddy`。
*   `.andExpect(content().string(containsString("Hello World, Buddy")))`:我们期望响应包含名为的消息。

### 集成测试

前面方法的集成测试非常简单。看看下面的`test`方法:

```
    @Test

    public void welcomeWithParameter() throws Exception {

      ResponseEntity<String> response = 

      template.getForEntity(

      createURL("/welcome-with-parameter/name/Buddy"), String.class);

      assertThat(response.getBody(), 

      containsString("Hello World, Buddy"));

    }
```

需要注意的一些重要事项如下:

*   `createURL("/welcome-with-parameter/name/Buddy")`:匹配 URI 中的变量模板。我们在传递名字，伙计。
*   `assertThat(response.getBody(), containsString("Hello World, Buddy"))`:我们期望响应包含名为的消息。

在这一节中，我们看了用 Spring Boot 创建一个简单的 REST 服务的基础。我们也确保了我们有好的单元测试和集成测试。虽然这些都是非常基本的，但是它们为我们将在下一节中构建的更复杂的 REST 服务奠定了基础。

使用 JSON 比较而不是简单的子串比较，我们实现的单元测试和集成测试可以有更好的断言。我们将在为下一节中创建的 REST 服务编写的测试中关注它。

# 创建待办事项资源

我们将着重于为一个基本的待办事项管理系统创建 REST 服务。我们将为以下内容创建服务:

*   检索给定用户的待办事项列表
*   检索特定待办事项的详细信息
*   为用户创建待办事项

## 请求方法、操作和 uri

REST 服务的最佳实践之一是根据我们执行的操作使用适当的 HTTP 请求方法。在我们到目前为止公开的服务中，我们使用了`GET`方法，因为我们专注于读取数据的服务。

下表根据我们执行的操作显示了适当的 HTTP 请求方法:

| 

HTTP 请求方法

 | 

操作

 |
| --- | --- |
| `GET` | 读取-检索资源的详细信息 |
| `POST` | 创建-创建新的项目或资源 |
| `PUT` | 更新/替换 |
| `PATCH` | 更新/修改资源的一部分 |
| `DELETE` | 删除 |

让我们快速地将我们想要创建的服务映射到适当的请求方法:

*   **检索给定用户的待办事项列表**:这是 READ。我们将使用 GET。我们将使用一个 URI: `/users/{name}/todos`。另一个好的实践是在 URI 中对静态事物使用复数:用户、todo 等等。这导致更可读的 URIs。
*   **检索特定待办事项的详细信息**:同样，我们将使用`GET`。我们将使用 URI `/users/{name}/todos/{id}`。你可以看到，这与我们之前为 todos 列表确定的 URI 一致。
*   **为用户创建 todo】:对于创建操作，建议的 HTTP 请求方法是`POST`。为了创建新的待办事项，我们将发布到`URI /users/{name}/todos`。**

## 豆子和服务

为了能够检索和存储 todo 的细节，我们需要一个 Todo bean 和一个服务来检索和存储细节。

让我们创建一个 Todo Bean:

```
    public class Todo {

      private int id;

      private String user;

      private String desc;

      private Date targetDate;

      private boolean isDone;

      public Todo() {}

      public Todo(int id, String user, String desc, 

      Date targetDate, boolean isDone) { 

        super();

        this.id = id;

        this.user = user;

        this.desc = desc;

        this.targetDate = targetDate;

        this.isDone = isDone;

      }

       //ALL Getters

    }
```

我们已经创建了一个简单的 todo bean，包含 ID、用户名、Todo 描述、Todo 目标日期和完成状态指示器。我们为所有字段添加了一个构造函数和 getters。

现在来补充一下`TodoService`:

```
   @Service

   public class TodoService {

     private static List<Todo> todos = new ArrayList<Todo>();

     private static int todoCount = 3;

     static {

       todos.add(new Todo(1, "Jack", "Learn Spring MVC", 

       new Date(), false));

       todos.add(new Todo(2, "Jack", "Learn Struts", new Date(), 

       false));

       todos.add(new Todo(3, "Jill", "Learn Hibernate", new Date(), 

       false));

      }

     public List<Todo> retrieveTodos(String user) {

       List<Todo> filteredTodos = new ArrayList<Todo>();

       for (Todo todo : todos) {

         if (todo.getUser().equals(user))

         filteredTodos.add(todo);

        }

      return filteredTodos;

     }

    public Todo addTodo(String name, String desc, 

    Date targetDate, boolean isDone) {

      Todo todo = new Todo(++todoCount, name, desc, targetDate, 

      isDone);

      todos.add(todo);

      return todo;

    }

    public Todo retrieveTodo(int id) {

      for (Todo todo : todos) {

      if (todo.getId() == id)

        return todo;

      }

      return null;

     }

   }
```

需要注意的快速事项如下:

*   为了简单起见，这个服务不与数据库对话。它维护一个 todos 的内存数组列表。这个列表是用静态初始化器初始化的。
*   我们公开了几个简单的检索方法和一个添加待办事项的方法。

现在我们已经准备好了服务和 bean，我们可以创建第一个服务来检索用户的待办事项列表。

## 检索待办事项列表

我们将创建一个名为`TodoController`的新的`RestController`注释。retrieve todos 方法的代码如下所示:

```
    @RestController

    public class TodoController {

     @Autowired

     private TodoService todoService;

     @GetMapping("/users/{name}/todos")

     public List<Todo> retrieveTodos(@PathVariable String name) {

       return todoService.retrieveTodos(name);

     }

    }
```

以下是一些需要注意的事项:

*   我们正在使用`@Autowired`注释自动连接 todo 服务
*   我们使用`@GetMapping`注释将对`"/users/{name}/todos"` URI 的 Get 请求映射到`retrieveTodos`方法

### 执行服务

让我们发送一个测试请求，看看会得到什么样的响应。以下屏幕截图显示了输出:

![Executing the Service](graphics/01_06.jpg)

对`http://localhost:8080/users/Jack/todos` URL 的响应如下:

```
   [

    {"id":1,"user":"Jack","desc":"Learn Spring    

     MVC","targetDate":1481607268779,"done":false},  

    {"id":2,"user":"Jack","desc":"Learn 

    Struts","targetDate":1481607268779, "done":false}

   ]
```

### 单元测试

对`TodoController`类进行单元测试的代码如下面的屏幕截图所示:

```
   @RunWith(SpringRunner.class)

   @WebMvcTest(TodoController.class)

   public class TodoControllerTest {

    @Autowired

    private MockMvc mvc;

    @MockBean

    private TodoService service;

    @Test

    public void retrieveTodos() throws Exception {

     List<Todo> mockList = Arrays.asList(new Todo(1, "Jack",

     "Learn Spring MVC", new Date(), false), new Todo(2, "Jack",

     "Learn Struts", new Date(), false));

     when(service.retrieveTodos(anyString())).thenReturn(mockList);

     MvcResult result = mvc

    .perform(MockMvcRequestBuilders.get("/users

    /Jack/todos").accept(MediaType.APPLICATION_JSON))

    .andExpect(status().isOk()).andReturn();

    String expected = "["

     + "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}" +","

     + "{id:2,user:Jack,desc:\"Learn Struts\",done:false}" + "]";

     JSONAssert.assertEquals(expected, result.getResponse()

      .getContentAsString(), false);

     }

    }
```

需要注意的一些重要事项如下:

*   我们正在编写一个单元测试。因此，我们只想测试出现在`TodoController`类中的逻辑。因此，我们使用`@WebMvcTest(TodoController.class)`初始化一个只有`TodoController`类的模拟 MVC 框架。
*   `@MockBean private TodoService service`:我们正在使用`@MockBean`注释模仿`TodoService`。在用`SpringRunner`运行的测试类中，用`@MockBean`定义的 beans 将被用 Mockito 框架创建的 mock 替换。
*   `when(service.retrieveTodos(anyString())).thenReturn(mockList)`:我们正在模仿`retrieveTodos`服务方法返回模仿列表。
*   `MvcResult result = ..`:我们将请求的结果接受到一个 MvcResult 变量中，使我们能够对响应执行断言。
*   JSONAssert 是在 JSON 上执行断言的一个非常有用的框架。它将响应文本与预期值进行比较。`JSONAssert`足够智能，可以忽略未指定的值。另一个优点是在断言失败的情况下有明确的失败消息。最后一个参数 false 表示使用非严格模式。如果将其更改为 true，则预期值应该与结果完全匹配。

### 集成测试

对`TodoController`类执行集成测试的代码如下面的代码片段所示。它启动了整个 Spring 上下文，并定义了所有控制器和 beans:

```
   @RunWith(SpringJUnit4ClassRunner.class)

   @SpringBootTest(classes = Application.class, webEnvironment =     

   SpringBootTest.WebEnvironment.RANDOM_PORT)

   public class TodoControllerIT {

    @LocalServerPort

    private int port;

    private TestRestTemplate template = new TestRestTemplate();

    @Test

    public void retrieveTodos() throws Exception {

     String expected = "["

     + "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}" + ","

     + "{id:2,user:Jack,desc:\"Learn Struts\",done:false}" + "]";

     String uri = "/users/Jack/todos";

     ResponseEntity<String> response =

     template.getForEntity(createUrl(uri), String.class);

     JSONAssert.assertEquals(expected, response.getBody(), false);

    }

     private String createUrl(String uri) {

     return "http://localhost:" + port + uri;

    }

  }
```

这个测试非常类似于针对`BasicController`的集成测试，除了我们使用`JSONAssert`来断言响应。

## 检索特定待办事项的详细信息

我们现在将添加方法来检索特定 Todo 的详细信息:

```
    @GetMapping(path = "/users/{name}/todos/{id}")

    public Todo retrieveTodo(@PathVariable String name, @PathVariable 

    int id) {

      return todoService.retrieveTodo(id);

    }
```

以下是一些需要注意的事项:

*   绘制的 URI 是`/users/{name}/todos/{id}`
*   我们为`name`和`id`定义了两个路径变量

### 执行服务

让我们发送一个测试请求，看看会得到什么样的响应，如下图所示:

![Executing the Service](graphics/01_07.jpg)

对`http://localhost:8080/users/Jack/todos/1` URL 的响应如下所示:

```
    {"id":1,"user":"Jack","desc":"Learn Spring MVC", 

    "targetDate":1481607268779,"done":false}
```

### 单元测试

单元测试`retrieveTodo`的代码如下:

```
     @Test

     public void retrieveTodo() throws Exception {

       Todo mockTodo = new Todo(1, "Jack", "Learn Spring MVC", 

       new Date(), false);

       when(service.retrieveTodo(anyInt())).thenReturn(mockTodo);

       MvcResult result = mvc.perform(

       MockMvcRequestBuilders.get("/users/Jack/todos/1")

       .accept(MediaType.APPLICATION_JSON))

       .andExpect(status().isOk()).andReturn();

       String expected = "{id:1,user:Jack,desc:\"Learn Spring

       MVC\",done:false}";

      JSONAssert.assertEquals(expected, 

       result.getResponse().getContentAsString(), false);

     }
```

需要注意的一些重要事项如下:

*   `when(service.retrieveTodo(anyInt())).thenReturn(mockTodo)`:我们模仿`retrieveTodo`服务方法来返回模仿的 todo。
*   `MvcResult result = ..`:我们将请求的结果接受到一个 MvcResult 变量中，使我们能够对响应执行断言。
*   `JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(), false)`:断言结果是否如预期。

### 集成测试

对`TodoController`中的`retrieveTodos`执行集成测试的代码如下面的代码片段所示。这将被添加到`TodoControllerIT`类:

```
     @Test

     public void retrieveTodo() throws Exception {

       String expected = "{id:1,user:Jack,desc:\"Learn Spring   

       MVC\",done:false}";

       ResponseEntity<String> response = template.getForEntity(

       createUrl("/users/Jack/todos/1"), String.class);

       JSONAssert.assertEquals(expected, response.getBody(), false);

     }
```

## 添加待办事项

我们现在将添加方法来创建新的 Todo。用于创建的 HTTP 方法是`Post`。我们将向`"/users/{name}/todos"` URI 发帖:

```
    @PostMapping("/users/{name}/todos")

    ResponseEntity<?> add(@PathVariable String name,

    @RequestBody Todo todo) { 

      Todo createdTodo = todoService.addTodo(name, todo.getDesc(),

      todo.getTargetDate(), todo.isDone());

      if (createdTodo == null) {

         return ResponseEntity.noContent().build();

      }

     URI location = ServletUriComponentsBuilder.fromCurrentRequest()

    .path("/{id}").buildAndExpand(createdTodo.getId()).toUri();

    return ResponseEntity.created(location).build();

   }
```

以下是一些需要注意的事项:

*   `@PostMapping("/users/{name}/todos")` : `@PostMapping`注释将`add()`方法映射到带有`POST`方法的 HTTP 请求。
*   理想情况下，HTTP post 请求应该将 URI 返回给创建的资源。我们用`ResourceEntity`来做这件事。`@RequestBody`将请求的主体直接绑定到 bean。
*   `ResponseEntity.noContent().build()`:用于返回创建资源失败。
*   `ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(createdTodo.getId()).toUri()`:为创建的资源形成 URI，可以在响应中返回。
*   `ResponseEntity.created(location).build()`:返回一个状态`201(CREATED)`，并带有一个到已创建资源的链接。

### 邮递员

如果你在 Mac 上，你可能也想试试 Paw 应用。

让我们发送一个测试请求，看看会得到什么样的响应。以下截图显示了回应:

![Postman](graphics/01_08.jpg)

我们将使用 Postman 应用与 REST 服务进行交互。你可以从网站上安装，[https://www.getpostman.com/](https://www.getpostman.com/)。Windows 和 Mac 上都有。谷歌 Chrome 插件也是可用的。

### 执行 POST 服务

要使用`POST`创建新的 Todo，我们需要在请求体中包含 Todo 的 JSON。下面的屏幕截图显示了我们如何使用 Postman 应用创建请求以及执行请求后的响应:

![Executing the POST Service](graphics/01_09.jpg)

需要注意的一些重要事项如下:

*   我们正在发送 POST 请求。因此，我们从左上角的下拉菜单中选择`POST`。
*   为了将 Todo JSON 作为请求体的一部分发送，我们在`Body`选项卡中选择`raw`选项(用蓝点突出显示)。我们选择内容类型为 JSON ( `application/json`)。
*   请求成功执行后，您可以在屏幕中间的栏中看到请求的状态:`Status: 201 Created`。
*   地点是`http://localhost:8080/users/Jack/todos/5`。这是在响应中收到的新创建的 todo 的 URI。

对`http://localhost:8080/users/Jack/todos`的请求的完整细节显示在块中，如下所示:

```
    Header

    Content-Type:application/json

   Body

    {

      "user": "Jack",

      "desc": "Learn Spring Boot",

       "done": false

     }
```

### 单元测试

对创建的 Todo 进行单元测试的代码如下所示:

```
    @Test

    public void createTodo() throws Exception {

     Todo mockTodo = new Todo(CREATED_TODO_ID, "Jack", 

     "Learn Spring MVC", new Date(), false);

     String todo = "{"user":"Jack","desc":"Learn Spring MVC",     

     "done":false}";

    when(service.addTodo(anyString(), anyString(),   

    isNull(),anyBoolean()))

    .thenReturn(mockTodo);

   mvc

    .perform(MockMvcRequestBuilders.post("/users/Jack/todos")

    .content(todo)

    .contentType(MediaType.APPLICATION_JSON)

    )

    .andExpect(status().isCreated())

    .andExpect(

      header().string("location",containsString("/users/Jack/todos/"

     + CREATED_TODO_ID)));

   }
```

需要注意的一些重要事项如下:

*   `String todo = "{"user":"Jack","desc":"Learn Spring MVC","done":false}"`:要发布到创建待办事项服务的待办事项内容。
*   `when(service.addTodo(anyString(), anyString(), isNull(), anyBoolean())).thenReturn(mockTodo)`:模仿服务返回一个虚拟的 todo。
*   `MockMvcRequestBuilders.post("/users/Jack/todos").content(todo).contentType(MediaType.APPLICATION_JSON))`:创建一个给定内容类型的帖子到给定的 URI。
*   `andExpect(status().isCreated())`:期望状态为已创建。
*   `andExpect(header().string("location",containsString("/users/Jack/todos/" + CREATED_TODO_ID)))`:期望头包含`location`，并带有已创建资源的 URI。

### 集成测试

对`TodoController`中创建的 todo 执行集成测试的代码如下所示。这将被添加到`TodoControllerIT`类中，如下所示:

```
    @Test

    public void addTodo() throws Exception {

      Todo todo = new Todo(-1, "Jill", "Learn Hibernate", new Date(),  

      false);

      URI location = template

     .postForLocation(createUrl("/users/Jill/todos"),todo);

      assertThat(location.getPath(), 

      containsString("/users/Jill/todos/4"));

    }
```

需要注意的一些重要事项如下:

*   `URI location = template.postForLocation(createUrl("/users/Jill/todos"), todo)` : `postForLocation`是一个实用方法，在创建新资源的测试中特别有用。我们将待办事项发送到给定的 URI，并从标题中获取位置。
*   `assertThat(location.getPath(), containsString("/users/Jill/todos/4"))`:断言该位置包含新创建资源的路径。

# 春天初始化 zr

是否要自动生成 Spring Boot 项目？您想快速开始开发您的应用吗？Spring Initializr 就是答案。

Spring Initializr 托管在 [http://start.spring.io](http://start.spring.io) 。以下截图显示了网站的外观:

![Spring Initializr](graphics/01_10.jpg)

Spring Initializr 在创建项目时提供了很大的灵活性。您可以选择执行以下操作:

*   选择您的构建工具:Maven 或 Gradle。
*   选择您想要使用的 Spring Boot 版本。
*   为您的组件配置一个`Group ID`和`Artifact ID`。
*   为您的项目选择您想要的起始项(依赖项)。您可以点击屏幕底部的链接`Switch to the full version`，查看所有可供选择的启动项目。
*   选择如何打包组件:JAR 或 WAR。
*   选择您想要使用的 Java 版本。
*   选择您想要使用的 JVM 语言。

下面的截图显示了当你扩展(点击链接)到完整版本时 Spring Initializr 提供的一些选项:

![Spring Initializr](graphics/01_11.jpg)

## 创建您的第一个 Spring Initializr 项目

我们将使用完整版本并输入值，如下所示:

![Creating Your First Spring Initializr Project](graphics/01_12.jpg)

需要注意的事项如下:

*   `Build tool` : `Maven`
*   `Spring Boot version`:选择最新的
*   `Group` : `com.mastering.spring`
*   `Artifact` : `first-spring-initializr`
*   `Selected dependencies`:选择`Web, JPA, Actuator and Dev Tools`。在文本框中输入每一项，然后按*回车*选择它们。我们将在下一节学习更多关于执行器和开发工具的知识
*   `Java version` : `1.8`

继续点击**生成项目**按钮。这将创建一个`.zip`文件，您可以将它下载到您的计算机上。

下面的屏幕截图显示了创建的项目的结构:

![Creating Your First Spring Initializr Project](graphics/01_13.jpg)

我们现在将这个项目导入到您的 IDE 中。在 Eclipse 中，您可以执行以下步骤:

1.  启动 Eclipse。
2.  导航到**文件** | **导入**。
3.  选择现有的 Maven 项目。
4.  浏览并选择 Maven 项目的根文件夹(包含`pom.xml`文件的文件夹)。
5.  继续使用默认设置，点击**完成** `.`

这将把项目导入到 Eclipse 中。下面的屏幕截图显示了 Eclipse 中项目的结构:

![Creating Your First Spring Initializr Project](graphics/01_14.jpg)

让我们看看生成的项目中的一些重要文件。

### pom.xml

以下代码片段显示了声明的依赖项:

```
<dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies>
```

其他一些重要的观察结果如下:

*   该组件的包装为`.jar`
*   `org.springframework.boot:spring-boot-starter-parent`被声明为父 POM
*   `<java.version>1.8</java.version>`:Java 版本是 1.8
*   Spring Boot Maven 插件(`org.springframework.boot:spring-boot-maven-plugin`)被配置为插件

### FirstSpringInitializrApplication.java 类

`FirstSpringInitializrApplication.java`是 Spring Boot 的发射装置:

```
    package com.mastering.spring;

    import org.springframework.boot.SpringApplication;

    import org.springframework.boot.autoconfigure

    .SpringBootApplication;

    @SpringBootApplication

    public class FirstSpringInitializrApplication {

       public static void main(String[] args) {

        SpringApplication.run(FirstSpringInitializrApplication.class,   

        args);

      }

    }
```

### first springinitializrapplicationtests 类

`FirstSpringInitializrApplicationTests`包含当我们开始开发应用时，可以用来开始编写测试的基本上下文:

```
    package com.mastering.spring;

    import org.junit.Test;

    import org.junit.runner.RunWith;

    import org.springframework.boot.test.context.SpringBootTest;

    import org.springframework.test.context.junit4.SpringRunner;

    @RunWith(SpringRunner.class)

    @SpringBootTest

    public class FirstSpringInitializrApplicationTests {

      @Test

      public void contextLoads() {

      }

   }
```

# 快速浏览自动配置

自动配置是 Spring Boot 最重要的功能之一。在本节中，我们将快速了解一下幕后的情况，以了解 Spring Boot 自动配置是如何工作的。

Spring Boot 自动配置的大部分魔力来自于`spring-boot-autoconfigure-{version}.jar`。当我们启动任何 Spring Boot 应用时，都会自动配置一些 beans。这是怎么发生的？

下面的截图是来自`spring-boot-autoconfigure-{version}.jar`的`spring.factories`的摘录。为了节省空间，我们过滤掉了一些配置:

![A Quick Peek into Auto-Configuration](graphics/01_15.jpg)

每当启动 Spring Boot 应用时，就会运行前面的自动配置类列表。让我们快速看一下其中的一个:

`org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration`。

这里有一小段:

```
@Configuration

@ConditionalOnWebApplication

@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,

WebMvcConfigurerAdapter.class })

@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)

@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)

@AutoConfigureAfter(DispatcherServletAutoConfiguration.class)

public class WebMvcAutoConfiguration {
```

需要注意的一些要点如下:

*   `@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class })`:如果类路径中有任何提到的类，那么这个自动配置将被启用。当我们添加一个 web starter 项目时，我们引入了所有这些类的依赖关系。因此，这种自动配置将被启用。
*   `@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)`:只有当应用没有显式声明`WebMvcConfigurationSupport.class`类的 bean 时，才启用这种自动配置。
*   `@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)`:指定该特定自动配置的优先顺序。

让我们来看另一个小片段，它展示了同一个类中的一个方法:

```
    @Bean

    @ConditionalOnBean(ViewResolver.class)

    @ConditionalOnMissingBean(name = "viewResolver", 

    value = ContentNegotiatingViewResolver.class)

    public ContentNegotiatingViewResolver 

    viewResolver(BeanFactory beanFactory) {

      ContentNegotiatingViewResolver resolver = new 

      ContentNegotiatingViewResolver();

      resolver.setContentNegotiationManager

      (beanFactory.getBean(ContentNegotiationManager.class));

      resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);

      return resolver;

     }
```

视图解析器是由`WebMvcAutoConfiguration`类配置的 beans 之一。上面的代码片段确保了如果应用没有提供视图解析器，那么 Spring Boot 会自动配置一个默认的视图解析器。以下是需要注意的几个要点:

*   `@ConditionalOnBean(ViewResolver.class)`:如果`ViewResolver.class`在类路径中，则创建这个 bean
*   `@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)`:如果没有名称为`viewResolver`和类型为`ContentNegotiatingViewResolver.class`的显式声明的 bean，则创建这个 bean
*   该方法的其余部分在视图解析器中配置

总而言之，所有的自动配置逻辑都是在 Spring Boot 应用启动时执行的。如果某个特定的类(来自特定的依赖项或起始项目)在类路径中可用，那么将执行自动配置类。这些自动配置类查看已经配置了哪些 beans。基于现有的 bean，它们允许创建默认的 bean。

# 总结

Spring Boot 使得基于 Spring 的应用的开发变得简单。它使我们能够从项目的第一天就创建生产就绪的应用。

在本课中，我们讲述了 Spring Boot 和 REST 服务的基础知识。我们讨论了 Spring Boot 的不同特性，并创建了几个带有大量测试的 REST 服务。通过深入了解自动配置，我们了解了后台发生的事情。

在下一课中，我们将把注意力转移到为 REST 服务添加更多特性上。

# 评估

1.  _______ 类可用于从 Java main 方法引导和启动 Spring 应用。
2.  以下哪种方法用于将本地主机 URL 和端口附加到 URI 以创建完整的 URL？

    1.  私有 URL(字符串 uri)
    2.  私有字符串 create(字符串 uri)
    3.  私有字符串 CreateURL(字符串 uri)
    4.  私有字符串 createURL(字符串 uri)

3.  判断对错:Tomcat 服务器在端口 8080 上启动- Tomcat 在端口 8080 (http)上启动。
4.  以下哪个入门模板支持各种单元测试框架，如 JUnit、Mockito 和 Hamcrest？这些框架在 Spring Boot 完成了编排锁争用的工作。

    1.  spring-boot-starter-test
    2.  spring-boot-starter-test frame
    3.  spring-boot-starter-unittest
    4.  spring-boot-starter-test orchestration

5.  判断正误:multipartResolver 不支持在 web 应用中上传文件。