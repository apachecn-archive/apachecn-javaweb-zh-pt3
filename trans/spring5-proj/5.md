# 使用 JHipster 查看国家及其 GDP 的应用

随着时间的推移，不断变化的业务功能要求交付团队快速生产高质量的软件产品。为了满足这种期望，IT 行业已经开始关注软件开发过程的简化和自动化。因此，许多新的平台正在出现，其目标是生成代码以立即准备生产就绪的应用。

我们从一个在 Spring Framework 中开发的简单应用开始了我们的旅程，该应用使用世界银行 API 显示了各个国家的国内生产总值信息，在[第 1 章](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml)、*中创建了一个应用，列出了世界各国的国内生产总值信息 ( **GDP** )。Spring 框架提供了一种全面的方式来轻松开发企业级应用。*

随着 Spring Boot 框架的诞生，使用 Spring 框架的开发变得比以往任何时候都更快、更智能。在随后的章节中，我们继续讨论 Spring Boot，探索它的功能，特别是与其他 Spring 和第三方库和模块的集成。

在这一章中，我们将探索另一个名为 JHipster 的框架，它在制作基于 Spring 的应用方面领先了一步，只需点击几下鼠标，就能让 Spring 开发充满乐趣。我们将利用 JHipster 开发第 1 章、*中的应用，创建一个列出世界各国 GDP 的应用，*显示各个国家的 GDP 信息，并展示开发过程是如何简化和自动化的。我们将在本章中讨论以下有趣的主题:

*   JHipster 简介
*   装置
*   应用创建
*   实体的建模和创建
*   创建 GDP 应用
*   了解如何在 JHipster 应用中添加定制
*   JHipster 的其他特性

# 技术要求

本章用到的所有代码都可以从以下 GitHub 链接下载:[https://GitHub . com/packt publishing/Spring-5.0-Projects/tree/master/chapter 05](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05)。该代码可以在任何操作系统上执行，尽管它只在 Windows 上测试过。

# JHipster 简介

简而言之，JHipster 是一个代码生成工具，构建在大量开发、构建、测试和部署框架和平台之上。它是一个现代的 web 应用开发平台，用于构建一个全面的基于 Java 的 web 应用的所有层，从前端到数据库。JHipster 支持各种框架，让用户在开始应用开发时有多种选择。

JHipster 是一个免费的开源平台，旨在大大简化在 Spring Framework 和 Angular 或 React 技术上生成、开发和部署单片和基于微服务的应用的过程。在 JHipster 中构建应用之前，用户会被询问各种问题，以便根据用户选择的选项生成一个生产就绪的应用。JHipster 为应用提供了对以下现成工具和框架的支持:

*   构建工具: Maven，Gradle
*   **开发平台:** Spring 框架
*   **安全框架:**Spring安全
*   **模板:**百里香叶
*   **微服务:**网飞 OSS
*   RDBMS: H2，MySQL，Oracle，PostgreSQL，MS SQL，MariaDB
*   **数据流:**卡夫卡
*   **数据库跟踪器:** Liquibase
*   NoSQL: 蒙博德布，卡珊德拉，库什基，黑兹尔卡斯特
*   **缓存实现:** Infinispan，Ehcache
*   **搜索引擎:** Elasticsearch 和 **Elasticsearch、Logstash 和 Kibana** stack ( **麋鹿**)
*   **监控:**普罗米修斯
*   **ORM:** 冬眠
*   **测试框架:**黄瓜、浏览器同步、笑话、量角器测试
*   **负载测试:**加特林
*   **UI:** Bootstrap，HTML5，CSS3，SaaS，Redux
*   **JavaScript 框架:** Angular，Typescript，React，Webpack
*   **部署:**码头工、库员、箱体工、牧场工
*   **云支持:** Heroku，Cloud Foundry，AWS，OpenShift
*   **CI/CD:** 詹金斯，特拉维斯 CI，吉特拉布 CI，切尔莱西

JHipster 生成的代码符合行业标准、最佳实践和质量合规性。除了自动生成应用代码之外，JHipster 还支持自动化测试，以及以更加简化的方式持续集成和交付应用。这可以给组织带来巨大的好处，如下所示:

*   以统一和受控的方式创建具有各种平台和框架的应用。
*   大部分样板代码是自动生成的，因此开发人员可以专注于业务需求的实现。这将提高开发人员的生产力，并极大地改善整个项目交付时间表。
*   从前端到数据库表，轻松集成整个应用中的更改。
*   总体上提高了应用的代码质量。
*   组织中的不同项目可以轻松地共享公共工件。因此，项目团队的整体生产力将得到提高。

# 安装 JHipster

JHipster 建议普通用户用`npm`安装。`npm`是来自`Node.js`的软件包管理器，用来安装各种软件。它是世界上最大的软件仓库，在这里你可以找到成千上万的开源软件，以软件包的形式。如果没有安装`npm`，就去节点站点的下载部分(【https://nodejs.org/en/download】T4)安装最新的 64 位**长期支持** ( **LTS** )版本，因为 JHipster 不支持非 LTS 版本。

一旦安装了`npm`,从命令行运行下面的命令来安装 JHipster 包:

```
npm install -g generator-jhipster
```

JHipster 使用另一个名为**Yeoman**(【http://yeoman.io/】T2)的工具来生成应用代码，该代码随 JHipster 节点包一起安装。在创建一个应用之后，JHipster 提供了一个用 Maven 或 Gradle 构建它的选项。为此，JHipster 将为 Maven 和 Gradle 安装所需的包装器，因此没有什么是明确需要的，尤其是构建应用。

JHipster 的本地安装也可以用 Yarn 来完成，Yarn 是另一个安装软件的包管理器。用纱线安装 JHipster 的过程和`npm`几乎一模一样。

# 创建应用

安装 JHipster 之后，下一步是创建应用。在本地计算机上创建一个具有适当名称的项目目录，从命令提示符下选择该目录，并执行以下命令。项目目录的名称为`gdp`，但它可以是任何有效的名称:

```
jhipster
```

在点击这个命令后，JHipster 将开始询问一系列问题，并根据用户给出的答案决定必须生成什么，如下所示:

1.  您想创建哪种类型的应用？有四种可能的选项可供选择，如下所示:
    *   **单片应用:**该选项用于创建一个独立的应用。这是创建简单应用的推荐选项，因此我们将选择此选项。
    *   **微服务应用:**如果你想设计一个基于微服务架构的应用，可以选择这个选项。
    *   **微服务网关:**微服务网关用于通过 UI 构建基于微服务的应用。默认情况下，微服务应用没有 UI。
    *   **jip ster UAA 服务器:**jip ster 支持使用***(***)用户认证和授权创建应用。****

 ****2.  您的应用的基本名称是什么？您需要为您的应用命名。默认情况下，它采用与项目目录相同的名称。如果你愿意，你可以给它另一个名字。
3.  你默认的 Java 包名是什么？接下来，你需要给出一个 Java 包名。你可以给一个合适的名字(它将被认为是一个基础包，所有其他的 Java 源文件将在与这个包相关的各自的包中生成)。
4.  **您是否希望使用 JHipster 注册表来配置、监控和扩展您的应用？**这个问题涉及到在我们的应用中使用 JHipster 注册中心。注册表广泛用于基于微服务的应用中，用于注册各种服务。对于单一的应用，我们仍然可以使用它，因为尽管它是一种注册表，但它关系到应用的健康，这有助于我们监控应用。这是一张图片。为了简单起见，我们不打算使用它，所以选择 No 并继续。

5.  您想使用哪种类型的身份验证？接下来是认证机制。它提供了三个选项供选择，如下所示。我们将选择第三个选项(HTTP 会话身份验证):
    1.  **JWT 认证:****JSON Web Token**(**JWT**)，是以 JSON 形式在双方之间传递信息的开放标准。身份验证是 JWT 最常见的用例。
    2.  **OAuth2/OIDC 认证:** JHipster 通过 Keycloak 和**OpenID Connect**(**OIDC**)为 OAuth2 提供完整的支持，当我们选择该选项时默认生成。Keyclock 是一个开源的身份代理和访问管理解决方案。**Open ID Connect**(**OIDC**)，这是 OAuth2 协议之上的一个简单身份层。
    3.  **HTTP 会话认证:**基于会话认证用户。这是最常用的选项。

6.  您想使用哪种类型的数据库？接下来，它将询问我们希望在应用中使用的数据库类型。JHipster 支持各种 SQL 数据库。它还支持三个 NoSQL 数据库——MongoDB、Couchbase 和 Cassandra，后者有一个 Spring 数据后端。我们将选择 SQL。

7.  **您想使用哪个生产/开发数据库？**您将被要求回答不同的问题，以选择用于生产和开发的特定数据库。JHipster 为各种环境(如开发、生产等)维护各种配置文件。它将根据您选择的选项配置数据库。在我们的例子中，我们将选择 MySQL 进行生产和开发。
8.  你想使用 Spring 缓存抽象吗？再往前，它会询问缓存机制的类型，比如 Ehcache、Hazelcase、Memcached，或者根本没有缓存；Spring cache 抽象将用于插入其中的任何一个。我们可以根据我们特定的业务需求和底层硬件体系结构(单节点、多节点、分布式等)选择其中任何一种。我们将选择 Ehcache(默认选中)。
9.  **要不要用 Hibernate 二级缓存？**在这里，我们可以选择使用 Hibernate 的二级缓存。为此选项选择“是”。

10.  你想用 Maven 还是 Gradle 来构建后端？您将被要求选择 Maven 或 Gradle 作为构建工具。我们会选择 Maven。

11.  您还想使用其他哪些技术？到最后，JHipster 会要求添加一些额外的技术，比如 Elasticsearch、WebSocket、Kafka 的异步消息传递，以及 OpenAPI generator 的 API 优先开发。API-first 是一种先用 API 设计应用，然后在这些 API 的基础上开发 web 或移动应用的方法。现在，许多公司都在采用这种方法，JHipster 支持开箱即用。为了简单明了，我们不会选择其中任何一个。由于这是一个多项选择选择器，您可以只按*回车*继续移动，而不选择任何一项。
12.  您想为客户端使用哪个框架？下一个问题要求您选择一个前端框架，Angular 或 React。选择角度并按下*键进入*。
13.  您想要启用 Sass 样式表预处理程序吗？接下来，它会问你是否使用**语法棒的样式表** *(* **Sass** )样式表预处理器。选择是。

14.  **您想要启用国际化支持吗？**如果您希望增加对国际化的支持，请选择一种本地语言。选择英语作为答案。
15.  **请选择要安装的其他语言:**除了您的母语，您还可以添加对其他语言的支持。JHipster 支持大约 30 种语言。为了简单起见，我们不会添加任何额外的语言。
16.  除了 JUnit 和 Jest，你还想使用哪些测试框架？您将被要求在这个屏幕上选择单元测试框架。JHipster 支持 Gatling、Cucumber 和量角器框架，以及用于单元测试的默认 JUnit。一个都不选，进入下一步。
17.  **您是否愿意安装 JHipster Marketplace 上的其他发电机？**最后一个问题将询问您是否从 JHipster marketplace 添加其他模块。这是一个第三方生成器的集合，它工作在核心 JHipster 之上，可以访问它的变量和函数，就像子生成器一样。您可以通过从 JHipster market place(【https://www.jhipster.tech/modules/marketplace】T2)下载它们，在您的应用中使用它们。对于此选项，我们将选择“否”。

# 项目结构

现在，坐下来放松一下，JHipster 将开始根据我们选择的选项创建一个应用。此时，JHipster 将生成我们应用的代码和项目结构。简而言之，JHipster 生成以下内容来使应用准备好运行:

*   Spring Boot 应用
*   Angular JS 应用(在前端)
*   Liquibase changelog 文件(用于数据库表**数据定义语言** ( **DDL** )操作)
*   其他配置文件

一旦创建了应用，我们可以配置一个**集成开发环境** ( **IDE** )用于进一步的开发。JHipster 支持广泛的 ide，包括 Eclipse、IntelliJ IDEA 和 Visual Studio 代码。你可以在 https://www.jhipster.tech/configuring-ide 的[了解更多关于这个话题的信息。应用结构如下所示:](https://www.jhipster.tech/configuring-ide)

![](assets/a829a4fe-b517-4e16-904a-460778640e35.png)

让我们看看每个 Java 包，如下所示:

*   `com.nilangpatel.aop.logging`:包含了**面向方面编程** ( **AOP** )的日志建议。
*   `com.nilangpatel.config`:这个包包含了属性、缓存、数据库、概要文件、Liquibase、日志、Spring Security、metrics、web、locale 等等的各种配置，以及应用中使用的常量。
*   JHipster 提供了现成的审计特性。该软件包包含专门用于审计的配置。
*   `com.nilangpatel.domain`:这包含了我们创建的定制实体的所有模型对象，以及其他核心模型对象。

*   `com.nilangpatel.domain.enumeration`:这包含了我们在 **JHipster 领域语言** ( **JDL** )中声明的枚举。我们将在接下来的部分更多地讨论 JDL。
*   `com.nilangpatel.repository`:Spring Data**Java Persistence API**(**JPA**)每个定制的和现成的实体的仓库，都存储在这里。
*   `com.nilangpatel.security`:所有与安全相关的类，比如`Roles`、`UserDetail`服务的常量等等，都存储在这个包中。
*   `com.nilangpatel.service`:这包含了现成的和定制的实体的服务层接口。
*   `com.nilangpatel.service.dto`:这里保存了**数据传输对象** ( **DTOs** ，用于控制器和服务之间的传输。
*   `com.nilangpatel.service.mapper`:用于用 d to 映射模型对象的映射器类将存储在这个包中。
*   这个包包含了一些实用程序类。
*   `com.nilangpatel.web.rest`:每个实体的所有**代表性状态转移** ( **其余**)控制器都在这个包下生成。
*   特定于 REST 调用的异常在此处可用。
*   `com.nilangpatel.web.rest.util`:这包含了一些在 REST 调用中使用的工具类。
*   `com.nilangpatel.web.rest.vm`:包含视图模型，主要用于 UI 中的管理页签。

除了 Java 类和包，JHipster 还在`src/main/resource`文件夹中生成某些资源。详情如下:

*   `config`:这包含了各种配置文件，比如用于 Spring Boot 的`application.properties`和各种概要文件，一些 Liquibase 配置文件，以及用于导入和配置 HTTPS 配置证书的`changelog`文件和密钥库文件。
*   `i18`:它包含了我们在创建应用时选择的各种语言的属性文件。
*   `templates`:该文件夹包含各种邮件模板，如激活、账户创建、密码重置等，以及错误模板。

是时候运行应用了。JHipster 提供了以下命令来用 Maven 构建应用。确保您位于命令提示符下的项目目录中:

```
mvnw
```

在构建应用的同时，这个命令会将它部署到嵌入式 web 服务器上(默认情况下，它随 Spring Boot 一起提供)。可以在`http://localhost:8080`访问，如下所示:

![](assets/76273649-fcea-4793-bc5e-fadd4347a8ed.png)

如果需要在任何应用服务器上部署应用，JHipster 提供了一种生成可执行 WAR 文件的方法，Maven 使用命令`mvnw -Pprod package` ，Gradle 使用命令`gradlew -Pprod bootWar`。

JHipster 首先生成一组页面和几个用户帐户。点击帐户|登录，登录到应用。默认情况下，`Admin`用户可以使用凭证`admin/admin`登录，普通用户可以使用`user/user`登录。`Admin`用户可以访问管理菜单，在这里他们可以执行各种管理功能。

# 实体创建

一个 web 应用有某种数据库交互，至少包括基本的**创建、读取、更新和删除** ( **CRUD** )操作。手动完成时需要大量的工作。在这种情况下，需要完成以下任务:

*   创建数据库表，以及它们的关系和约束
*   构建模型实体，构建**数据访问** **对象** ( **道**)层，提供与数据库的数据接口
*   生成封装业务逻辑的服务层
*   准备 web 控制器和前端层，以及所有验证，以将数据存储在各自的实体表中

除此之外，可能需要额外的工作来适应任何层上的未来变化。JHipster 为这个问题提供了一个巧妙的解决方案。在创建一个应用之后，我们需要构建一个数据访问层，JHipster 使这整个过程自动化。

JHipster 中一个叫做**实体生成**的概念让这一切发生。实体是 JHipster 应用的构建元素。实体生成过程包括各种任务，如下所示:

*   创建数据库表并维护它们的更改(通过配置)
*   构建 JPA 模型类，以及 Spring 数据 JPA 存储库
*   创建可选的服务层以适应业务规则
*   创建支持基本 CRUD 操作和前端角度路由器的 REST 控制器
*   组件和服务以及 HTML 视图，包括集成和性能测试

是不是很酷？我们来见证一下做实体，自动生成代码的过程。

# 使用 CLI 添加实体

为了演示在 JHipster 中创建实体的过程，我们将首先创建一个简单的实体，名为 **Owner** ，有一个属性，名为 **name** 。JHipster 允许实体创建的方式，以及实体的数据访问、服务层、控制器和前端层与我们在上一节中看到的生成应用代码的过程是相同的。这两者都可以通过 CLI 完成。

对于实体生成，JHipster 在内部使用 Yeoman 工具来生成代码。让我们创建我们的第一个实体。执行以下命令创建实体:

```
jhipster entity Owner
```

`Owner`是一个实体的名称。该命令将为`Owner`创建一个实体，并将启动一个向导，询问用户几个问题，如下所示:

1.  **您想在您的实体中添加字段吗？**如果您希望为您的实体添加一个字段，选择 *y* 。
2.  你的领域叫什么？您可以在此给出属性的名称。
3.  你的领域是什么类型的？您需要提供属性的类型。JHipster 支持多种属性类型，包括`string`、`integer`、`long`、`float`、`double`、`BigDecimal`和`LocalDate`。
4.  您想在您的字段中添加有效性规则吗？这关系到您是否希望在实体的属性上添加任何约束。选择 *y* 。
5.  **您想添加哪个验证规则？** JHipster 还允许您添加各种约束，包括`required`、`unique`、`min`值、`max`值和正则表达式模式，以验证输入。您可以在此选择多个约束。

可以重复前面添加属性的过程，向其类型和约束添加更多的属性。我们将创建具有`String`类型的`name`属性和`required`约束的`Owner`实体。

JHipster 还允许您定义与另一个实体的关系。一旦我们添加完属性，它会要求我们添加一个关系。由于我们只创建了`Owner`实体，我们将在添加另一个实体后添加关系。稍后我们将看到如何添加关系。

此时，只需对添加关系说 no ( *n* )即可，JHipster 将显示与服务和控制器层相关的下一组问题，如下所示:

6.  您想为您的业务逻辑使用单独的服务类吗？在这个问题中，我们被问到是否希望添加一个服务层，可能的选项如下。我们将选择第三个选项:
    1.  不，REST 控制器应该直接使用存储库；REST 控制器将直接调用存储库。不添加服务层。
    2.  是，生成一个单独的服务类；服务图层仅添加了服务类。REST 控制器将为任何数据库交互调用该类。我们可以在服务类中编写额外的业务逻辑。
    3.  可以，生成单独的服务接口和实现；在这种情况下，服务层添加了接口和实现。这种设计的明显优势是我们可以在不改变其他代码的情况下提供服务接口的另一种实现。
7.  **要不要用一个******？**下一个问题与 d to 有关。JHipster 提供了为每个实体创建 DTO 的选项。它使用 MapStruct，这是另一个用于映射 Java 实体以生成 d to 的代码生成器工具。基本上，它用于将值从 d to 映射到模型实体，反之亦然。这个问题的选项如下。我们将选择第二个选项:

    1.  否，直接使用实体；实体对象用于在所有层中传递数据。
    2.  可以，用 MapStruct 生成 DTO；这将生成对应于每个实体的 DTO。控制器将创建一个 DTO 实例，并将其传递给服务层。服务类将把 DTO 映射到实体，并调用存储库与数据库进行交互。** 
***   **您想添加过滤功能吗？**这将提供一个动态过滤选项来搜索特定实体。它使用 JPA 静态元模型来过滤选项。如果我们选择 Yes，JHipster 将创建完整的代码，从表示到 DAO。尽管使用 filter 选项非常有用，但为了简单起见，我们在这个问题中选择 No。**

 **9.  您想在您的实体上分页吗？下一个问题是关于分页模式。JHipster 支持以下分页模式。我们将选择第二个选项:
    1.  没有；这意味着没有分页。所有记录将在一个页面中可见。这将为大型数据集带来性能问题。
    2.  是，带有分页链接；这显示了带有在页面之间移动的链接的分页。这是最常见的分页样式。
    3.  是的，用无限卷轴；这使用无限滚动来显示数据。卷轴将起到分页的作用。

现在，JHipster 将开始创建实体，并在发现冲突时要求覆盖某些文件。这是因为 JHipster 将再次开始生成代码。对于所有的提示，继续说 yes (y)并按下 *Enter* ，最后，您将看到一条消息，表明实体已经创建。接下来，让我们创建另一个名为`Car`的实体，其属性为`name`、`model`和`manufacture year`。按照前面的步骤创建`Car`实体。

JHipster 提供了一个在实体创建期间建立关系的选项。因此，如果您刚刚添加了一个实体，并试图创建与另一个实体的关系，您将会得到一个错误，比如没有找到另一个实体。因此，当与另一个实体建立关系时，首先要确保它已经被创建。

第五步之后，它会询问添加关系。我们已经添加了一个`Owner`实体，我们希望建立一个多对一的关系(多个`Cars`可以与一个`Owner`相关联)。在第五步之后，下面是一组专门针对关系的问题:

1.  **您是否要向另一个实体添加关系？**这里选 Y。
2.  **其他实体的名称是什么？**这是指我们希望与之建立关系的实体的名称。在此给出实体名称`Owner`。
3.  **关系叫什么？**默认为`owner`(这是您想要给出的关系名称。默认情况下，系统将给出另一侧实体名称的小写名称。如果你愿意，你可以改变它)。
4.  **关系的类型是什么？**可能的选项有一对多、多对一、多对多和一对一。它们非常简单。我们将选择多对一，因为我们正在与`Car`实体建立关系。

5.  **当您在客户端显示** **这种关系时，您希望使用** `Owner` **中的哪个字段？**此问题询问在显示或添加`Car`数据时，是否应显示`Owner`实体的列名。在内部，JHipster 总是使用 ID 列来设置表之间的关系。给出`name`作为这个问题的答案，因为`Owner`只有一列(`name`)。
6.  是否要向此关系添加任何验证规则？这基本上增加了对外键列的验证。
7.  您想要添加哪些验证规则？需要进行可能的验证。

在这之后，它将从第 6 步开始提问。直到第 9 步添加`Car`实体。此时，我们有两个实体——`Owner`和`Car`——以及它们之间的关系，还有前端、控制器、服务层和 DAO 层的源代码。

现在，是时候构建我们的应用了。Maven 命令不仅会构建应用，还会在嵌入式服务器上部署和运行它。生成实体后，当我们用这个命令构建和部署应用时，JHipster 将创建/更新对应于每个实体的数据库表。

在构建应用之前，确保在`src/main/resources/config`文件夹的`application-prod.yml`文件中按照本地 MySQL 配置设置了数据库凭证。物业名称为`spring:datasource:username`和`spring:datasource:password` *。*如果不这样做，运行应用时会出现错误。

让我们为我们的实体添加一些数据。使用管理员凭据(`admin` / `admin`)登录，然后转到实体|所有者，首先添加所有者数据。“创建新所有者”按钮将用于插入所有者记录。类似地，我们可以为`Car`实体添加数据。由于我们已经创建了从`Car`到`Owner`的多对一关系(也就是说，许多`Car`实例与一个`Owner`相关联)，您将看到一个字段，您可以在其中选择一个`Owner`值，同时添加一个`Car`实体。

`Car`实体的记录以及对`Owner`实体的引用将如下所示:

![](assets/18d57ab2-fc3e-4c16-93cc-0678886ad8b2.png)

`Owner`实体的`name`属性的值在这里作为引用可见，这是我们在创建关系时选择的。这个页面还显示了链接类型的分页，这是我们在创建`Car`实体时选择的。除此之外，您可以对每个单独的实体执行 CRUD 操作，而无需自己编写一行代码。这绝对是一个很酷的特性，可以节省大量的开发时间和精力。

默认情况下，JHipster 创建一个 ID 列作为每个实体表的主键。对于代码的自动生成，不支持将自定义列定义为主键。但是，如果需要特定的列作为主键，那么在使用`mvnw`命令运行之前，您需要修改生成的源代码。

# 实体建模

您已经看到了 JHipster 如何通过自动化许多事情来加速开发。以前，在应用中建模一个实体需要许多活动，包括生成表格；DAO、服务和表示层的创建；以及用于每个单独实体的验证和用户界面。

虽然 Spring Boot 在编写样板代码方面提供了很大的帮助，但开发人员仍然需要编写大量代码才能看到事情的发生。这是一项相当乏味且逻辑上重复的工作。您已经看到了 JHipster 如何在这种情况下提供了巨大的帮助，它提供了自动生成代码来构建一个全功能的 Spring Boot 应用，而无需您自己编写一行代码。

设计一个有完整工作代码的实体，只是给 JHipster 提供某些信息的问题。乍一看，这看起来很棒，但是事情还有另外一面。考虑一个场景，其中您需要用 JHipster CLI 合并 50 多个实体，这在您编写企业应用时是完全可能的。有时，实体总数超过 100 个。

在这种情况下，用 CLI 编写每个实体并提供所有元数据，以及与其他实体的关系，是很痛苦的。作为一种变通方法，JHipster 提供了一个图形化工具，我们可以在其中一次性设计所有的实体。目的是简化用可视化工具定义关系的过程，而不是用经典的方法，用问题和答案来定义。有两种可视化实体建模的方法，如下所示:

*   用**统一建模语言** ( **UML** )建模
*   和 JDL 一起做模特

# 用 UML 建模

在这个选项中，我们需要将所有的实体设计成一个类图，然后将其导入到 JHipster 中，以便一次性为所有的实体生成代码。因此，整个过程分为两个独立工作的部分，如下所示:

*   用可视化工具设计实体类图
*   导出类图并将其导入 JHipster

在应用开发的早期阶段，类图主要用于设计领域模型。类图显示了类的属性和操作，以及它与其他类的关系，描述了应用的静态视图。类图中使用的类直接映射到面向对象的语言，并且还用于对数据库表建模。

JHipster 在应用代码的生成中提供了这一过程的好处。已经设计了一个单独的工具，叫做 JHipster UML 它读取类图来生成实体结构。它可以从 Git 存储库安装，或者作为一个单独的`npm`包安装，使用以下命令:

```
//For Global installation
npm install -g jhipster-uml

//For local installation
npm install jhipster-uml --dev
```

目前可用的大多数工具都允许将类图导出为 XMI 格式。JHipster UML 读取 XMI 文件并生成实体。因为这个工具从类图中生成 JHipster 中的实体，所以属性类型选择仅限于 JHipster 支持的类型列表。JHipster 支持的属性类型列表，以及每个属性类型可能的验证规则如下:

| **号** | **属性类型** | **可能的验证** |
| one | `string` | `required`、`minlength`、`maxlength`、`pattern` |
| Two | `integer` | `required`、`min`、`max` |
| three | `long` | `required`、`min`、`max` |
| four | `BigDecimal` | `required`、`min`、`max` |
| five | `float` | `required`、`min`、`max` |
| six | `double` | `required`、`min`、`max` |
| seven | `enum` | `required` |
| eight | `Boolean` | `required` |
| nine | `LocalDate` | `required` |
| Ten | `ZonedDateTime` | `required` |
| Eleven | `blob` | `required`、`minbytes`、`maxbytes` |
| Twelve | `AnyBlob` | `required`、`minbytes`、`maxbytes` |
| Thirteen | `ImageBlob` | `required`、`minbytes`、`maxbytes` |
| Fourteen | `TextBlob` | `required`、`minbytes`、`maxbytes` |

首先，我们需要为每个领域模型设计类图，以及它们之间的关系。JHipster 建议使用以下工具来生成类图:

*   Modelio
*   UML 设计器
*   GenMyModel

其中，前两个是完全开源的、基于 Eclipse 的图形工具，可以从各自的站点下载，而第三个是基于浏览器的免费工具，可以直接在 web 上使用(有一定的限制)。一旦类图准备好了，将它导出到一个 XMI 文件中，并在命令提示符下执行下面的命令来生成实体结构。执行此命令时，请确保您位于项目目录中:

```
jhipster-uml <class-diagram.xmi>
```

这将生成实体结构。JHipster UML 还提供了各种选项来指定分页模式，例如您是否想要使用 DTO 或者为您的每个实体添加服务类。它可以与前面的命令一起给出，如下所示:

```
// If you wish to use DTO. The possible values would be MapStruct
jhipster-uml <class-diagram.xmi> --dto <value>

//Type of pagination pattern.The possible values are [pager,pagination,infinite-scroll]
jhipster-uml <class-diagram.xmi> --paginate <value>

//If you need to add service layer with class and implementation. The values would be [serviceClass,serviceImpl]
jhipster-uml <class-diagram.xmi> --service <value>
```

基于您提供的选项，JHipster UML 生成实体和其他源代码。最后，您需要执行`mvnw`命令，以便在数据库中创建/修改所需的实体表，以及 Liquibase changelog 文件，并将应用部署到服务器。在定义类图中的类之间的关系时，您需要确保它们在 JHipster 中是允许的。支持的关系如下:

*   双向一对多关系
*   单向的多对一关系
*   多对多关系
*   双向一对一的关系
*   单向的一对一关系

JHipster 代码生成器不支持现成的单向一对多关系。JHipster 建议使用双向一对多关系。

# 用 JHipster 领域语言工作室建模

将域模型设计成类图，然后基于类图生成源代码，这是在 JHipster 中创建实体的一种非常快速的方法。因此，与使用 CLI 逐个创建它们相比，这样可以节省时间。但是，您仍然需要依赖第三方应用来使用 JHipster。JHipster 对特定版本的支持可能非常有限，或者在最坏的情况下，完全不兼容。

作为解决方案，JHipster 提供了一个独立的工具，名为 **JDL 工作室**。它是一个创建实体并在实体之间建立关系的在线工具。使用 JDL 工作室的明显好处是，它是由 JHipster 团队设计和维护的，因此几乎没有版本不兼容和其他问题的机会。使用稳定版的时候可以放心。如有任何问题，您可以从 JHipster 官方问题跟踪中心轻松获得更新或支持。

用 JDL 工作室创建实体甚至比用 UML 建模实体更简单。JHipster 领域语言 ( **JDL** )，这是一种领域语言，用于在单个文件(有时是多个文件)中用非常简单易用的语法构建实体。

与 JDL 合作有两种方式。你可以使用 JHipster IDE 或者在线的 JDL 工作室([https://start.jhipster.tech/jdl-studio](https://start.jhipster.tech/jdl-studio))。JHipster IDE 是一些知名 IDE 的插件或扩展，包括 Eclipse、Visual Studio 和 Atom。在线 JDL 工作室是一个基于浏览器的集成开发环境，你可以用脚本的形式构建实体和它们之间的关系，这是在 JDL 写的。您可以将它与编写用于创建数据库表的 SQL 脚本以及它们之间的关系联系起来。

为了简单起见，我们将看一个用在线 JDL 工作室创建实体的简单例子。在为每个实体编写定义时，JDL 工作室绘制了实体图，并列显示了它们之间的关系。当打开在线 JDL 工作室，你会看到一些样本实体，以及它们的关系和其他参数，默认情况下，给你一些关于如何开始使用它的想法。

让我们在在线 JDL 工作室中创建`School`和`Teacher`实体，以及它们之间的关系(一对多)。打开 URL 并添加这些实体的定义，如下所示:

```
entity School {
  name String required
    eduType EducationType required
    noOfRooms Integer required min(5) max(99)
}
enum EducationType {
  PRIMARY, SECONDARY, HIGHER_SECONDARY 
}
entity Teacher {
  name String required
    age Integer min(21) max(58)
}
// defining multiple one-to-many relationships with comments
relationship OneToMany {
  School{teacher} to Teacher{school(name) required}
}
// Set pagination options
paginate School with infinite-scroll
paginate Teacher with pagination

// Use data transfer objects (DTO)
dto * with mapstruct

// In case if DTO is not required for specific (comma separated)entities.
// dto * with mapstruct except School

// Set service options to all except few
service all with serviceImpl

// In case if service layer is not required for certain 
// (comma separated) entities. Just uncomment below line
// service all with serviceImpl except School
```

每个实体都可以用关键字`entity`来定义，以及它的属性和数据类型。我们还可以在每个属性上定义某些验证。这些验证不仅在数据库表级别施加了相应的约束，还在前端施加了约束。`maxlength`验证表示给定属性的最大列长度。`min`和`max`验证描述了要输入的最小值和最大值。实体之间的关系可以用以下语法定义:

```
relationship (OneToMany | ManyToOne | OneToOne | ManyToMany) {
  <OWNER entity>[{<Relationship name>[(<Display field>)]}] to <DESTINATION entity>[{<Relationship name>[(<Display field>)]}]
}
```

`relationship`可用于各种选项，如下所示:

*   关系的可能类型。
*   `OWNER entity`:关系的所有者实体。也可以说是关系的来源。拥有方实体必须在左侧。
*   `DESTINATION entity`:这是关系结束的彼岸实体，目的地。
*   `Relationship name`:表示对方类型的字段名称。
*   `Display field`:在为实体添加记录时，JHipster 在屏幕上显示另一侧实体下拉菜单。此属性显示将在下拉菜单中显示的另一方实体的字段名称。默认情况下，它是另一端实体的 ID(主键)。
*   `required`:决定下拉菜单中是否需要选择对方主体。

`paginate`、`dto`和`service`关键字分别用于定义分页模式的配置选项，是否需要生成 d to，以及是否需要生成带有实现的服务层。它们非常简单，您可以在使用 CLI 创建实体时将其与相应的选项相关联。JHipster 还支持 mass(用`*`)和 exclude 选项(用`except`关键字)，这些选项非常强大和方便。简而言之，支持各种实体子生成器特性，比如字段类型、验证、关系、dto、服务、枚举等等。JDL 工作室根据我们实体的定义生成一个图表，如下所示:

![](assets/33f9fd8b-cf14-4061-85c7-5bfc4034b784.png)

在本例中，我们定义了一个双向关系。如果需要单向关系，只需要去掉两边的名字或者关系就可以了。例如，`School`和`Teacher`实体之间的单向关系可以定义如下:

```
relationship OneToMany {
  School to Teacher
}
```

JHipster 不支持单向的、一对多的关系，但它看起来是这样的。在定义关系时，您需要了解 JHipster 所支持的关系，这一点我们在上一节中已经讨论过了。

除了生成实体代码，JDL 还用于从头开始创建应用，以及部署选项。因此，您可以在单个 JDL 文件中定义所有配置选项，并一次性创建应用，而不是在 CLI 中使用基于问答的方法。

# 使用模型生成实体

我们已经在 JDL 工作室定义了实体。现在，我们将指导 JHipster 生成实体，以及数据库表和源代码。该过程涉及以下两项任务:

*   导出实体定义
*   导入 JDL 文件以生成所需的工件

从 JDL 工作室，你可以导出定义为 JDL ( `.jh`)文件。JHipster 提供了一个子生成器，它将用于导入 JDL 文件，命令如下:

```
jhipster import-jdl <your_jdl_file.jh>
```

不用说，您需要在 JHipster 项目目录下执行这个命令。在成功构建和部署之后，您将从 entities 菜单中看到`School`和`Teacher`实体。您还可以验证是否生成了相应的表。如果一个应用有大量的实体，很难将它们都放在一个 JDL 文件中。如果一个实体有错误，整个生成实体的过程将无法正常工作。在最坏的情况下，如果多个团队在工作，那么就会产生维护问题。

JHipster 通过允许多个 JDL 文件解决了这个问题，这样相关的实体就可以分组到单独的 JDL 文件中。`import-jdl`子生成器允许导入多个由空格分隔的文件。在第一次执行这个命令时，它将生成实体和所有的源代码。您需要使用`mvnw`命令构建和部署应用，以便必要的数据库更改能够得到反映。

第二次及随后，`import-jdl`将只重新生成已改变的实体。如果您希望从头开始再次生成所有的实体，您将需要添加`- force`选项。请注意，此选项将删除应用于实体的所有定制。在我们使用`mvnw`命令构建和部署应用时，会捕获某些验证，如下所示:

*   不允许在类型为`integer`、`long`、`BigDecimal`、`LocalDate`、`Boolean`、`enum`、`double`等的列上进行`maxlength`和`minlength`验证。
*   如果给定实体的服务层被转义，那么如果为该实体选择了带有`mapstruct`的 DTO 选项，JHipster 会显示一个警告。在这种情况下，应用可能无法正常工作。
*   添加单行注释时，需要在`//`后加一个空格，否则 JHipster 会显示错误，实体无法正常生成。

# 显示国家国内生产总值

既然您已经了解了如何创建一个应用并对实体建模，我们将开始创建一个用 JHipster 显示各个国家 GDP 的应用。我们这样做是为了展示 JHipster 在自动生成的代码中应用定制的能力。

# 应用和实体创建

参考*创建应用*部分创建一个新的应用，将其命名为`gdp`。我们将构建一个与我们在第一章[，*中用 Spring Framework 创建的应用功能相似的应用，创建一个列出世界各国 GDP 的应用*。为了显示不同国家的 GDP 数据，我们从 MySQL 数据库(](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml)[https://dev.mysql.com/doc/index-other.html](https://dev.mysql.com/doc/index-other.html))中引用了一个样本国家、城市和国家语言数据，并使用 REST 服务通过世界银行 API([https://data help desk . World Bank . org/knowledge base/articles/898614-aggregate-API-queries](https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries))获取给定国家的 GDP 数据。我们将使用相同的引用来构建一个带有 JHipster 的应用。

为了简单起见，我们将使用满足应用目的所必需的列。首先理解表结构是很重要的。数据库表及其关系详情如下:

![](assets/bef82c37-c2d0-4ecd-bfdd-2c6bf417b7d9.png)

让我们首先定义实体。JHipster 推荐 JDL 用于实体和代码生成，因此我们将使用它来创建我们的实体结构，并生成我们的服务层、REST 控制器和 DTO，以及一组用于前端层的组件。JDL 脚本如下所示:

```
entity Country{
  code String required maxlength(3)
    name String required maxlength(52)
    continent Continent required
    region String required maxlength(26)
    surfaceArea Float required
    population Integer required
    lifeExpectancy Float
    localName String required maxlength(45)
    governmentForm String required maxlength(45)
}
entity City{
  name String required maxlength(35)
    district String required maxlength(20)
    population Integer required
}

entity CountryLanguage{
    language String required
    isOfficial TrueFalse required
    percentage Float required
}

enum Continent {
  ASIA, EUROPE, NORTH_AMERICA, AFRICA, OCEANIA, ANTARCTICA, SOUTH_AMERICA
}

enum TrueFalse{
  T, F
}

// Set pagination options
paginate Country, City, CountryLanguage with pagination

// Use data transfer objects (DTO)
dto * with mapstruct

// Set service options. Alternatively 'Service all with sericeImpl can be used
service all with serviceImpl

relationship OneToMany{
  Country{city} to City {country(name) required}
  Country{countryLanguage} to CountryLanguage{country(name) required}
}
filter Country
```

这个脚本包含各个表的实体定义，以及用于`Continent`和`TrueFalse`的`enum`。我们还定义了分页模式、DTO 结构和带有`Service`类和接口(`serviceImpl`)的服务层，以及一种关系。`Country`将与`City`和`CountryLanguage`都有一对多的关系。

关系中的`country(name)`，另一边会显示国家名称作为参考，而不是默认的国家的`ID`。请特别注意最后一个选项— `filter`。这为`Country`实体声明了`filter`选项，用于在获取实体记录时应用各种过滤标准。我们将在*开发定制屏幕*部分对此进行更详细的探讨。JDL 图应该如下所示:

![](assets/e0bc985b-b705-49ba-80c6-8600ee143d69.png)

由于我们在 MySQL 提供的每个表中省略了一些列，所以还需要在这些表各自的插入脚本中进行必要的更改。您将在项目结构的`download`文件夹中找到修改后的插入脚本。此时，您必须在继续下一步之前应用插入脚本。

# 用 JHipster 中的数据库处理枚举数据

接下来，我们将运行应用，并验证 JHipster 已经创建了三个实体，并且它们在 entities 菜单中可以执行各种 CRUD 操作。第一次运行应用时，我们会得到一个错误，如下所示:

```
org.springframework.dao.InvalidDataAccessApiUsageException: Unknown name value [Asia] for enum class [com.nilangpatel.domain.enumeration.Continent]; nested exception is java.lang.IllegalArgumentException: Unknown name value [Asia] for enum class [com.nilangpatel.domain.enumeration.Continent] at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:367) ....
```

当获取大陆数据并尝试将其映射到`Continent`枚举数据类型时，会出现此错误。根本原因是我们将`Country`实体的`continent`列的类型定义为`Continent`枚举。该列中的实际值是通过插入脚本(来自 MySQL 站点)添加的，与`Continent`枚举值并不完全相同。比如数据库中的实际值是`Asia`，而对应的 enum 是`ASIA`。

`continent`列的另一个值是`North America`，而对应的枚举是`NORTH_AMERICA`。由于 Java 中 enum 的限制，我们不能在值的中间放一个空格，这就是我们保留值为`NORTH_AMERICA`、`SOUTH_AMERICA`等的原因。由于这种限制以及大小写的不同，在运行应用时，您将会得到前一个异常。

作为一种变通方法，我们需要提供某种从数据库列中的实际值到 Java 中的枚举值的映射。为此，我们将使用 JPA 属性转换器机制。它主要用于定义一种方法，将数据库值转换为属性的 Java 表示，反之亦然。打开`com.nilangpatel.domain`包中的`Country.java`类，并更新`continent`属性的注释声明，如下所示:

```
@NotNull
//@Enumerated(EnumType.STRING) // commented original
@Convert(converter=ContinentEnumConvertor.class) // added newly
@Column(name = "continent", nullable = false)
private Continent continent;       
```

本来定义为`@Enumerated(EnumType.STRING)`，加了`@Convert`注释注释掉了。这个注释需要实现`javax.persistence.AttributeConverter`接口。该实现由如下的`ContinentEnumConvertor`自定义类提供:

```
public class ContinentEnumConvertor implements AttributeConverter<Continent, String>{
  @Override
  public String convertToDatabaseColumn(Continent continent) {
    return continent.getName();
  }
  @Override
  public Continent convertToEntityAttribute(String continentValue) {
    return Continent.getContinent(continentValue);
  }
}
```

这两个方法将在数据库和 Java 中相应的 enum 值之间转换值。我们还需要对`Continent`枚举类进行必要的修改，如下所示:

```
public enum Continent {
  ASIA("Asia"), EUROPE("Europe"), NORTH_AMERICA("North America"), AFRICA("Africa"), OCEANIA("Oceania"), ANTARCTICA("Antarctica"), SOUTH_AMERICA("South America");
    private String name;
  Continent(String name){
    this.name=name;
  }
  public String getName() {
    return this.name;
  }
  public static Continent getContinent(String name) {
    Continent returnContinent = null;
    switch(name){
      case "Asia": returnContinent = Continent.ASIA;break;
      case "Europe": returnContinent = Continent.EUROPE;break;
      case "North America": returnContinent = Continent.NORTH_AMERICA;break;
      case "Africa": returnContinent = Continent.AFRICA;break;
      case "Oceania": returnContinent = Continent.OCEANIA;break;
      case "Antarctica": returnContinent = Continent.ANTARCTICA;break;
      case "South America": returnContinent = Continent.SOUTH_AMERICA;break;
      default: returnContinent = null;
    }
    return returnContinent;
  }
}
```

运行应用，您将看到实体和 JHipster 只允许登录用户执行 CRUD 操作。但是，您仍然会看到洲值被呈现为枚举值，如`ASIA`、`NORTH_AMERICA`等，而不是实际的数据库列值。

这样做的原因是，当在创建应用时启用国际化支持时，JHipster 会为各种标签、错误消息和各种枚举生成显示值。它很好地在一个单独的文件中为每个工件创建了键值对。这些文件是在`src/main/webapp/i18n`文件夹下为每个特定语言的文件夹生成的。例如，`Country`实体的语言键及其值是在`src/main/webapp/i18n/en/country.json`文件中创建的。

因为我们的应用只有一种语言`English`，所以只为`English`语言生成语言键，在`en`文件夹下，如下所示:

![](assets/c191091e-0820-4a1f-8179-e321890ce937.png)

键和值是以 JSON 格式创建的。要理解其结构，请打开`country.json`文件，如下所示:

```
{
    "gdpApp": {
        "country": {
            "home": {
                "title": "Countries",
                "createLabel": "Create a new Country",
            },
            "created": "A new Country is created with identifier {{ param }}",
            "delete": {
                "question": "Are you sure you want to delete Country {{ id }}?"
            },
            "detail": {
                "title": "Country"
            },
            "code": "Code",
            "name": "Name",
            "continent": "Continent",
          ....
        }
    }
}
```

使用`gdpApp.country.home.title`键可以访问标题。这将在 HTML 模板中使用。打开`/src/main/webapp/app/entities/country`文件夹下的`country.component.html`文件，你会看到下面的代码来使用这个键:

```
<div>
    <h2 id="page-heading">
        <span jhiTranslate="gdpApp.country.home.title">Countries</span>
    ....
```

JHipster 创建了各种模块来支持验证、枚举、读取和解析 JSON 等等。其中一个`translation`，支持国际化。这些在 JHipster 安装过程中作为一个`jhipster-core`包安装在项目目录下创建的`node_modules`文件夹下。如果需要添加更多的标签，可以将键放在相应的 JSON 文件中，并使用`jhiTranslate`来呈现值。

现在，回到我们在屏幕上为`Country`实体显示枚举值的问题，而不是实际的数据库值。这是因为默认情况下，`continent.json`中的转换是用一个枚举值生成的。为了在屏幕上显示正确的洲值，您可以按如下方式进行更改:

```
 "ASIA": "Asia",
 "EUROPE": "Europe",
 "NORTH_AMERICA": "North America",
 "AFRICA": "Africa",
 "OCEANIA": "Oceania",
 "ANTARCTICA": "Antarctica",
 "SOUTH_AMERICA": "South America",
```

现在一切都应该像预期的那样工作。管理员能够看到所有三个实体，并且能够正确地执行 CRUD 操作。我们现在将开发自定义屏幕，按国家显示 GDP 数据。

# 服务、持久性和 REST 控制器层中的过滤器供应

让我们回忆一下，在用 JDL 创建实体时，我们在最后为 JDL 脚本中的`Country`实体设置了过滤器选项。让我们看看这对服务、持久性和 REST 控制器层有何影响。

# 持久层

当我们为任何实体添加一个过滤器选项时，JHipster 会对与该实体对应的存储库接口进行必要的更改。在我们的例子中，`CountryRepository`现在扩展了`JpaSpecificationExecutor`接口，用于向存储库添加`Specification`功能，如下所示:

```
public interface CountryRepository extends JpaRepository<Country, Long>, JpaSpecificationExecutor<Country>
```

Spring Data JPA 提供了一个执行条件查询的`Specification`接口，该接口用于根据数据库列上的各种条件从数据库中检索值。

# 服务层

在服务层，JHipster 在服务包下生成一个单独的类`xxxQueryService`。对于`Country`实体，创建了一个新的服务类`CountryQueryService`。该类的目的是根据过滤标准检索数据，因此它只包含 fetch 方法，如下所示:

```
 public Page<CountryDTO> findByCriteria(CountryCriteria criteria, Pageable page) {
     log.debug("find by criteria : {}, page: {}", criteria, page);
     final Specification<Country> specification = createSpecification(criteria);
     return countryRepository.findAll(specification, page)
            .map(countryMapper::toDto);
 }
```

JHipster 为用 filter 选项声明的每个实体生成一个**普通旧 Java 对象** ( **POJO** )类。这用于将过滤器值从前端传递到服务层。在我们的例子中，JHipster 生成一个`CountryCriteria`类，为`Country`实体提供这个服务。该类包含域对象中每个相应字段的各种过滤器。如果没有应用过滤器，这将带来所有的实体。

JHipster 创建了各种过滤器类型，对应于每种包装类类型。对于任何自定义类型，它都创建一个扩展了`io.github.jhipster.service.filter.Filter`类的内部类。`CountryCriteria`类如下所示:

```
public class CountryCriteria implements Serializable {
    /**
     * Class for filtering Continent
     */
    public static class ContinentFilter extends Filter<Continent> {
    }
    private static final long serialVersionUID = 1L;
    private LongFilter id;
    private StringFilter code;
    private StringFilter name;
    private ContinentFilter continent;
    private StringFilter region;
    private FloatFilter surfaceArea;
    private IntegerFilter population;
    private FloatFilter lifeExpectancy;
    private StringFilter localName;
    private StringFilter governmentForm;
    private LongFilter cityId;
    private LongFilter countryLanguageId;
 //setters and getters
}
```

`Country`域类中的`continent`属性属于 enum 类型，所以 JHipster 创建了一个`ContinentFilter`的内部过滤器类，对于类型包装类的其他属性，它使用相应的过滤器。在前端，您需要根据属性的类型，以特定的方式将搜索文本作为请求参数传递，如下所示。考虑属性名为`abc` *:*

*   如果属性`abc`是字符串类型:
    *   `abc.contains=<seach_text>`:列出`abc`的值包含`search_text`的所有实体。
*   如果属性`abc`是任意数字类型(浮点型、长整型、双精度型、整数型)或日期:
    *   `abc.greaterThan=<search_text>`:列出`abc` 大于`search_text`的所有实体。
    *   `abc.lessThan=<search_text>`:列出所有`abc` 小于`search_text`的实体。
    *   `abc.greaterOrEqualThan=<search_text>` : 列出`abc` 大于等于`search_text`的所有实体。
    *   `abc.lessOrEqualThan=<search_text>` : 列出所有`abc` 小于等于`search_text`的实体。
*   如果属性`abc`是自定义类型:
    *   `abc.equals=<search_text>`:列出所有`abc`的值与`search_text`完全相似的实体。
    *   `abc.in=<comma separated search_text values>`:列出`abc` 值在`search_text`列表内的所有实体。
    *   `abc.specified=true`:列出所有`abc` 值不为空的实体，表示指定。
    *   `abc.specified=false`:列出所有`abc` 为空的实体，表示未指定。

这些规则可以针对多个属性进行组合，形成一个复杂的查询。

# REST 控制器层

当应用过滤器选项时，JHipster 还对 REST 控制器进行必要的修改。例如，实体`Country`的 REST 控制器`CountryResouce`的所有`get`方法现在都将`CountryCriteria`作为参数来支持过滤操作，如下所示:

```
 @GetMapping("/countries")
 @Timed
 public ResponseEntity<List<CountryDTO>> getAllCountries(
     CountryCriteria criteria, Pageable pageable) {

     log.debug("REST request to get Countries by criteria: {}", criteria);
     Page<CountryDTO> page = countryQueryService.findByCriteria(criteria, pageable);
     HttpHeaders headers = PaginationUtil.
                 generatePaginationHttpHeaders(page, "/api/countries");
     return ResponseEntity.ok().headers(headers).body(page.getContent());
 }
```

这就是过滤器选项如何影响持久性、服务和 REST 控制器层代码生成的。使用单过滤器配置，JHipster 可以进行所有必要的更改。然而，默认情况下，为每个实体生成的 REST 控制器受到 Spring 安全性的保护。可以在`com.nilangpatel.config.SecurityConfiguration`类的`config()`方法中验证这一点，如下所示:

```
    public void configure(HttpSecurity http) throws Exception {
        ....
        .and()
            .authorizeRequests()
            .antMatchers("/api/register").permitAll()
            .antMatchers("/api/activate").permitAll()
            .antMatchers("/api/authenticate").permitAll()
            .antMatchers("/api/account/reset-password/init").permitAll()
            .antMatchers("/api/account/reset-password/finish").permitAll()
            .antMatchers("/api/**").authenticated()
            ....
    }
```

除了注册、激活、验证和重置密码操作之外，所有其他 URL(`/api/**`)仅限于登录用户。但是，在我们的例子中，我们希望向普通用户显示国家 GDP 数据，而不需要登录。为此，我们需要创建一个具有不同 URL 模式的自定义 REST 控制器，如下所示:

```
@RestController
@RequestMapping("/api/open")
public class GenericRestResource {
  private final Logger log = LoggerFactory.getLogger(GenericRestResource.class);
  private final CountryQueryService countryQueryService;

    public GenericRestResource(CountryQueryService countryQueryService) {
        this.countryQueryService = countryQueryService;
    }

    @GetMapping("/search-countries")
    @Timed
    public ResponseEntity<List<CountryDTO>> getAllCountriesForGdp(
                CountryCriteria criteria, Pageable pageable) {
        log.debug("REST request to get a page of Countries");
        Page<CountryDTO> page = countryQueryService.findByCriteria
             (criteria, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(
             page, "/api/open/search-countries");
        return ResponseEntity.ok().headers(headers).body(page.getContent());
    }
    @GetMapping("/show-gdp/{id}")
    @Timed
    public ResponseEntity<CountryDTO> getCountryDetails(@PathVariable Long id) {
        log.debug("Get Country Details to show GDP information");
        CountryDTO countryDto = new CountryDTO();
        Optional<CountryDTO> countryData = countryService.findOne(id);
        return ResponseEntity.ok().body(countryData.orElse(countryDto));
    }
}
```

第一种方法类似于它在`CountryResource`中自动生成的方法。第二种方法将用于显示 GDP 数据，我们将在创建该屏幕时使用它。映射到这个控制器的 URL 模式是`/api/open`。创建一个单独的 REST 控制器的目的是通过在`SecurityConfiguration`的`configure`方法中用 Spring 安全配置其 URL 模式，使其无需登录即可访问，如下所示:

```
public void configure(HttpSecurity http) throws Exception {
   ....
    .antMatchers("/api/activate").permitAll()
    .antMatchers("/api/open/**").permitAll()
    .antMatchers("/api/authenticate").permitAll()
    ....
}
```

该控制器现在可以公开访问。我们将在*开发定制屏幕*部分使用 Angular 构建前端层时使用控制器方法。

# 向现有实体添加过滤器选项

如果实体已经在没有过滤器选项的情况下生成，并且您想要在以后添加它，您将需要执行某些步骤。以下是两种可能的方法:

1.  使用命令提示符，执行以下操作:
    1.  打开项目目录中的`.jhipster`文件夹下实体的 JSON 文件。例如，对于一个`Country`实体，您将在`.jhipster`文件夹中看到一个名为`Country.json`的文件。
    2.  如果`service`键的值是`no`，将其更改为`serviceClass`或`serviceImpl` *。*过滤选项必须启用服务层选项。
    3.  将键`jpaMetamodelFiltering`的值更改为`true`。
    4.  用`jhipster entity <entity_name>`命令重新生成实体。

2.  对于 JDL，请执行以下操作:
    1.  将包含`filter <entity_name>` 的一行添加到 JDL 脚本文件中。
    2.  用`jhipster jhipster-jdl <jdl_file>`命令重新导入定义。

在这两种情况下，在重新生成实体时，定制将被恢复，因此在执行此任务之前要进行适当的备份。

# 开发自定义屏幕

默认情况下，JHipster 只向登录的用户显示实体。我们应用的目的是向最终用户显示给定国家的 GDP 数据。为此，国家数据必须公开可见。换句话说，它必须无需登录即可访问。为了使它更加用户友好，我们将在两个不同的屏幕中设计流程。

第一个屏幕将列出系统中所有可用的国家。选择其中的任何一个都会在第二个屏幕上显示该国的实际国内生产总值，并带有图形演示。这些是我们需要从头开始开发的定制屏幕，并插入到 JHipster 项目结构中，我们将在本节中完成。

# 搜索国家屏幕

在此屏幕中，我们将列出系统中所有可用的国家，并标上页码。它与*国家*实体屏幕相同，但对所有用户可用(无需登录)。为了更好的用户体验，我们将添加过滤器以在该屏幕上找到特定的国家。它看起来如下:

![](assets/6bec5ea1-5a09-4947-8ad2-73df7292f760.png)

该屏幕有两个过滤器。第一个过滤器将匹配国家名称中的搜索文本(`contains`标准)，而第二个过滤器将比较选定的洲(`equals`标准)。这些过滤器帮助用户立即找到他们想要的国家。为了简单起见，我们只添加了几列关于每个国家的信息，这似乎适合这个屏幕。在每个国家记录的末尾，View 按钮会将用户导航到第二个屏幕，显示该国家的 GDP 信息。

JHipster 提供了 **Angular** 或 **React** 作为开发前端的选项。我们选择 Angular 来创建这个应用。因此，我们所有的开箱即用屏幕都是用 Angular 框架生成的。由于这是一个自定义屏幕，我们需要使用各种角度的工件来开发它。在`/src/webapp/app`文件夹中创建一个`gdp`文件夹，在下一小节中，我们将在其中创建有角度的工件，以构建定制的屏幕。

# 创建有角度的服务

Angular 是一个模块化框架，其中我们编写了许多组件，每个组件都有特定的用途。很多时候，我们需要一些跨多个组件共享的通用功能。此外，我们可能需要用 REST 调用从数据库中获取记录。这就是创建角度服务的完美意义所在。对于我们的 GDP 应用，我们需要在角度服务中获取国家数据，如下所示:

```
@Injectable({ providedIn: 'root'})
export class CountryGDPService {
    public searchCountryUrl = SERVER_API_URL + 'api/open/search-countries';
    public showGDPUrl = SERVER_API_URL + 'api/open/show-gdp';
    constructor(private http: HttpClient) { }
    query(req?: any): Observable<EntityArrayResponseType> {
        const options = createRequestOption(req);
        return this.http.get<ICountry[]>(this.searchCountryUrl, 
            { params: options, observe: 'response' });
    }
    find(id: number): Observable<EntityResponseType> {
        return this.http.get<ICountry>(`${this.showGDPUrl}/${id}`, 
               { observe: 'response' });
    }
}
```

`query`方法用于获取所有带有由`search-country`组件发送的各种请求参数的国家。第二种方法是`find`，用于根据给定的`id`值获取特定的国家。这个服务类使用由 Angular 框架提供的`HttpClient`模块，对新创建的 REST 控制器进行 REST 调用。

`api/open/search-countries`和`api/open/show-gdp`URL 分别用于调用 REST 控制器方法`getAllCountriesForGdp()`和`getCountryDetails()`。然而，服务组件的`find()`方法通过`${this.showGDPUrl}/${id}`表达式动态地将`id`值传递给 URL。这种服务等级对于两个屏幕都是通用的。

# 创建角度路由器

下一个工件是角路由器。Angular 路由器用于管理各种组件之间的应用导航和路由。Angular 路由器使用浏览器 URL 将其映射到特定组件。它对浏览器 URL 进行各种类型的处理，例如解析以验证 URL 是否有效；如果给定选项，则进行重定向；将组件与 URL 段进行匹配；验证给定的 URL 是否可以用防护集来访问；运行关联解析以动态添加数据；最后，激活组件并执行导航。我们将按如下方式编写角度路由器:

```
@Injectable({ providedIn: 'root' })
export class CountryGDPResolve implements Resolve<ICountry> {
    constructor(private service: CountryGDPService) {}

    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<Country> {
        const id = route.params['id'] ? route.params['id'] : null;
        if (id) {
            return this.service.find(id).pipe(
                filter((response: HttpResponse<Country>) => response.ok),
                map((country: HttpResponse<Country>) => country.body)
            );
        }
        return of(new Country());
    }
}

export const countryGDPRoute: Routes = [
    {
        path: 'countries',
        component: SearchCountryComponent,
        resolve: {
            pagingParams: JhiResolvePagingParams
        },
        data: {
            defaultSort: 'name,asc',
            pageTitle: 'gdpApp.country.home.title'
        },
    },
    {
        path: 'showGDP/:id',
        component: CountryGDPComponent,
>        resolve: {
            country: CountryGDPResolve
        }
    },
];
```

它包括一个`resolve`类(`CountryGDPResolve`)和一个路由数组。当用户单击视图按钮开始转换到第二个屏幕时，`resolve`类根据国家 ID 获取完整的国家型号数据。它使用一个服务组件进行 REST 调用并获取国家信息。路由器阵列保存组件的配置映射和触发它们的 URL。这种有角度的路由器在两种屏幕上也是通用的。

# 角度模块

我们知道，Angular 是一个模块化的框架。Angular 中的模块用于将相关的组件、管道、指令和服务组合在一起，形成一个独立的单元，该单元可以与其他模块组合在一起，形成一个完整的应用。一个**模块**可以控制哪些组件、服务和其他工件对其他模块是隐藏的和可见的，就像 Java 类有公共和私有方法一样。我们将使用一个名为`CountryGDPModule`的模块，如下所示:

```
const ENTITY_STATES = [...countryGDPRoute];

@NgModule({
    imports: [GdpSharedModule, RouterModule.forChild(ENTITY_STATES)],
    declarations: [
        SearchCountryComponent,
        CountryGDPComponent,
    ],
    entryComponents: [SearchCountryComponent , CountryGDPComponent],
    schemas: [CUSTOM_ELEMENTS_SCHEMA]
})
export class CountryGDPModule {}
```

它定义了作为本模块一部分所必需的所有组件和路由器。这在两个屏幕上都很常见。

# 创建一个角度组件来显示国家列表

接下来，我们将编写一个组件在第一个屏幕上显示国家列表。组件是创建角度应用的基本构件。每个角度应用至少有一个分量。该组件保存应用数据和逻辑，以便在与之关联的 HTML 模板中显示数据。我们将为应用中的每个屏幕编写一个单独的组件。对于第一个屏幕，我们将编写一个`search-country`组件，如下所示:

```
@Component({
  selector: 'jhi-search-country',
  templateUrl: './search-country.component.html',
})
export class SearchCountryComponent implements OnInit {
    countries: ICountry[];
    routeData: any;
    totalItems: any;
    queryCount: any;
    itemsPerPage: any;
    page: any;
    predicate: any;
    previousPage: any;
    reverse: any;

    // variables for country name and continent filters.
    nameFilter: String;
    continentFilter: String;

   constructor(
        private countryGDPService: CountryGDPService,
        private activatedRoute: ActivatedRoute,
        private router: Router,
    ) {
        this.itemsPerPage = ITEMS_PER_PAGE;
        this.routeData = this.activatedRoute.data.subscribe(data => {
            this.page = data.pagingParams.page;
            this.previousPage = data.pagingParams.page;
            this.reverse = data.pagingParams.ascending;
            this.predicate = data.pagingParams.predicate;
        });
    }

   loadAll() {
        this.countryGDPService
            .query({
                page: this.page - 1,
                size: this.itemsPerPage,
                sort: this.sort(),
                'name.contains': this.nameFilter,
                'continent.equals' : this.continentFilter
            })
            .subscribe(
                (res: HttpResponse<ICountry[]>) => this.paginateCountries(res.body, res.headers),
            );
    }
 .....

}
```

可以用`@component()`装饰器创建一个角度组件。`SearchCountryComponent`类代表了`search-country`组件。它是用某些用于分页和过滤的变量定义的。`CountryGDPService`的对象通过一个构造函数注入到 component 类中，这个构造函数将在其他方法中用于获取国家数据。构造函数用分页变量初始化，这些变量用于处理第一个屏幕上的分页。

组件类用构造函数初始化后不久，Angular 就会调用`ngOnInit()`方法。在这个方法中，我们初始化一些参数，并用`loadAll()`调用其他方法。这个方法调用`countryGDPService`对象的`query()`方法来获取国家信息。

`query()`方法接受各种分页和过滤参数。`page`、`size`和`sort`为分页参数，`name.contains`和`continent.equals`为过滤参数。它们最终通过`CountryGDPService`提交给 REST 控制器。

`name.contains`过滤参数用于根据`name`属性过滤国家数据。由于它属于`String`类型，我们使用了`contains`标准。类似地，另一个过滤参数`continent.equals`用于过滤`continent`属性的数据。因为它是类型`enum`，我们使用`equals`标准。这就是我们在*服务层*部分中看到的内容，在*服务、持久性和 REST 控制器层*小节中的过滤器供应下。

其他函数，像`searchCountries()`、`trackId()`、`loadPage()`等等，都是从与`search-country`组件直接关联的 HTML 模板中调用的。你可以在[https://GitHub . com/packt publishing/Spring-5.0-blue prints/tree/master/chapter 04](https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04)的 GitHub 的章节源代码中看到。

# 显示国家列表的角度模板

最后，我们需要一个 HTML 模板在屏幕上呈现国家数据。每个角度组件都有一个与`@Component`装饰器相关联的 HTML 模板。对于显示国家列表的第一个屏幕，HTML 模板如下所示:

```
<form name="searchCountriesForm" novalidate (ngSubmit)="searchCountries()">
    <div class="container mb-5">
        <div class="row">
            <div class="col-6">
                <label class="form-control-label" 
                jhiTranslate="gdpApp.country.name" for="nameFilter">Name</label> 
                <input type="text" class="form-control" 
                name="nameFilter" id="nameFilter" [(ngModel)]="nameFilter" maxlength="52"/>
            </div>
            <div class="col-4">
                <label class="form-control-label" jhiTranslate="gdpApp.country.continent"
                for="continentFilter">Continent</label>
                <select class="form-control" name="continentFilter" 
                    [(ngModel)]="continentFilter" id="continentFilter">
                    <option value="">
                        {{'gdpApp.Continent.ALL' | translate}}</option>
                    <option value="ASIA">
                        {{'gdpApp.Continent.ASIA' | translate}}</option>
                    <option value="EUROPE">
                        {{'gdpApp.Continent.EUROPE' | translate}}</option>
                    <option value="NORTH_AMERICA">
                        {{'gdpApp.Continent.NORTH_AMERICA' | translate}}</option>
                    <option value="AFRICA">
                        {{'gdpApp.Continent.AFRICA' | translate}}</option>
                    <option value="OCEANIA">
                        {{'gdpApp.Continent.OCEANIA' | translate}}</option>
                    <option value="ANTARCTICA">
                        {{'gdpApp.Continent.ANTARCTICA' | translate}}</option>
                    <option value="SOUTH_AMERICA">
                        {{'gdpApp.Continent.SOUTH_AMERICA' | translate}}</option>
                </select>
            </div>
            <div class="col-2 align-self-end">
                <label class="form-control-label" for="search-countries"></label>
                <button type="submit" id="search-countries" class="btn btn-primary">
                        <fa-icon [icon]="'search'"></fa-icon><span>Search</span>
                </button>
            </div> 
        </div>
    </div>
</form> 
<div class="table-responsive" *ngIf="countries">
    <table class="table table-striped">
        <thead>
        <tr jhiSort [(predicate)]="predicate" 
                [(ascending)]="reverse" [callback]="transition.bind(this)">
        <th jhiSortBy="code"><span jhiTranslate="gdpApp.country.code">
                Code</span> <fa-icon [icon]="'sort'"></fa-icon></th>
        <th jhiSortBy="name"><span jhiTranslate="gdpApp.country.name">
                Name</span> <fa-icon [icon]="'sort'"></fa-icon></th>
        <th jhiSortBy="continent"><span jhiTranslate="gdpApp.country.continent">
                Continent</span> <fa-icon [icon]="'sort'"></fa-icon></th>
        <th jhiSortBy="region"><span jhiTranslate="gdpApp.country.region">
                Region</span> <fa-icon [icon]="'sort'"></fa-icon></th>
        <th jhiSortBy="surfaceArea"><span jhiTranslate="gdpApp.country.surfaceArea">
                Area</span> <fa-icon [icon]="'sort'"></fa-icon></th>
        <th></th>
        </tr>
        </thead>
        <tbody>
        <tr *ngFor="let country of countries ;trackBy: trackId">
            <td>{{country.code}}</td>
            <td>{{country.name}}</td>
            <td jhiTranslate="{{'gdpApp.Continent.' + country.continent}}">
                {{country.continent}}</td>
            <td>{{country.region}}</td>
            <td>{{country.surfaceArea}}</td>
            <td class="text-right">
                <div class="btn-group flex-btn-group-container">
                    <button type="submit"
                            [routerLink]="['/showGDP', country.id ]"
                            class="btn btn-info btn-sm">
                        <fa-icon [icon]="'eye'"></fa-icon>
                        <span class="d-none d-md-inline" 
                         jhiTranslate="entity.action.view">View GDP</span>
                    </button>
                </div>
            </td>
        </tr>
        </tbody>
    </table>
</div>
<div *ngIf="countries && countries.length">
    <div class="row justify-content-center">
        <jhi-item-count [page]="page" [total]="queryCount" 
            [itemsPerPage]="itemsPerPage"></jhi-item-count>
    </div>
    <div class="row justify-content-center">
        <ngb-pagination [collectionSize]="totalItems" 
            [(page)]="page" [pageSize]="itemsPerPage" [maxSize]="5" [rotate]="true" 
            [boundaryLinks]="true" (pageChange)="loadPage(page)"></ngb-pagination>
    </div>
</div>
```

HTML `form`用于呈现过滤选项，国家名称作为文本字段，洲作为下拉菜单。在筛选表单之后，它以表格格式显示国家，并在底部标上页码。每一行的最后一列有一个查看按钮，它使用`/showGDP` URL 并传递当前国家的`id`来打开下一个屏幕。

# 显示 GDP 屏幕

该屏幕以图形方式显示了所选国家的基本数据以及 GDP 数据。我们将使用世界银行 API 获取 JSON 格式的信息，并将其提供给图表模块，以呈现 GDP 数据的图表。该屏幕如下所示:

![](assets/ff24ec52-92a5-4f89-8c02-abab43bf5ecd.png)

这个屏幕使用我们为第一个屏幕创建的相同的服务、路由器和模块构件，但是将使用一个单独的组件和 HTML 模板，您将在下一节中看到。

# 显示国家 GDP 的角度分量

`show-gdp`组件从第一个屏幕中获取国家数据，调用世界银行 API，并以 JSON 格式获取数据，最后将其发送到图表模块以呈现图表。该组件如下所示:

```
@Component({
  selector: 'jhi-show-gdp',
  templateUrl: './show-gdp.component.html',
  })
export class CountryGDPComponent implements OnInit {
    currentCountry: ICountry;
    data: IGdpData[];
    preGDPUrl = 'http://api.worldbank.org/v2/countries/';
    postGDPUrl = '/indicators/NY.GDP.MKTP.CD?format=json&per_page=' + 10;
    year = [];
    gdp = [];
    chart = [];
    noDataAvailale: any;
    constructor(
        private activatedRoute: ActivatedRoute,
        private httpClient: HttpClient
    ) {
        this.activatedRoute.data.subscribe(data => {
            this.currentCountry = data.country;
        });
    }
    ngOnInit() {
        const gdpUrl = this.preGDPUrl + this.currentCountry.code 
                       + this.postGDPUrl;
        this.httpClient.get(gdpUrl).subscribe(res => {
            this.noDataAvailale = true;
            const gdpDataArr = res[1];
            if ( gdpDataArr ) {
                this.noDataAvailale = false;
                gdpDataArr.forEach(y => {
                    this.year.push(y.date);
                    this.gdp.push(y.value);
                });
                this.year = this.year.reverse();
                this.gdp = this.gdp.reverse();

                this.chart = new Chart('canvas', {
                    type: 'line',
                    data: {
                        labels: this.year,
                        datasets: [
                            {
                            data: this.gdp,
                            borderColor: '#3cba9f',
                            fill: true
                            }
                        ]
                    },
                    options: {
                    legend: {
                        display: false
                    },
                    scales: {
                        xAxes: [{
                            display: true
                        }],
                        yAxes: [{
                            display: true
                        }],
                      }
                    }
                });
            }
        });
    }
}
```

在这个组件的构造器中，我们从 Angular 路由器中获取选定的国家。在`CountryGDPResolve`类的`resolve()`方法中，我们从 URL 中的`ID`参数获取国家对象，然后这个对象通过路由器对这个组件可用，因为我们已经在`countryGDPRoute`中为这个组件提供了一个解析配置，如下所示:

```
    {
        path: 'showGDP/:id',
        component: CountryGDPComponent,
        resolve: {
            country: CountryGDPResolve
        }
    }
```

一旦我们得到国家信息，我们将打电话给世界银行 API。其 URL 如下所示:

http://api.worldbank.org/v2/countries/**印第安纳**/指示器/纽约。GDP.MKTP.CD？格式=json & per_page=10 。

在这个 URL 中，国家代码是从路由器给出的国家数据中动态插入的。`per_page`属性返回这么多年的 GDP 数据。前面的示例显示了国家印度过去十年的 GDP 数据。得到 JSON 数据后，我们正在迭代和准备两个数组，`year`和`gdp`，并将它们传递给 chart 模块，在屏幕上生成一个图表。图表模块可以作为节点模块安装，使用`npm install chart.js`命令。

# 显示国家 GDP 的角度模板

最后，`show-gdp`组件的模板将呈现图表并显示国家 GDP 数据。该模板如下所示:

```
<div class="container">
    <h2 id="page-heading">
        <span> GDP data for country <b>{{currentCountry.name}}</b></span>
    </h2>
    <br/>
    <div class="row">
        <div class="col-4">
            <dl class="row">
                <dt class="col-sm-4">Code</dt>
                <dd class="col-sm-8">{{currentCountry.code}}</dd>
                <dt class="col-sm-4">Name</dt>
                <dd class="col-sm-8">{{currentCountry.name}}</dd>
                <dt class="col-sm-4">Continent</dt>
                <dd class="col-sm-8">{{'gdpApp.Continent.' + 
                    currentCountry.continent | translate }}</dd>
                <dt class="col-sm-4">Region</dt>
                <dd class="col-sm-8">{{currentCountry.region}}</dd>
                <dt class="col-sm-4">Surface Area</dt>
                <dd class="col-sm-8">{{currentCountry.surfaceArea}}</dd>
                <dt class="col-sm-4"></dt>
                <dd class="col-sm-8">
                    <div class="btn-group">
                        <button type="submit"
                                [routerLink]="['/countries']"
                                class="btn btn-info btn-sm">
                            <span class="d-none d-md-inline">Back</span>
                        </button>
                    </div>
                </dd>
            </dl>
        </div>
        <div class="col-8">
            <div *ngIf="noDataAvailale">
                GDP data for <b>{{currentCountry.name}}</b> is not available
            </div> 
            <div *ngIf="chart">
                <canvas id="canvas">{{ chart }}</canvas>
            </div>
        </div>
    </div>
</div>
```

它显示了所选国家的一些详细信息，后面是图表的占位符。`noDataAvailale`变量用于在所选国家没有 GDP 数据的情况下显示一条消息。它是在进行世界银行 API 调用时在`show-gdp`组件中设置的。

# 将 GDP 模块挂钩到 AppModule

现在一切都完成了。我们的 GDP 模块已经准备好执行了。最后一步是将其插入到 JHipster 项目结构中。您已经看到一个模块由多个工件组成，比如组件、管道、服务和路由器。多个模块组合在一起形成一个应用。

每个 Angular 应用至少有一个模块，称为根模块，用于引导应用。通常，这个模块按照惯例被称为`AppModule`。因为我们应用的前端是建立在 Angular 之上的，所以有一个`AppModule`。`/src/main/webapp/app`文件夹下的`app.module.ts`文件代表一个`AppModule`。

我们需要在`AppModule`中配置我们的定制模块以使其生效。这可以通过将我们的模块添加到`app.module.ts`文件中`@NgModule`下的`imports`声明中来实现，如下所示:

```
@NgModule({
    imports: [
        ....
        GdpHomeModule,
        GdpAccountModule,
        // jhipster-needle-angular-add-module JHipster will add new module here
        GdpEntityModule,
        CountryGDPModule
```

在将实体添加到应用中时，JHipster 会生成一个名为`XXXEntityModule`的公共模块，该模块保存与所有实体相关的所有工件的引用。在实体生成后不久，JHipster 将这个模块条目添加到`@NgModule`内部的导入数组中。我们为 GDP 模块添加了另一个条目(`CountryGDPModule`)。这就是任何定制模块插入`AppModule`的方式。

# 更新导航

我们的模块已经准备好了，也插入到`AppModule`中，让它开始工作。但是，还缺少一个小东西，就是定位导航启动 GDP 模块。最好的选择是将导航链接放到页面顶部的导航栏中。JHipster 提供了一个导航栏，作为一个独立的模块，它显示各种链接。其中有几个是公开可见的，其他的只对登录和`Admin`用户开放。

要添加链接，我们需要修改`/src/main/webapp/app/layouts/navbar`文件夹下的导航模板文件`navbar.component.html`，如下所示:

```
<div class="navbar-collapse collapse" id="navbarResponsive" 
            [ngbCollapse]="isNavbarCollapsed" [ngSwitch]="isAuthenticated()">
        <ul class="navbar-nav ml-auto">
            <li class="nav-item" routerLinkActive="active" 
                [routerLinkActiveOptions]="{exact: true}">
                <a class="nav-link" routerLink="/" (click)="collapseNavbar()">
                    <span>
                        <fa-icon icon="home"></fa-icon>
                        <span jhiTranslate="global.menu.home">Home</span>
                    </span>
                </a>
            </li>
            <li class="nav-item" routerLinkActive="active" 
 [routerLinkActiveOptions]="{exact: true}">
 <a class="nav-link" routerLink="/countries" 
                        (click)="collapseNavbar()">
 <span>
 <fa-icon icon="list"></fa-icon>
 <span>Countries</span>
 </span>
 </a>
 </li>
          ....
```

我们添加了以粗体突出显示的 HTML 代码，以在导航栏中显示 Countries 菜单项。这看起来如下:

![](assets/bfe81b78-3808-4a2a-8b98-6ec49ceea2f8.png)

`routerLink`的路径被定义为 Countries，这最终会触发`t=the search-country`组件在第一个屏幕上显示带有过滤器选项的国家列表。这就是如何在 JHipster 项目中添加定制屏幕的方法。

# JHipster 的其他功能

到目前为止，您已经看到了如何使用 JHipster 创建成熟的产品化应用。您已经看到了如何创建实体并定义它们之间的关系。我们还添加了定制屏幕并开发了各种工件，因此您可以学习如何向 JHipster 生态系统生成的应用添加定制代码。

这些是一些很棒的特性，通过自动化大量的过程，不仅使开发人员的生活更容易，而且更有生产力。我们现在来看看这些。

# IDE 支持

在本章的开始，您通过回答各种问题，了解了如何使用 JHipster CLI 创建应用。这对于开始使用 JHipster 已经足够了。但是，为了提高效率，建议使用 IDE 进行开发。JHipster 支持广泛的 ide，包括 Eclipse、Visual Studio 代码、IntelliJ IDEA 等等。在使用 IDE(或简单的文本编辑器)时，您需要确保将某个文件夹排除在索引之外，如`node_modules`、`build`和`target`，以减少应用的初始加载时间。

# 设置开箱即用的屏幕

JHipster 提供了几个现成的屏幕。大体上，它们可以分为以下三类:

*   主页和登录屏幕
*   管理
*   账户管理

# 主页和登录屏幕

启动后，JHipster 会在主屏幕上显示一条欢迎消息。这是默认主页，您可以根据您的应用需求进行更改。在本地开发中，默认情况下会选择`dev`概要文件，因此您会在左上角看到一个开发选项卡。在页面的顶部，您会看到一个导航菜单。如果没有登录，它将显示以下菜单项:

*   主页:显示主页的链接。
*   语言:这是有条件的。仅当您选择了多种语言时，此菜单才可见。
*   Account:显示子菜单项，如登录和注册。

单击登录选项后，您将看到一个登录页面，如下所示:

![](assets/42169da4-3411-4be0-a3f6-debe10692372.png)

这个屏幕包括记住我，你忘记了你的密码吗？，并注册新账户功能。忘记密码功能需要电子邮件验证。为此，您需要在应用属性文件中用 JHipster 配置 SMTP。默认情况下，JHipster 创建以下两个用户:

*   **管理员**:用户名— `admin`，密码— `admin`，角色— `admin`。
*   **用户**:用户名— `user`，密码— `user`，角色— `user`。

# 账户管理

JHipster 方便了开箱即用的登录功能。它还将帐户管理与此结合起来。JHipster 提供的帐户屏幕支持子菜单形式的各种操作，如下所示:

*   **设置**:该屏幕允许更新用户帐户的详细信息，如名字和姓氏、电子邮件地址和语言。语言下拉菜单显示系统中所有可用的语言，这些语言是在创建应用时配置的。
*   **密码**:该屏幕用于更新当前登录用户的密码。
*   **注册**:该屏幕用于注册新用户进入系统。它仅在用户未登录时可用。创建用户后不久，将会启动一个激活流程，发送一封激活电子邮件并进行验证。SMTP 配置需要在发送电子邮件的应用属性中完成。请注意，如果在应用创建期间选择 OAuth 作为身份验证机制，JHipster 将不会显示此屏幕。

# 管理

使用管理员凭据登录后，您将看到带有管理选项的导航菜单。它涵盖了用于管理整个应用的各种模块。它对于开发和监控应用非常有用。

它包含各种子菜单，如以下部分所述。

# 用户管理

这是一个用于管理应用注册用户的一站式屏幕。您可以从该屏幕添加新用户以及修改、删除或激活/停用现有用户。它还显示了具有各种属性的用户列表，如`ID`、`username`、`email`、`Activate/Deactivate`、`Roles`、`Created date`、`Modify by`和`Modify date with pagination support`。

# 韵律学

JHipster 提供各种屏幕来分析应用的性能和其他指标，如下所示:

*   **JVM 指标**:显示特定于 JVM 的统计数据，比如内存利用率、线程数量、线程转储和垃圾收集细节。
*   **HTTP requests** :显示了此度量的 HTTP 请求的汇总详细信息及其状态代码。
*   **服务统计**:这里显示了各种开箱即用和定制服务的执行时间详情。查看各种服务的使用情况非常有用。
*   **高速缓存统计数据**:实体高速缓存的详细信息包含在此指标中。
*   **数据源统计**:这里会显示数据源的详细信息。

“刷新”按钮用于用最新值更新指标。

# 健康

该屏幕显示与应用运行状况相关的各种信息，例如底层数据库和磁盘空间。它用于提前做出有关数据存储的决策。

# 配置

该屏幕显示应用于应用的当前配置。这对于在出现任何问题的情况下对应用进行故障排除，或者检查进一步性能改进的可能性特别有用。它涵盖了 Spring 框架特定的配置、服务器配置、系统环境配置和应用属性。由于这涉及敏感数据，默认情况下只有管理员可以查看。

# 审计

JHipster 为用户认证提供了一个审计日志。因为认证是由 JHipster 中的 Spring Security 完成的，所以它专门为认证捕获特定于安全性的事件，并将它们存储在独立的 Spring 数据存储库中的数据库中。从安全的角度来看，它们是有用的。该屏幕以表格形式显示所有这些数据，并标有页码。

# 日志

该屏幕显示运行时类和包的各种应用日志级别，如`TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`和`OFF`。它还允许更新单个类和包的日志级别。这有助于对应用进行故障排除。

# 应用接口

JHipster 使用 Swagger，这是一个用来描述 API 结构的框架。如您所见，JHipster 支持实体创建，并且还公开了 REST API。它使用 Swagger 来记录实体 REST API。JHipster 还提供了一个用户界面，使用样本数据与 API 进行交互，并返回输出。

# 维护代码质量

JHipster 在创建应用和实体时会生成大量样板代码。它在生成代码时遵循最佳实践，以保持质量。然而，JHipster 只是在第一次创建应用代码，用户必须在以后根据业务需求添加定制代码。

为了在添加定制代码后保持代码质量，JHipster 允许使用 Sonar 分析完整的应用代码，Sonar 是一种专门为监控代码质量而设计的工具。使用 **SonarCloud** *—* 声纳的云版本来分析代码。为此，您必须在 Git 中提交代码。

您也可以在本地 Sonar 服务器上分析代码。为此，您必须在本地设置并运行 Sonar 服务器。Sonar 服务器运行的默认端口是`9000`，所以你需要确保在`pom.xml`(如果构建类型是 Maven)中配置的 Sonar 端口是相同的。执行`mvnw test sonar:sonar`命令，您将在 Sonar 中看到代码分析，如下所示:

![](assets/4c03dcee-921f-4fbc-9805-2cb2b2a2f6b5.png)

这有助于保持代码质量，即使在向应用添加定制代码之后。

# 微服务支持

在这一章中，我们使用 JHipster 创建了一个单片应用。但是，它也允许用户创建基于微服务的应用。基于微服务的架构将整个整体应用(前端和后端)拆分为小型独立的模块化服务。这是一种独特的软件开发方式，在过去的几年里发展迅速。

每个模块化服务都可以通过独特而简单的 API 与其他服务进行交互。微服务架构与单一设计相比有许多优势，如独立开发和部署、轻松管理故障转移、开发人员可以在独立团队中工作、持续交付等。

一般来说，微服务架构没有任何前端层，但 JHipster 支持微服务网关，前端处理 web 流量。它作为最终用户的代理微服务。简而言之，用户可以通过网关与微服务进行交互。JHipster 微服务模型由一个网关服务、一个注册中心和至少一个或多个微服务应用组成，我们可以使用 JHipster 创建一个后端代码，可以通过 API 访问。

# 码头支持

Docker 是一个支持容器的开源软件平台，使得应用部署可移植且自包含。它用于将整个应用(包括 SQL 和 NoSQL 数据库、Sonar 配置等)及其依赖项打包成一个容器映像，以便在任何环境中部署和测试。

JHipster 为单片和基于微服务的应用提供 Docker 开箱即用的支持。Docker 是为 Linux 开发的，但在 macOS 和 Windows 上有不同的版本。JHipster 只在应用生成时创建 Dockerfile。Docker 文件包含 Docker 容器用来构建 Docker 映像的指令集。

JHipster 还支持从 Docker Hub 中提取 Docker 图像。这是一个用于发布公共和私人 Docker 图像的在线注册表。这极大地有助于在没有本地安装的情况下使用第三方工具，因为 Docker 映像可以被提取并在本地容器上运行。

# 档案管理

概要文件是特定环境的一组配置，比如开发、测试、生产等等。JHipster 支持配置文件管理，并提供了两个现成的配置文件— `dev`和`prod`。默认情况下，它使用`dev`配置文件。JHipster 为每个概要文件提供了一个单独的应用属性文件。

在生产中，您需要使用 Maven 的`./mvnw -Pprod`命令和 Gradle 的`./gradlew -Pprod`命令来启用生产概要文件。如果您需要在生产中导出一个可执行的 WAR 文件，您可以对 Maven 使用命令`./mvnw -Pprod package`,对 Gradle 使用命令`./gradlew -Pprod package`。

# 实时重装

就时间管理而言，软件开发过程中最具挑战性的因素之一是重新编译代码、部署代码并重启服务器以查看您所做的更改。通常，用 JavaScript 编写的前端代码不需要编译，并且可以在浏览器刷新时立即反映出变化。然而，最新的前端框架需要在脚本文件中进行修改后进行某种转换。

在这种情况下，对于任何单一的代码更改，通常都需要构建、部署和重启服务器。这将严重影响开发人员的生产力。为了避免这种情况，JHipster 支持一种叫做**实时重载**的机制。JHipster 使用`DevTools`模块生成一个基于 Spring Boot 的应用来刷新服务器上的更改，而无需冷启动。默认情况下，这是启用的，因此每当发生任何 Java 代码更改时，它都会在服务器上自动刷新它们。任何前端代码的实时重载都可以通过 **BrowserSync** 实现，它可以通过`npm start`命令启动，并且可以在`http://localhost:9000`T7 访问。

# 测试支持

测试是任何软件开发过程中不可或缺的一部分。它为应用或产品提供质量保证。在创建应用和实体时，JHipster 为前端和后端(或服务器端)创建各种自动化单元测试用例。

服务器端单元测试用例在`/src/test/java`文件夹中生成。它们涵盖了应用的各个层次，比如存储库、服务、安全性、REST API 和分页。它们被分组在各自的包中。您可以从 IDE 中运行单独的测试用例，或者使用`mvnw test`命令从命令提示符中运行所有的测试用例。执行此命令时，请确保您位于应用目录中。对于 Gradle，您需要执行`gradle test`命令。

前端(或客户端)单元测试可以用`npm test`命令来执行。这将为驻留在`/src/test/javascript/spec`文件夹中的 typescript 执行各种 JavaScript 测试用例。默认情况下，JHipster 还支持 Jest 框架的端到端客户端测试用例。可选地，其他框架，如**加特林**、**黄瓜**和**量角器**，也可以用于客户端端到端测试。

# 升级 JHipster

与其他框架不同，升级 JHipster 是一个轻松的过程。名为 **JHipster upgrade** 的子生成器用于将现有应用升级到新版本，而不会删除自应用首次创建以来添加的任何自定义更改。这非常有用，尤其是当 JHipster 的一个新版本发布时，它包含了已知的错误修复和安全补丁。JHipster 升级可通过以下命令执行:

```
jhipster upgrade
```

为了使整个升级过程自动化，JHipster 通过以下步骤获得了 Git 的帮助:

*   前面的命令检查 JHipster 的新版本是否可用，除非明确给出了`--force`标志。如果给定了这个选项，将会触发升级子生成器，而不考虑正在安装的最新版本。
*   整个升级过程依赖于 Git，所以如果一个应用没有用 Git 初始化(如果没有安装 Git)，JHipster 会初始化 Git，并将当前代码提交给 master 分支。

*   JHipster 将检查任何未提交的本地代码。如果代码未提交，升级过程将失败。
*   接下来，它将检查 Git 中是否有一个`jhipster_upgrade`分支。如果没有，这将被创建。这个分支专用于 JHipster 升级过程，所以不应该手动更新。
*   JHipster 将检查`jhipster_upgrade`分支。
*   至此，JHipster 升级到了最新版本。
*   清理当前项目目录，从头开始生成带有实体的应用。
*   生成的代码将被提交到`jhipster_upgrade`分支。
*   最后，`jhipster_upgrade`分支将与启动`jhipster_upgrade`命令的原始分支合并。
*   如果出现任何冲突，您需要手动解决并提交它们。

# 持续集成支持

自动化测试非常有助于使系统无 bug，即使在添加新功能之后。JHipster 为生成的代码创建单元和集成测试用例，这在一定程度上会有所帮助。在真实的场景中，我们需要添加更多针对定制业务实现的单元测试用例；例如，您可能添加了一些定制屏幕、控制器和服务层，您需要为它们编写额外的单元测试用例。

此外，我们需要为新引入的 API 添加集成测试用例。除此之外，我们还需要为前端定制添加客户端测试用例。

目前，测试和持续集成已经成为软件开发过程中不可或缺的一部分。测试将有助于生产高质量的产品，而持续集成只不过是不断地合并和测试新引入的代码变更，这有助于识别潜在的 bug。这发生在执行自动化单元、集成和针对代码的端到端测试用例的组合中。一个经典的例子是在 Git 上每次提交时触发自动化测试套件；或者更有效地按照预定义的计划运行它。

自动化测试模型的好处可以通过放置一个持续的集成过程来实现，以确保新的代码变化不会引入对稳定版本的回归。这确保了合并新的变更并放心地部署到生产环境中。

持续的测试、集成和持续的部署产生了一个叫做**持续集成/持续部署** ( **CI/CD** )的概念，它执行代码的持续集成、测试和部署。可以通过各种 CI/CD 工具实现连续交付。JHipster 为当今市场上的知名 CI/CD 工具提供了出色的支持，如 Jenkins、Travis CI、GitLab CI 和 Circle CI。

# 社区支持和文档

无论一个软件框架或产品有多好，它的受欢迎程度来自于用户从文档和社区获得帮助的难易程度。JHipster 的官方网站上有非常好的文档，这足以让我们开始使用它。

除了官方的 GitHub 论坛之外，还有很多其他的资源和论坛，在这里你可以很容易地得到关于使用 JHipster 时的任何问题的帮助。此外，开发人员在按时回答问题和优先提供错误修复方面提供专业帮助。这确实有助于吸引开发人员和组织开始使用 JHipster。

# 吉普斯特市场

谁不喜欢使用符合业务需求的可重用组件或模块呢？这将大大节省开发时间。作为一个开源软件，JHipster 团队不仅以框架的形式产生了一个伟大的杰作，而且还维护了一个可重用模块的存储库，称为 **Marketplace** 。

您可以根据需要下载各种模块，并将它们直接插入到您的应用中。您可以将您的模块贡献给市场，以便其他社区用户可以从该模块中受益。这是 JHipster 提供的一个很好的平台，可以与社区共享一段可重用的代码。

# 摘要

这真是一次伟大的旅程，探索构建强大 web 应用的新框架。JHipster 是一个非常好的工具，可以很快制作出一个现代化的、可投入生产的应用。由于许多事情都是自动发生的，JHipster 不仅使开发人员的工作变得更加容易，而且改进了整个项目交付进度。

在这一章的开始，我们探讨了 JHipster 作为一个框架的基础知识，以及一个安装指南。接下来，您了解了 JHipster 如何通过问答方式生成应用代码。它使用另一个名为 **Yeoman** 的工具来生成应用代码。

将域对象实现为实体并支持完整的 CRUD 操作是任何应用最重要的部分。在下一步中，我们学习了 JHipster 如何通过实体生成为领域对象建模提供支持。实体生成有三种选择:经典的基于约曼的选择，UML 方法，以及使用 JDL 工作室。我们已经详细研究了所有这些问题。

在介绍了这些特性之后，我们开始创建一个应用来显示各个国家的 GDP 信息。这需要我们构建定制的屏幕，我们发现了如何在用 JHipster 生成的应用中添加定制。我们还收集了不同层中生成代码的一些细节，包括持久性、服务、REST 控制器和前端层，这将帮助我们适应任何未来的定制。

最后，我们看了一些看不见的特性，这些特性展示了 JHipster 是一个多么健壮的平台，以及它如何让我们轻松地构建一个基于 Spring 的企业级应用。在下一章，你将学习如何用微服务架构创建一个基于 Spring 的应用，以及这与单一应用相比有何不同和优势。******