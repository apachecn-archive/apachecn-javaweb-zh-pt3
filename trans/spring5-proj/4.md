# 四、构建中央认证服务器

实现安全约束是任何应用的核心要求。Spring 为应用的各个方面提供支持，包括安全性。Spring 框架的一个模块叫做 Spring Security，是专门为满足安全需求而设计的。它是一个健壮的、高度自适应的框架，提供开箱即用的身份验证和授权。

Spring Security 是保护任何基于 Spring 的应用的标准。我们可以看到 Spring Security 在与其他系统集成时的真正实力。它的功能可以轻松扩展，以满足客户需求。这一章将专门讨论 Spring 安全。

在最后一章中，我们看到了 Spring 框架的强大之处，它将各种模块和第三方库在 Spring Boot 绑定在一起:一个构建在 Spring 框架之上的模块，主要用于引导和开发一个基于 Spring 的应用，该应用具有自动配置功能。我们将在本章中继续使用它，以便建立中央认证和授权系统。

Spring Security 是一个高度可定制的框架，我们可以将它与其他提供访问控制数据的系统集成在一起。在本章中，我们将仔细研究**轻量级目录访问协议** ( **LDAP** )和 **OAuth** 与 Spring Security 的集成。

我们将在本章中讨论以下有趣的主题:

*   对 LDAP 和数据结构的基本理解
*   LDAP 服务器(Apache DS)的配置
*   使用 LDAP 在 Spring 安全中进行身份验证
*   Spring 安全的 LDAP 授权
*   OAuth 基础知识和各种授权类型
*   与 OAuth 的 Spring 安全集成
*   Spring 安全中使用 LDAP 和 OAuth 的双重认证
*   Spring Security 中使用自定义授权服务器实现 OAuth

# 技术要求

本章用到的所有代码都可以从以下 GitHub 链接下载:[https://GitHub . com/packt publishing/Spring-5.0-Projects/tree/master/chapter 04](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04)。该代码可以在任何操作系统上执行，尽管它只在 Windows 上测试过。

# 轻量级目录访问协议

当电子邮件被引入并开始在企业中使用时，一个挑战是查找一个从未与你交流过的人的电子邮件地址。它需要某种中央存储库来搜索组织内其他人的电子邮件地址。

需要是发明之母。对中央数据仓库的需求使得微软、Lotus、Netscape 和 IBM 等公司走到了一起，他们定义了一个叫做 LDAP 的标准。它是通过网络访问存储在目录结构中的数据的协议。

LDAP 服务器以分层的方式保存和索引数据，支持 LDAP 的客户端可以访问它。可以过滤数据以选择存储在不同实体中的特定个人或组。例如，假设搜索位于芝加哥的所有来自行政部门且工作超过三年的员工，并收到他们的全名、职务和电子邮件地址。这对于 LDAP 来说是完全可能的。

除了联系信息，LDAP 还可以用来存储访问控制数据，这些数据可以用来执行身份验证和授权。我们将从介绍 LDAP 的基础知识以及如何用它构建数据结构开始。

# 什么是 LDAP？

LDAP 是通过网络访问和管理存储在目录结构中的分层信息的行业标准。LDAP 已经使用了相当长的时间。现在主要用于构建认证系统；然而，这绝不是它的唯一目的。LDAP 还可以用来存储需要集中访问的任何类型的信息(例如，组织中的电子邮件或联系信息)。

将用户(或任何其他)信息(如用户名、电子邮件、密码等)存储在一个地方的主要动机是为了方便管理和维护。例如，LDAP 可以作为一个中央存储库来管理用户列表，而不是单独处理组织中每个子组的用户列表，从网络中的任何地方都可以访问。在某些用例中，LDAP 是最合适的，如下所示:

*   允许用户在多个应用中使用相同的凭证登录，就像在内部网和您的本地机器上登录一样。
*   向一组用户提供基于角色的访问；例如，访问内部网站点上的特定页面，或者访问文档管理系统中的文档。
*   收集用户的详细联系信息，并在全球范围内公开，以便组织中的任何用户都可以访问这些信息。

LDAP 是访问存储在目录中的结构化信息的一种方式。为此，它遵循客户机-服务器模型，其中数据存储在 LDAP 服务器上，客户机可以提出访问所需信息的请求(通过 LDAP API)。

存储在 LDAP 服务中的信息不会在每次访问时被更改，这使得 LDAP 成为一种一次写入多次读取的服务形式。例如，LDAP 不适合维护在线购物应用的交易记录，因为这些记录会随着每次操作而改变。然而，LDAP 可用于维护不经常更改的数据，如用户帐户、用户地址等。

存储在 LDAP 服务器上的数据不是关系形式的；相反，它是分等级的。然而，LDAP 使用数据库在内部存储信息，但是以分层的方式呈现。

除了定义如何访问目录服务中的数据，LDAP 还定义了数据的呈现方式。为了理解这个数据信息模型，有必要理解 LDAP 中使用的某些术语。这不仅有助于您更好地了解它是如何工作的，还将说明如何在 LDAP 中创建和搜索数据:

*   **目录信息树** ( **DIT** ):正如我们所讨论的，LDAP 服务器以分层(或树)的形式存储信息。这种树被称为目录信息树。
*   **条目**:由于树有节点，DIT 中的节点称为条目。存储在条目中的信息是键值对的形式。每个条目都有一个父条目(根条目除外)和零个或多个子条目。子条目是其父条目的兄弟条目。
*   **词根/词根/后缀**:DIT 中最上面的条目叫做词根、词根或后缀。
*   **识别名**(**DN**):DIT 中的每个条目都应该由一个唯一的标识符来识别。这个唯一的标识符称为识别名。通常，它是由一个或多个逗号分隔的键-值对组成的字符串，这些键-值对共同唯一地区分树中的节点(条目)。例如，字符串`dc=nilangpatel` *，* `cd=com`可以是根实体的 DN。
*   **相对可分辨名称** ( **RDN** ):唯一区分实体与其父实体的字符串称为相对可分辨名称。DN 在全局范围内唯一标识实体，而 RDN 在它的兄弟中唯一标识实体。
*   **对象类**:每个实体由一个或多个`objectClasses`组成。每个对象类都有一个名称和零个或多个属性。`objectclass`被认为是属性的容器，它将控制什么类型的属性可以添加到实体中。
*   **属性**:该属性是`objectclass`的一部分。它有一个名字和值。它还有一个缩写或别名。

以下是我们将在本章中使用的一些属性(及其对象类)的列表:

| 属性名 | 别名 | 描述 | 对象类别 |
| `dc` | `domainComponent` | 域名的任何部分；例如，`domain.com`、域或 com | `dcObject` |
| `o` | `organizationName` | 组织名称 | `organization` |
| `ou` | `organisationalUnitName` | 部门或任何子组 | `organizationUnit` |
| `cn` | `common name` | 实体的名称 | `person`、`organizationalPerson`、`organizationalRole`、`groupOfNames`、`applicationProcess`、`applicationEntity`、`posixAccount`、`device` |
| `sn` | `surname` | 姓氏或家族名称 | `person` |
| `uid` | `userid` | 用户名或其他唯一值 | `account`、`inetOrgPerson`、`posixAccount` |
| `userPassword` | `-` | 某种形式的访问控制的用户密码 | `organization`、`organizationalUnit`、`person`、`dmd`、`simpleSecurityObject`、`domain`、`posixAccount` |

*   **LDAP 数据交换格式** ( **LDIF** ):这是一种 ASCII 文件格式，以文本文件的形式描述 LDAP 数据的层次树结构。LDAP 数据可以以 LDIF 文件格式导入或导出。

# 将 Apache DS 配置为 LDAP 服务器

我们将使用 **Apache 目录服务器** ( **Apache DS** )，一个可扩展的、现代的、可嵌入的 LDAP 服务器，来展示 LDAP 认证。它是纯 Java 编写的。Apache DS 是作为独立的 LDAP 服务器提供的。在使用它时，您将需要某种 LDAP 浏览器来可视化和操作数据。

然而，Apache 提供了另一个工具，叫做 **Apache Directory Studio，**，这是一个基于 Eclipse 的应用。它在一个包中附带了 Apache DS 和 LDAP 浏览器。它是专门为 Apache DS 设计的；然而，你可以在任何 LDAP 服务器上使用它(比如 **OpenLDAP** )。

当您使用 Apache Directory Studio 时，您不再需要获得另一个 LDAP 服务器，因为它附带了 Apache DS(一个 LDAP 服务器)。

下载 Apache Directory Studio([https://directory.apache.org/studio/](https://directory.apache.org/studio/)，在本地机器上解压，双击`ApacheDirectoryStudio`可执行文件打开。

首先，我们需要添加 Apache DS 服务器。为此，请转到 LDAP Server 选项卡(通常位于窗口底部)，右键单击该选项卡，选择 New | New Server，然后选择最新版本的 Apache DS server。一旦添加了服务器，右击它并选择 *Run* 来启动服务器。

服务器启动并运行后，我们需要创建一个连接。右键单击*连接*选项卡，选择新连接，显示以下信息:

*   连接名称 **:** 任何合适的名称。
*   主机名:本地主机。
*   端口 **:** 任何 LDAP 服务器的默认端口都是`389`。但是，Apache DS 的默认端口是`10389`。不用说，端口是可以更改的。

保持其余选项不变，并单击“Next”按钮填写以下详细信息:

*   **认证方式:**简单认证
*   **绑定 DN 或用户:** `uid=admin`，`ou=system`
*   **绑定密码:** `Secret`

这是默认的管理员凭据，可以通过单击“检查身份验证”按钮进行验证。单击 Finish，您将在 LDAP 浏览器窗口中看到详细信息，如下面的屏幕截图所示:

![](assets/e77d5953-205b-452f-8cb8-30cadfe77ffd.png)

接下来，我们将开始创建一个数据结构来存储用户详细信息。如您所见，LDAP 可用于存储任何类型的信息，但我们将使用 LDAP 进行身份验证。LDAP 以树(DIT)的形式存储数据，因此我们将创建一个 DIT 结构。

# 示例抖动结构

接下来，让我们首先看看 LDAP 中常用的几种数据结构，然后选择其中一种:

![](assets/82f72d0f-e7ab-4c5f-a48a-2240ca32af5a.png)

这个结构从一个名为 packt ( **o=packt** )的组织开始，然后是每个部门的组织单元(子组)，最后是用户。有的地方，子组织有用户组，后面跟着用户。

该树也可以基于互联网域名排列，如下所示:

![](assets/54101e71-9a26-4e90-8bc2-8cdf364380b0.png)

该结构将`example.com`作为一个域。您可以用不同的名称多次赋予相同的属性，如前所示。 **dc** 代表**域组件**。接着是**用户**和**打印机**(设备)的子组，最后列出**用户**和设备(**打印机**)。

另一种选择如下:

![](assets/fa6a4809-43f0-4b9d-ab26-5f8619a589f7.png)

该选项有一个组织( **o=packtPublisher** )作为根，两个子**用户**和**角色**作为 **ou** (组织单元或子组)。**用户**条目将有用户条目，而**角色**条目将有角色条目。在本章中，我们将选择这个选项在 LDAP 中构建一个 DIT。LDAP 允许将用户与具有属性成员的角色相关联。在本书后面的*在 LDAP 服务器中创建角色*一节中，您将会看到更多的细节。

# Apache DS 分区

Apache DS 有一个概念叫做**分区**。每个分区都包含一个实体树(DIT ),它与其他分区中的实体树完全断开。这意味着一个分区中的条目树发生的变化将永远不会影响另一个分区中的条目树。每个分区由一个唯一的 ID 标识。它还有一个命名上下文，称为**分区后缀**，可以认为是该分区中 DIT 的根(或基)；所有条目都存储在该目录下。

要在 Apache DS 中创建一个分区，双击 LDAP server 选项卡中的服务器实例，它将打开服务器配置。打开服务器配置的 Partitions 选项卡，单击 Add 按钮，并为 Partition General Details 部分提供值，如下所示:

![](assets/93d2ee51-0e6a-44fd-8634-33e8bb916c39.png)

*   ID: `packtPublisher`
*   后缀:`o=packtPublisher`

将所有其他值保留为默认值，并保存配置。重新启动服务器以使分区生效。新分区将在 LDAP 浏览器中可用，如下面的屏幕截图所示:

![](assets/c05bf0b7-40a1-4e18-ba9c-2e40d5706561.png)

我们将在这个分区下创建一个实体树(DIT)。分区后缀(`o=packtPublisher`)将被视为 DIT 的基(或根)。接下来，我们将在其下创建条目。

# LDAP 结构

接下来，我们将看看 DIT 中的 DN 和 RDN 概念。我们根据您在*示例 DIT 结构*部分看到的第三个选项来确定 DIT 的目标。让我们回忆一下，RDN 唯一地区分了它的兄弟条目。这意味着它是一个使父条目下的条目唯一的键。我们可以使用任何属性来声明 RDN。此外，在每个级别，用作 RDN 的属性可以不同。

在我们的例子中，base 的 RDN 是`o=packtPublisher`(这是分区后缀)。我们使用了属性`o`，它是组织名称。就在它的下面，有两个子节点，`ou`属性被用作 RDN。属性`ou`代表一个组织单位。这两个子节点分别代表用户和角色。

我们将把用户信息(用户名和密码，以及其他信息)存储在`users`实体下。因此，`users`实体的子实体是实际的用户实体，其属性`uid`被用作 RDN。属性`uid`代表**用户 ID** 。通常，在任何组织中，要么使用用户名，要么使用电子邮件 ID 登录；所以，我们可以把它们中的任何一个作为`uid`属性的值。在这种情况下，我们将用户名设为`uid`。

我们已经讨论了 RDN 的工作原理。现在，让我们看看 DN 是如何工作的。正如我们所描述的，DN 唯一地标识给定 DIT 中的任何条目。换句话说，DN 使得条目在整个树(DIT)中是唯一的。DN 是给定实体的 rdn 的逗号分隔字符串，连同其所有父实体，直到根实体。因此，DN 是根据每个级别的给定 RDN 自动计算的。

在前面的例子中，每个实体(带有`uid=npatel`)的 DN 将是`uid=npatel` *、* `ou=users` *、*和`o=packtPublisher`。同样，`users`实体的 DN 是`ou=users`和`o=packtPublisher`。这就是通过在每个级别附加 RDN 来计算 DN 的方法。

现在让我们在 Apace DS 中创建这个结构。执行以下步骤，在 Apache Directory Studio 中展开 DIT 结构:

1.  右键单击分区`o=packtPublisher`，并选择 New | New Entry。
2.  选择一个选项，*从头开始创建条目*，然后点击下一步。
3.  我们将添加一个实体类型的组织单位，因此选择`organizationalUnit`对象类并单击下一步。
4.  我们将使用`ou`(组织单位)作为 RDN，使用`users`作为它的值。当您给出 RDN 的值时，会自动计算 DN。对于 RDN，可以使用多个属性(或者多次使用不同值的相同属性)。然后，通过在每个名称后附加一个逗号来计算 DN。
5.  点击 Next，然后点击 Finish 按钮，条目`ou=users`将被添加到`o=packtPublisher`下。更新后的结构将在 LDAP 浏览器窗口中可见。

一旦添加了`users`条目，我们可以在它下面插入单个用户条目。步骤如下:

1.  右键单击`users`实体(`ou=users`，选择新建|新建条目。
2.  选择从头开始创建条目选项，然后单击下一步。
3.  我们将添加一个用户，因此选择`inetOrgPerson`对象类，它代表组织中的一个人。点击下一步按钮。

4.  我们将添加一个用户，所以我们将使用属性`uid`(用户 ID)作为 RDN。只需给出值为`npatel`。您可以给出唯一标识用户的任何值。这时，DN 计算为`uid=npatel`、*、*、`ou=users`、`o=packtPublisher`。
5.  点击 Next，您将看到一些必需的属性，如`cn`和`sn`。`cn`代表**俗名**,`sn`表示**姓**。可以分别给出`cn`和`sn`的名和姓。
6.  我们希望对用户进行身份验证，因此用户实体必须有一个密码字段(属性)。只需右键单击该屏幕并选择新属性。
7.  给出属性类型为`userPassword`，点击 Next | Finish 将弹出一个新窗口，您可以在其中输入密码。
8.  给密码取合适的值，确认密码，设置哈希方法为 SHA 点击确定按钮。在父窗口中单击“完成”按钮。

使用前面的步骤添加两到三个这样的用户。我们将在*LDAP authorization with Spring Security*一节中查看如何添加角色和创建实际角色。

Apache DS 的默认配置包含一个带有后缀`dc=example`、`dc=com`的数据分区。也可以使用这个分区，但是为了详细理解这个概念，我们创建了一个单独的分区。

恭喜你！配置 LDAP 的基本步骤已经完成。LDAP 服务器已经可以使用了。接下来，我们将看看如何使用 Spring Security 在 LDAP 服务器上验证用户。

# Spring 安全性与 LDAP 的集成

在第三章、*Blog press——一个简单的博客管理系统*中，我们提供了关于 Spring Boot 的信息，并看了如何用它创建一个应用。在本章中，我们将使用 Spring Boot 构建一个应用来展示 Spring Security 中的认证和授权。在 *LDAP* 部分，我们介绍了 LDAP 服务器的安装和设置，以及它的数据结构。在本节中，您将看到 Spring Security 如何与 LDAP 一起工作。

Spring Security 是一个高度全面和可扩展的框架；它为基于 J2EE 的 web 和 REST 应用提供身份验证和授权支持。我们将看看如何将 Spring Security 与 LDAP 集成在一起以执行身份验证。根据定义，**认证**是一种验证或决定个人或实体是否如其所声称的那样的机制。

为了演示身份验证，我们将首先使用 Spring Boot 构建一个 web 应用，然后将它与 LDAP 集成。

# 用 Spring Boot 创建 web 应用

我们已经创建了数据结构，并在 LDAP 服务器中添加了用户及其凭证。接下来，我们将构建一个 web 应用并集成 Spring Security，它将与 LDAP 服务器对话以进行身份验证。在前一章中，我们用 Spring MVC 和百里香叶构建了一个应用。我们将重用相同的架构，并使用以下构件创建一个 web 应用:

*   Spring Boot，用于创建 web 应用和其他模块的自动配置
*   百里香叶，用于表示层
*   Spring Security，使用 LDAP 执行身份验证。

和上一章一样，本章我们将使用一个基于 Eclipse 的 IDE，名为 **Spring Tool Suite (STS)** 。创建一个名为`SpringAuth`的 Spring Boot 应用，以及其他合适的参数，比如组、工件、版本、描述和 Java 包。确保将以下启动器添加到`pom.xml`:

```java
<depedency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.security</groupId>
  <artifactId>spring-security-ldap</artifactId>
</dependency>
```

在前面的条目中，`spring-security-ldap`不是起始项，而是一个简单的依赖项。它提供了 Spring Security 与 LDAP 集成所需的相关依赖。

我们将 LDAP 服务器配置为数据源，以获取用户详细信息并在 Spring Security 中执行身份验证。这时，Spring Security 应该知道如何连接 LDAP 服务器的细节。这些详细信息由 URL、基本 RDN 和管理凭证组成。我们将在`application.properties`文件中定义这些细节，如下所示。

```java
spring.ldap.urls=ldap://localhost:10389
spring.ldap.base=o=packtPublisher
spring.ldap.password=secret
spring.ldap.username=uid=admin,ou=system
```

细节很简单。用户名和密码代表 LDAP 管理员凭证。因为我们处理的是 LDAP，所以 admin 用户名的形式是 DN ( `uid=admin` *、* `ou=system`)，而不是直接值(比如 admin)。我们可以将这些细节与我们用来与数据库交互的信息联系起来(比如 URL、端口、用户名和密码)。我们将读取这些细节，并将它们提供给 Spring Security，以便与 LDAP 建立连接。为此，我们将编写一个配置类，如下所示:

```java
@Configuration
@ComponentScan(basePackages = { "com.nilangpatel.springldap.config" })
public class LdapDataConfig {

  @Value("${spring.ldap.urls}")
  private String ldapUrls;

  @Value("${spring.ldap.base}")
  private String ldapBase;

  @Value("${spring.ldap.password}")
  private String ldapManagerPwd;

  @Value("${spring.ldap.username}")
  private String ldapManagerUserName;

  @Bean("ldapAuthStructure")
  public LdapAuthStructure getLDAPAuthStructure() {
    LdapAuthStructure authStructure = new LdapAuthStructure();

    authStructure.setLdapUrl(ldapUrls);
    authStructure.setLdapBase(ldapBase);
    authStructure.setLdapManagerDn(ldapManagerUserName);
    authStructure.setLdapManagerPwd(ldapManagerPwd);
    authStructure.setUserDnPattern("uid={0},ou=users");
    authStructure.setUserSearchBase("ou=roles");

    return authStructure;
  }
}
```

这个类简单地读取带有`@Value`注释的 LDAP 连接属性，存储在`LdapAuthStructure`类的实例中，并将其定义为 Spring Bean，以便其他类可以使用。`LdapAuthStructure`是一个保存 LDAP 配置属性的定制类。对于 LDAP 与 Spring 的集成，我们将使用以下两个附加属性:

*   `userDnPattern`:数值为`uid={0},ou=users`。这只是一个 DN 模式(相对于实体`ou=users`)。在运行时，`{0}`将被 Spring 替换为实际值(`uid`，用户 ID)。
*   `userSearchBase` : 代表用户基数(`ou=users`)。基本上，它表示一个实体，可以在这个实体下搜索用户。
*   `groupSearchBase`:表示组基(`ou=roles`)。在接下来的部分中，我们将使用该属性来执行授权。

接下来，我们将使用这些属性并用安全配置类初始化 Spring 安全性，如下所示:

```java
@Configuration
@EnableWebSecurity
@ComponentScan("com.nilangpatel.springldap.security")
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

  @Autowired
  private LdapAuthStructure ldapAuthStructure;

  private Logger logger = LoggerFactory.getLogger(WebSecurityConfig.class);

  @Override
  public void configure(WebSecurity web) throws Exception {
    web.ignoring().antMatchers("/js/**");
    web.ignoring().antMatchers("/css/**");
  }

  @Override
  protected void configure(HttpSecurity http) throws Exception {
     http.authorizeRequests()
      .antMatchers("/").permitAll()
      .anyRequest().fullyAuthenticated().and()
    .formLogin().loginPage("/login").permitAll()
      .defaultSuccessUrl("/privatePage",true)
      .failureUrl("/login?error=true")
      .and()
    .logout()
      .permitAll().logoutSuccessUrl("/login?logout=true");
    logger.info("configure method is called to make the resources secure ...");
  }

  @Override
  protected void configure(AuthenticationManagerBuilder authManagerBuilder) throws Exception {
    authManagerBuilder.ldapAuthentication()
    .userDnPatterns(ldapAuthStructure.getUserDnPattern())
    .userSearchBase(ldapAuthStructure.getUserSearchBase())
    .contextSource()
      .url(ldapAuthStructure.getLdapUrl()+"/"+ldapAuthStructure.getLdapBase())
      .managerDn(ldapAuthStructure.getLdapManagerDn())
      .managerPassword(ldapAuthStructure.getLdapManagerPwd())
      .and()
    .passwordCompare()
      .passwordEncoder(new LdapShaPasswordEncoder())
      .passwordAttribute("userPassword");

    logger.info("configure method is called to build Authentication manager ...");
  }  

}
```

`WebSecurityConfig`是一个自定义类，它扩展了`WebSecurityConfigurerAdapter`类。该类是声明安全相关细节的单点配置。`configure(WebSecurity web)`方法用于忽略来自安全上下文的静态资源(JS 和 CSS)请求。如果没有这个，浏览器中就不会加载任何静态资源，因为它们会被 Spring Security 过滤掉。

对于我们的应用，我们没有使用任何图像；如果我们这样做，图像路径(通常是`/img/**`)也需要被忽略。

下一个方法`configure(HttpSecurity http)`，用于在各种页面(URL)上设置规则。我们的动机是展示使用 LDAP 的身份验证；因此，为了简单起见，有三个带有相应 URL 的页面，如下所示:

*   主页(带有 URL `/`)。这是一个登陆页面，意味着当用户输入`http://localhost:8080/springauth`时将打开这个页面(考虑`8080`作为服务器端口，`springauth`作为上下文)。

*   登录页面(带有 URL `/login`)。它将显示一个登录表单，通过该表单可以对用户进行身份验证。
*   一个私人页面(带有 URL `/privatePage`)。这是一个受保护的页面，只对登录用户可用。成功登录后，用户将被重定向到此页面。

主页和登录页面设置为所有人查看，而个人页面设置为登录后成功的 URL。这是一个简单的表单登录。下一个方法`configure(AuthenticationManagerBuilder authManagerBuilder)`，实际上很神奇。这是 LDAP 被配置为身份验证机制的地方。

在这个类中，`LdapAuthStructure`的对象被自动连接，它是由`LdapDataConfig`类提供的，我们在这里用`@Bean`注释声明了它。让我们回忆一下，`LdapAuthStructure`类保存 LDAP 连接数据，我们在`configure(AuthenticationManagerBuilder authManagerBuilder)`方法中使用了这些数据。对`AuthenticationManagerBuilder`类的调用`ldapAuthentication()`会将认证类型设置为 LDAP。

此外，它将设置其他连接数据，如`userDnPattern`和`userSearchBase`。`url`的值是作为 LDAP URL 和 LDAP 基础的组合提供的(例如，`localhost:10389/o=packtPublisher`)。最后，管理员凭证由`managerDn()`和`managerPassword()`调用提供。我们还需要提供一个密码编码器。它必须与我们在 LDAP 服务器中使用的密码编码器相同，所以我们使用了`LdapShaPasswordEncoder`。最后，我们只是提到我们在 LDAP 服务器中设置的密码字段。

LDAP 身份验证配置已完成。当我们使用在 Apache DS 服务器中创建的(相同的)凭证登录时，它将会成功。我们已经将`uid` 设置为`userDnPatterns`，所以登录时给`uid`作为用户名。

恭喜你！LDAP 与 Spring Security 的集成已经成功执行。用户将通过 Spring Security 根据 LDAP 进行身份验证。如果您只需要使用 LDAP 执行身份验证，那么我们到目前为止所做的配置就足够了。接下来，我们将看看如何通过 Spring Data repository 与 LDAP 服务器进行交互，我们将在本章后面的 LDAP 和 OAuth 中使用 Spring Data repository。

# 使用 Spring 数据管理 LDAP 用户

我们融合的一部分结束了。LDAP 管理员可以从 LDAP 服务器配置用户；然后，可以从使用 Spring Security 创建的 web 应用中对它们进行身份验证。然而，我们仍然必须处理单独的系统(Apache DS)来维护用户信息。

如果管理员可以直接从 Spring web 应用维护用户，那该有多酷？这是一个很好的想法，因为它不仅使管理工作变得容易，而且用户能够直接在基于 Spring 的 web 应用中更新他们的个人资料信息(比如密码、名字、姓氏等等)。这在 Spring Boot 是很有可能的。我们正在讨论从 web 应用在 LDAP 服务器上执行 CRUD 操作。

在我们的应用中，LDAP 被用作数据存储，我们在其中维护用户数据。每当我们需要在基于 Spring 的应用中处理任何类型的数据提供者时，我们都需要使用 **Spring Data** ，这是 Spring 家族的一个模块，专门设计用于与数据存储进行交互。Spring Data 促进了抽象层与底层数据提供者的交互，同时为每个数据提供者提供了一个实现，比如 JPA、REST、Elasticsearch(我们在上一章中使用过)、Mongo DB 等等。Spring Data LDAP 与 LDAP 服务器交互，我们将在应用中使用它。

Spring 为每个数据提供者提供了一组库，可以通过在 Spring Boot 应用中指定相应的启动器来利用这些库。Spring 数据 LDAP 模块可以与`pom.xml`中的以下 starter 条目集成:

```java
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-ldap</artifactId>
</dependency>
```

在我们定义了这个 starter 之后，所有需要的 jar 都将出现在类路径中。接下来，我们将创建模型(实体)类。

# Spring 数据模型

Spring 数据模块提供了 DAO 的实现，目的是使各种数据提供者的数据访问保持一致。这带来了无需太多努力就能切换底层持久性技术的巨大灵活性。最终，这将使系统松散耦合。

Spring Data 允许以面向对象的方式与持久层交换数据，这意味着我们可以用实体类对象执行 CRUD 操作。不用说，Spring 数据 LDAP 模块也有助于以模型类对象的形式处理 LDAP 服务器。因此，首先要定义模型(实体)类，它代表我们在 LDAP 服务器中定义的用户数据，如下所示:

```java
@Entry(
  base = "ou=users", 
  objectClasses = {"top", "person", "organizationalPerson","inetOrgPerson"})
public final class LdapAuthUser implements Persistable<Name> {

  @Id
  private Name id;

  @Attribute(name = "uid")
  @DnAttribute(value="uid")
  private String userName;

  @Attribute(name = "sn")
  private String surName;

  @Attribute(name = "cn") 
  private String firstName;

  @Attribute(name = "userPassword") 
  private String password;

  @Transient
  private boolean isNew;

  //.. setter and getter methods
}
```

`LdapAuthUser`类表示我们在 Apache DS 中创建的 LDAP 用户。`@Entity`注释用于映射 Java 类和 LDAP 服务器中的实体。`base`表示`users`实体(`ou=users`)的基础，而`objectClasses`用于定义用于创建用户实体的对象类层次。

`@Attribute`注释用于映射实例变量和 LDAP 实体的属性。注释`@DnAttribute`用于根据找到的条目的识别名自动填充值。特别注意`id`实例变量。它将属于`javax.naming.Name`类型。

LDAP 实体中没有像`id`这样的直接属性，但是 Spring 数据需要为模型类的每个实例提供某种唯一的标识符(像关系数据库中的`PK`)。因此，在内部，它分配一个相对于为模型类定义的`base`(在`@Entity`注释中)的 DN。例如，如果用户的`uid`是`npatel`，那么`id`将是`uid=npatel`、`ou=users`。

另一个独特点是，这个模型类实现了`Persistable<Name>`接口。特别是对于 LDAP，在添加一个新实体时，Spring Data 无法知道该实体是新的还是已存在的。因此，每次 Spring Data 试图搜索一个现有的实体时，如果该实体不存在，它就会抛出一个错误。为了避免这种情况，在添加新记录时，我们将把`isNew`属性显式设置为`true`，这样 Spring 数据将通过被覆盖的方法`isNew()`获得它的值。

模型类现在可以使用了。接下来，我们将使用 Spring 数据为 LDAP 用户执行 CRUD 操作。

# LDAP 的 Spring 数据仓库

如您所见，Spring Data 在处理持久层时提供了一个抽象(接口)层，以支持各种数据存储，包括关系数据库、非关系数据库、map-reduce 框架、云服务等等。抽象从`CrudRepository`接口开始，它提供基本的 CRUD 操作，与底层数据存储无关。该接口涵盖了所有基本的 CRUD 操作。

Spring Data 定义了各种接口，这些接口特定于`CrudRepository`之上的每个数据提供者。对于 LDAP 支持，Spring Data 提供了`LdapRepository`接口，它基本上扩展了`CrudRepository`接口，我们将为我们的自定义存储库扩展这个接口。这个接口拥有执行 CRUD 操作所需的所有方法。这样，通过扩展特定的存储库接口，标准数据访问的所有基本 CRUD 操作都将变得可用。

让我们在应用中为 LDAP 添加 Spring 数据功能。自定义存储库界面如下所示:

```java
@Repository
public interface LdapAuthRepository extends LdapRepository<LdapAuthUser>{

}
```

`@Repository`注释用于描述这是存储库接口。定制接口`LdapAuthRepository`用模型实体`LdapAuthUser`扩展了`LdapRepository`，这是我们在上一节中创建的。在声明这个接口时，Spring Data 提供了我们可以在服务类中使用的 CRUD 实现，如下所示:

```java
@Component
public class LdapAuthService {

  private Logger logger = LoggerFactory.getLogger(LdapAuthService.class);

  @Autowired
  private LdapAuthRepository ldapAuthRepository;

//Create
  public void addUser(LdapAuthUser ldapAuthUser) {
    Name dn = LdapNameBuilder
            .newInstance()
            .add("uid", ldapAuthUser.getUserName())
            .add("ou", "users")
            .build();

    boolean isExist = ldapAuthRepository.existsById(dn);
    if(isExist ==false) {
      ldapAuthRepository.save(ldapAuthUser);
    }else {
      logger.info("User with username "+ldapAuthUser.getUserName()+" is already exist ");
    }
  }
  //Read  
  public LdapAuthUser getUser(String userName) {
    Optional<LdapAuthUser> ldapAuthUserOptional = ldapAuthRepository.
            findOne(LdapQueryBuilder.query().where("uid").is(userName));
    if(ldapAuthUserOptional.isPresent()) {
      return ldapAuthUserOptional.get();
    }else {
      return null;
    }
  }
  //Update
  public void updateLdapUser(LdapAuthUser ldapUser) {
    ldapAuthRepository.save(ldapUser);

  }
//Delete
public void deleteUser(String userName) {
    Optional<LdapAuthUser> ldapAuthUserOptional = ldapAuthRepository.
            findOne(LdapQueryBuilder.query().where("uid").is(userName));
    if(ldapAuthUserOptional.isPresent()) {
      ldapAuthRepository.delete(ldapAuthUserOptional.get());
    }else {
      logger.info("User with username "+userName+" does not exist ");
    }
  }
}
```

在这个服务类中，`LdapAuthRepository`类的对象被注入了`@Autowired`注释。它用于调用 CRUD 方法，如下所示:

*   **创建**:`existsById()`命令用于检查是否已经存在相同 ID 的用户。ID 的类型是`javax.naming.Name`。`LdapNameBuilder`类用于构建 ID。如果一个用户不存在，为了创建一个新的对象，在`ldapAuthRepository`对象上调用`save`方法。我们可以调用这个服务方法来添加来自 Spring MVC 控制器的记录。我们需要创建`LdapAuthUser`的对象，设置数据，从控制器方法调用服务方法，如下:

```java
        LdapAuthUser ldapUser = new LdapAuthUser();
        ldapUser.setUserName("kpatel");
        ldapUser.setPassword("test1234");
        ldapUser.setFirstName("Komal");
        ldapUser.setSurName("Patel");
        ldapUser.setIsNew(true);

        Name dn = LdapNameBuilder.newInstance()
              .add("ou=users")
              .add("uid=kpatel")
              .build();
        ldapUser.setId(dn);

        ldapAuthService.addUser(ldapUser);
```

*   **读取** : 使用`username`读取 LDAP 用户，使用`findOne()`方法。我们需要在这个方法中传递 LDAP 查询。`LdapQueryBuilder`类用于创建 LDAP 查询，该查询将`username`与`uid`进行匹配。
*   **更新**:更新操作很简单。`ldapAuthRepository`的`save`方法将实际更新 LDAP 用户。

*   **删除**:删除用户时，首先需要检查用户是否存在。同样，`fineOne`可以用来检索现有用户。只有当用户存在时，才能执行`delete`操作。

此外，我们可以在服务类中使用以下方法以编程方式执行身份验证，如下所示:

```java
 public boolean authenticateLdapUserWithContext(String userName, String password) {
    return ldapAuthRepository.authenticateLdapUserWithContext(userName, password);
  }

  public boolean authenticateLdapUserWithLdapQuery(String userName, String password) {
    return ldapAuthRepository.authenticateLdapUserWithLdapQuery(userName, password);
  }
```

`authenticateLdapUserWithLdapQuery`和`authenticateLdapUserWithContext`是在`LdapAuthRepositoryCustomImpl`类中定义的自定义方法，在这里我们可以定义自定义方法来与 LDAP 交互。我们将在下一节进一步讨论这个话题。

认证成功后，这些方法将返回`true`；否则他们就是`false`。对于这两种方法，我们都需要以纯文本格式传递密码。这就是使用 Spring 数据存储库对 LDAP 用户执行 CRUD 操作的方式。或者，我们可以使用`LdapTemplate`来执行 CRUD 操作，以及其他复杂的业务功能。

# 使用 LdapTemplate 执行 CRUD 操作

Spring 数据存储库是一种与底层数据提供者进行交互的便捷方式，因为它易于使用并且需要较少的代码，因为实现是由 Spring 数据模块提供的。然而，这种简单性有一定的局限性。例如，对于存储库编程模型，我们只有基本的 CRUD 操作可以使用。对于更复杂的业务需求，我们需要扩展它并提供我们自己的存储库实现。这就是模板模型发挥作用的地方。

Spring 数据模块中的模板模型不如存储库抽象方便，但是在为我们在数据存储上执行的复杂操作提供更细粒度的控制方面，它更强大。我们将看看 Spring 数据模板模型中相同的 CRUD 操作。当然，动机是学习如何准备 Spring 数据模板，以便它可以用于复杂的业务功能。

# 正在初始化 LdapTemplate

Spring Data 为每个底层数据提供者提供了模板，比如`JdbcTemplate`、`JpaTemplate`、`MongoTemplate`、`ElasticSearchTemplate`、`CassandraTemplate`等等。`LdapTemplate`是用来与 LDAP 服务器通信的。我们将首先初始化`LdapTemplate`。将以下方法添加到`LdapDataConfig`类中:

```java
@Bean("ldapTemplate")
  public LdapTemplate getLdapTemplate() {
    return new LdapTemplate(getLdapContextSrc());
  }

  @Bean
  public ContextSource getLdapContextSrc() {
    LdapContextSource ldapContextSrc = new LdapContextSource();
    ldapContextSrc.setUrl(ldapUrls);
    ldapContextSrc.setUserDn(ldapManagerUserName);
    ldapContextSrc.setPassword(ldapManagerPwd);
    ldapContextSrc.setBase(ldapBase);
    ldapContextSrc.afterPropertiesSet();
    return ldapContextSrc;
  }
```

`getLdapContextSrc()`方法首先创建一个对象`LdapContextSource`，并用从`application.properties`读取的 LDAP 连接参数初始化它。`@Bean`注释将这个对象导出为一个 Spring bean。第二个方法，`getLdapTemplate()`，使用`LdapContextSoruce`的对象，初始化`LdapTemplate`类的对象；然后，它被公开为带有`id=ldapTemplate`的 Spring bean，带有`@Bean`注释。

# 使用 LdapTemplate 执行 CRUD 操作

现在，我们已经初始化了`LdapTemplate`对象。接下来，我们将使用它来执行各种 CRUD 操作。我们将在 Spring 数据存储库结构中使用`LdapTemplate`。为此，我们需要扩展 Spring 数据存储库模型，并提供一个定制的实现。

创建一个接口:`LdapAuthRepositoryCustom`。这是一个我们可以定义定制方法的地方，这些方法不能直接用于存储库抽象。更新`LdapAuthRepository`接口的定义，如下所示:

```java
@Repository
public interface LdapAuthRepository extends LdapRepository<LdapAuthUser>,LdapAuthRepositoryCustom
{

}
```

这是自定义实现与 Spring 数据存储库框架的粘合点。最后，定义实现`LdapAuthRepositoryCustom`接口的`LdapAuthRepositoryCustomImpl`类。这是定义自定义方法实现的类，如下所示:

```java
@Repository
public class LdapAuthRepositoryCustomImpl implements LdapAuthRepositoryCustom {

  private Logger logger = LoggerFactory.getLogger(LdapAuthRepositoryCustomImpl.class);

  @Autowired
  private LdapTemplate ldapTemplate;

  ...// Custom implementation method.
```

`LdapAuthRepositoryCustomImpl`实现了`LdapAuthRepositoryCustom`接口，该接口用于声明定制的存储库方法。这个类有一个类型为`LdapTemplate`的实例变量，它被注入了`@Autowired`注释(在`LdapDataConfig`类中创建)。接下来，我们将看看这个类中定义的一些方法，如下所示。

*   **创建操作:**下面的代码块描述了如何使用创建操作添加一个新的 LDAP 用户，带有`ldapTemplate`:

```java
@Override
  public void create(LdapAuthUser ldapAuthUser) {
    ldapAuthUser.setIsNew(true);
    ldapTemplate.create(ldapAuthUser);
  }
  @Override
  public void createByBindOperation(LdapAuthUser ldapAuthUser) {

    DirContextOperations ctx = new DirContextAdapter();
    ctx.setAttributeValues("objectclass", new String[] {"top", "person",     "organizationalPerson","inetOrgPerson"});
    ctx.setAttributeValue("cn", ldapAuthUser.getFirstName());
    ctx.setAttributeValue("sn", ldapAuthUser.getSurName());
    ctx.setAttributeValue("uid", ldapAuthUser.getUserName());
    ctx.setAttributeValue("password", ldapAuthUser.getPassword());

    Name dn = LdapNameBuilder.newInstance()
            .add("ou=users")
            .add("uid=bpatel")
            .build();

    ctx.setDn(dn);
    ldapTemplate.bind(ctx);

  }
```

第一种方法很简单。它使用`ldapTemplate`创建一个带有模型对象的 LDAP 用户。我们已经将`isNew`设置为`true`，以确保在创建 LDAP 用户时不会出现任何问题。第二种方法`createByBindOperation`，使用一个低级 API 来创建 LDAP 用户。`DirContextAdapter`的对象首先用各种模型属性初始化，如`objectClass`、`cn`、`sn`、`uid`、`userPassword`和`dn`。`LdapNameBuilder`类用于创建 LDAP 用户的 DN。最后，使用`ldapTemplate`的`bind`方法创建用户。我们可以使用这两种方法中的任何一种来创建用户。

*   **读取操作:**下面的代码块描述了如何使用读取操作来获取 LDAP 用户，其中`ldapTemplate`:

```java
@Override
public LdapAuthUser findByUserName(String userName) {
    return ldapTemplate.findOne(
        LdapQueryBuilder.query().where("uid").is(userName), LdapAuthUser.class);
}

@Override
public List<LdapAuthUser> findByMatchingUserName(String userName) {
   return ldapTemplate.find(
       LdapQueryBuilder.query().where("uid").like(userName), LdapAuthUser.class);
}

@Override
public LdapAuthUser findByUid(String uid) {
    return ldapTemplate.findOne(LdapQueryBuilder.query().where("uid").is(uid), LdapAuthUser.class);
}

@Override
public List<LdapAuthUser> findAllWithTemplate() {
   return ldapTemplate.findAll(LdapAuthUser.class);
}

@Override
public List<LdapAuthUser> findBySurname(String surName) {
    return ldapTemplate.find(LdapQueryBuilder.query().where("sn").is(surName), LdapAuthUser.class);
}
```

下面是一些从 LDAP 服务器读取用户的方法。`LdapQueryBuilder`用于构建一个查询，该查询可用于执行各种属性的搜索，例如`uid`和`surname`。通过`like`查询，它还可以用来查找具有匹配属性的用户。

*   **更新操作:** 下面的代码块展示了更新操作如何更新 LDAP 用户，用`ldapTemplate`:

```java
@Override
  public void updateWithTemplate(LdapAuthUser ldapAuthUser) {
    ldapTemplate.update(ldapAuthUser);
  }
```

`update`方法很简单。`update()`方法用于用模型对象更新 LDAP 用户。

*   **删除操作:**下面的代码块描述了如何使用删除操作来删除 LDAP 用户，用`ldapTemplate`:

```java
  @Override
  public void deleteFromTemplate(LdapAuthUser ldapAuthUser) {
    ldapTemplate.delete(ldapAuthUser);
  }

  @Override
  public void deleteFromTemplateWithUnbind(String userName) {
    Name dn = LdapNameBuilder.newInstance()
            .add("ou=users")
            .add("uid="+userName)
            .build();
    ldapTemplate.unbind(dn);
  }
```

第一种方法很简单。它只是调用`ldapTemplate`对象上的`delete`方法来删除 LDAP 用户。第二种方法首先创建用户 DN，然后调用`ldapTemplate`上的`unbind`方法，删除用户。

`ldapTemplate`上的`delete`方法简单地调用了对给定实体进行空检查的`unbind`方法。因此，`delete()`和`unbind()`这两种方法最终做的是同样的事情。

除了基本的 CRUD 操作，我们可以使用`ldapTemplate`执行一些其他操作，如下所示:

```java
@Override
public boolean authenticateLdapUserWithLdapQuery(String userName, String password) {
    try {
     ldapTemplate.authenticate(LdapQueryBuilder.query().where("uid").is(userName), password);
     return true;
    }catch(Exception e) {
      logger.error("Exception occuired while authenticating user with user name "+userName,e.getMessage(),e);
    }
    return false;
  }

@Override
public boolean authenticateLdapUserWithContext(String userName, String password) {
    DirContext ctx = null;
    try {
      String userDn = getDnForUser(userName);
      ctx = ldapTemplate.getContextSource().getContext(userDn, password);
      return true;
    } catch (Exception e) {
      // If exception occurred while creating Context, means - authentication did not succeed
      logger.error("Authentication failed ", e.getMessage(),e);
      return false;
    } finally {
      // DirContext must be closed here.
      LdapUtils.closeContext(ctx);
    }
}
```

第一个方法通过传递`LdapQuery`和`password`来调用`ldapTemplate`上的`authenticate`方法。`LdapQueryBuilder`用于为给定的用户名创建 LDAP 查询。第二个方法通过传递用户 DN 和密码来调用`ldapTemplate`对象上的`getContextSource().getContet()`。要求上下文在结尾关闭。使用`getDnForUser()`方法获得给定`userName`的用户 DN，如下所示:

```java
  private String getDnForUser(String uid) {
      List<String> result = ldapTemplate.search(
          LdapQueryBuilder.query().where("uid").is(uid),
          new AbstractContextMapper<String>() {
             protected String doMapFromContext(DirContextOperations ctx) {
                return ctx.getNameInNamespace();
             }
          });
      if(result.size() != 1) {
        throw new RuntimeException("User not found or not unique");
      }
      return result.get(0);
   }
```

通过传递`LdapQuery`和`ContextMapper`的一个实现来调用`ldapTemplate`的`search`方法，最后返回给定用户名的用户 DN(例如`uid=npatel`、`ou=users`、`o=packtPublisher`)。

# Spring 安全的 LDAP 授权

在上一节中，您已经看到了带有 Spring Security 的 LDAP 身份验证。接下来，我们将看看如何执行授权。让我们回忆一下**授权**是一个验证过程，验证一个实体是否应该有权访问某个东西。简而言之，授权涉及到确定谁被允许做什么的规则。身份验证成功后，用户可以根据他们拥有的权限执行各种操作。

让我们回忆一下，身份验证处理的是验证有效用户的登录凭证。授权更多的是检查用户是否有权执行各种操作，如添加、更新、查看或删除资源。授权发生在用户成功通过身份验证之后。在这一节中，我们将看看如何授权 LDAP 用户。

到目前为止，您已经看到用户的详细信息是在 LDAP 服务器上维护的，Spring Security 使用它来执行身份验证。类似地，我们将在 LDAP 服务器中设置授权细节，并在 Spring Security 中获取它们以实现授权。

# 在 LDAP 服务器中创建角色

正如您在上一节中看到的，我们已经在根实体(`o=packtPublisher`)下创建了`users`实体(`ou=users`),并在 LDAP 服务器中将所有用户保存在该实体下。类似地，为了存储授权信息，我们将在 Apache DS 中的根实体下直接创建一个新实体，步骤如下:

1.  右键单击分区`o=packtPublisher`并从 LDAP 浏览器窗口中选择 New | New Entry 。
2.  选择从头开始创建条目选项，然后单击下一步按钮。
3.  我们将添加一个实体类型组织单元，因此选择 organizationalUnit 对象类并单击下一个按钮。
4.  我们将使用`ou`(组织单位)作为 RDN，角色作为它的值。当我们给出 RDN 的值时，DN 是自动计算的。对于 RDN，您可以使用多个属性(或者多次使用相同的属性，使用不同的值)。然后通过在它们后面加上逗号来计算 DN。
5.  点击 Next 按钮，然后点击 Finish 按钮，条目`ou=roles`将被添加到`o=packtPublisher`下。更新后的结构将在 LDAP 浏览器窗口中可见。

接下来，我们将在`ou=roles`条目下添加实际的角色条目。步骤如下:

1.  右键单击角色实体(`ou=roles`)并选择*新建|新条目*。
2.  选择从头开始创建条目选项，并点击下一步*。*
3.  要添加角色，选择`groupOfNames`作为代表角色的对象类。点击下一步按钮。
4.  我们将添加一个角色，所以我们将使用属性`cn`(通用名称)作为 RDN。只需给出值为`ADMIN`。这时，DN 计算为`cn=ADMIN`、`ou=roles`、`o=packtPublisher`。点击下一步按钮。
5.  由于该实体将`groupOfNames`作为对象类，系统将在下一个窗口中要求分配成员。
6.  点击 Browse 按钮，在`o=packtPublisher`条目下选择您想要分配该角色的用户。点击确定按钮。
7.  以下是在给定角色中分配多个成员的步骤:
    1.  从 LDAP 浏览器窗口中选择任何角色条目。右键单击中间部分(所选角色的详细信息以表格格式显示)，然后选择“新建属性”。
    2.  将属性类型的值设为`member`，点击下一个*、*，点击完成按钮；您将看到相同的窗口，用于选择要分配给该角色的用户。

执行这些步骤，并在角色条目下创建以下两个角色:

*   `ADMIN`
*   `USER`

角色结构已经在 Apache DS 中创建。我们现在将导入这些详细信息来执行授权。

# 导入角色信息以执行授权

在本章的*示例 DIT 结构*部分，我们在根实体(`o=packtPublisher`)下创建了一个角色实体(`ou=roles`)。角色实体包含各种角色作为其子实体。我们将看看如何使用这些角色来执行 Spring Security 的授权。我们已经配置了 Spring Security 来使用 LDAP 执行身份验证。我们现在将添加两个示例页面，并对其进行配置，以便一个页面只能由具有`ADMIN`角色的用户访问，另一个页面可以由具有`USER`或`ADMIN`角色的用户访问。

为了实现这一点，需要在我们为 Spring 安全配置创建的`WebSecurityConfig`类的`configure`方法中进行更改。更新后的方法应该如下所示:

```java
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
      .antMatchers("/").permitAll()
      .antMatchers("/adminPage/").hasAnyAuthority("ADMIN")
      .antMatchers("/userPage/").hasAnyAuthority("USER")
      .anyRequest().fullyAuthenticated()
      .and()
   .formLogin().loginPage("/login").permitAll()
      .defaultSuccessUrl("/privatePage",true)
      .failureUrl("/login?error=true")
      .and()
      .logout()
      .permitAll().logoutSuccessUrl("/login?logout=true");
    logger.info("configure method is called to make the resources secure ...");
  }
```

我们添加了一个管理页面(URL 为`/adminPage/`)和一个用户页面(URL 为`/usePage/`),并对它们进行了配置，以便分别由角色为`ADMIN`和`USER`的用户访问。

此外，我们需要在`src/main/resources/templates`文件夹下创建各自的百里香模板，并在 Spring MVC 控制器类中为这两个页面创建条目，并更新菜单结构(在 header 模板中定义)以容纳这些页面。完整的细节在源代码中有提及，可以在 GitHub([https://github.com/PacktPublishing/Spring-5.0-Projects](https://github.com/PacktPublishing/Spring-5.0-Projects))中获得。

接下来，我们将使用 Spring Security 更新代表 LDAP 配置的`configure`方法。这个方法接受一个类型为`AuthenticationManagerBuilder`的对象。完成所需的更改后，该方法将如下所示:

```java
  @Override
  protected void configure(AuthenticationManagerBuilder authManagerBuilder) throws Exception {
    authManagerBuilder.ldapAuthentication()
      .userDnPatterns(ldapAuthStructure.getUserDnPattern())
      .userSearchBase(ldapAuthStructure.getUserSearchBase())
      .groupSearchBase(ldapAuthStructure.getGroupSearchBase())
      .groupSearchFilter("member={0}").rolePrefix("")
    .contextSource()
      .url(ldapAuthStructure.getLdapUrl()+"/"+ldapAuthStructure.getLdapBase())
      .managerDn(ldapAuthStructure.getLdapManagerDn())
      .managerPassword(ldapAuthStructure.getLdapManagerPwd())
      .and()
    .passwordCompare()
      .passwordEncoder(new LdapShaPasswordEncoder())
      .passwordAttribute("userPassword");

    logger.info("configure method is called to build Authentication manager ...");
  }
```

以下是我们对授权所做的更改:

*   添加了`groupSearchBase`方法调用，并将值作为`ou=roles`传递，这表示组搜索的基础。组搜索基础值(`ou=roles`)存储在我们创建的用于保存 LDAP 连接属性的`ldapAuthStructure`对象中。
*   添加了一个`groupSearchFilter`方法调用，并将值作为`member={0}`传递。它用于定义搜索成员的模式。在运行时，`{0}`将被实际的用户 DN 替换。
*   放置附加方法`rolePrefix("")`来设置角色前缀。如果没有这个方法调用，Spring Security 将在角色名前面加上`ROLE_`。例如，对于 LDAP 服务器中定义的角色`ADMIN`，Spring Security 返回的实际角色将是`ROLE_ADMIN`。为了避免这种情况，我们调用这个方法并简单地传递一个空字符串，这样我们就可以获得我们在 LDAP 服务器中定义的确切的角色名称。

授权的配置部分结束了。您可以在 Apache DS 中创建一些示例用户，为他们分配角色，并检查他们是否能够访问我们创建的页面。没有任何角色的用户不能访问任何页面(管理员或用户)。

这都是关于使用 Spring Security 集成 LDAP 的。在下一节中，我们将研究 OAuth 集成。

# OAuth

典型的 web 应用需要用户名/密码形式的凭证来执行身份验证。HTML 表单用于在浏览器中请求凭证，然后将凭证发送到服务器。然后，服务器验证信息，在服务器端创建并维护会话，并将会话 ID 发送回浏览器。

会话 ID 将在每个请求中发送，服务器将用会话 ID 映射会话，并从数据库中提取某些信息来执行授权。浏览器通常将会话 ID 存储在 cookies 中。只要会话处于活动状态，用户就可以根据分配的权限访问受限资源。

对于客户机-服务器交互来说，这是一种非常简单和容易的机制，因此，今天许多 web 应用和服务仍在使用它。但是，这种模式有一定的局限性，如下所示:

*   一般来说，cookies 是有状态的，所以服务器需要跟踪会话，并针对每个请求检查数据库(或内存)。这可能会导致服务器开销。此外，授权过程与应用服务器密切相关，这导致了一个紧密耦合的系统。
*   对于 REST 客户端，如本地移动应用，cookies 可能无法正常工作。

*   如果应用功能分布在多个域中，可能需要额外的配置来维护 cookie 值。
*   基于 cookie 的模型有授予第三方客户端访问权限的限制。

OAuth 克服了这些限制。根据定义，它是一个授权框架(或者更准确地说是协议)，允许应用访问相同或不同应用中的资源。换句话说，OAuth 2.0 允许代表资源所有者的第三方应用对受保护资源进行有限的访问。它支持移动、web 和桌面应用的授权流。该协议的当前版本是 OAuth 2.0。我们将把 OAuth 2.0 与 Spring Security 集成在一起。

尽管 OAuth 具有会话的普通客户机-服务器机制所不具备的某些特征，但前者不能取代后者。例如，银行应用必须用客户机-服务器机制来实现。这里给出的比较是为了展示如何使用 OAuth 来提供对第三方应用的访问。

# OAuth 角色

在继续之前，理解 OAuth 中使用的某些术语是很重要的。这将提供对其基本概念的深刻理解。它们被称为 OAuth 角色，如下所示:

*   **资源所有者:**可以授权访问受保护资源的个人或实体。OAuth 协议不限于个人。应用与应用之间的交互可以通过 OAuth 实现。如果资源所有者是个人(或用户)，则称为最终用户。
*   **授权服务器:**顾名思义，是以令牌的形式提供授权的实体。资源所有者成功通过身份验证后，授权服务器将向客户端颁发一个访问令牌。
*   **资源服务器:**这是保存受保护资源的服务器。当对受保护资源的请求到达资源服务器时，它将向授权服务器验证访问令牌，并做出相应的响应。
*   **客户端:**发起访问受保护资源的请求以支持资源所有者的实体被称为**客户端**。它可以是任何形式，如要求凭证的移动应用或提供社交媒体替代登录功能的基于网络的应用(如脸书或谷歌)。

这些角色之间的关系如下图所示:

![](assets/4449129b-3238-4c98-a1ce-eea5fec9ee78.png)

作为资源所有者的最终用户与应用进行交互，应用在这里充当客户端。客户端将与授权服务器对话。资源所有者提供凭证，它将首先在授权服务器上被认证。在成功识别之后，授权服务器发布访问令牌，客户端使用该令牌来访问资源服务器上的安全资源，以支持资源所有者。授权服务器也被称为**身份提供商**。

让我们用一个真实的场景来看看 OAuth 中的授权过程。假设约翰有一辆配有智能钥匙的汽车。如今，配有智能钥匙的车辆很常见，如果口袋里没有智能钥匙，车辆就无法操作(甚至无法解锁或启动)。约翰请他的朋友查尔斯去机场接他。他已经给了他一把智能钥匙。查尔斯用智能钥匙启动了汽车。

在这个类比中，智能钥匙授权 Charles 操作 John 的汽车，因为授权涉及用户可以访问的资源，以及它可以使用这些资源做什么。在这种情况下，John 是最终用户(资源所有者)，而 Charles 是客户。智能钥匙是一个访问令牌，而汽车的安全系统可以被认为是一个授权服务器(或身份提供者)，它用智能钥匙(访问令牌)授权 Charles(客户端)。整个汽车是资源服务器(Charles 可以使用汽车的其他功能，如 AC、音乐系统等，因为他被授权使用带有访问令牌(智能钥匙)的汽车)。

# 授权类型

OAuth 协议的关键是为授权提供访问令牌。检索访问令牌的方式被称为**授权**。有各种方式(授权)来访问和使用访问令牌。OAuth 2.0 为不同的场景提供了不同的授权，比如应用的信任级别、应用的类型等等。

OAuth 2.0 支持以下类型的授权。根据应用的类型选择最适合该应用的产品:

*   授权代码
*   含蓄的
*   资源所有者密码凭据
*   客户端凭据

让我们来详细了解一下每一种奖励类型:它们是如何工作的，以及它们最适合哪种情况。

# 授权代码

作为最常用和最广泛使用的方法，授权代码 grant 最适合服务器端应用。**客户端**将是一个 web 应用。为了确保**客户端**与**授权服务器**正常交互，需要配置一些连接参数，如*客户端 ID* 和*客户端秘密、*与**客户端**。由于**客户端**是一个 web 应用，这些参数可以秘密维护。

在这种授权类型中，**客户端**必须能够与**用户代理(浏览器)**协作，因为授权代码是通过浏览器路由的。获得授权码授权的访问令牌的过程可以用下图来描述。由于**资源所有者**在**授权服务器**处被认证，其凭证将不会与**客户端**共享:

![](assets/ee105b78-23eb-48c0-a39d-4b34868c9461.png)

在这种授权类型中，通过以下步骤获得访问令牌:

1.  **客户端**被配置为建立到授权服务器的连接。它将打开**用户代理(浏览器)**中的链接。该链接包含其他信息，授权服务器将使用这些信息来识别并响应**客户端**。通常，该链接在一个单独的窗口中打开，它包含一个登录表单来验证用户，作为授权的第一步。
2.  然后，用户(**资源所有者**)以用户名和密码的形式输入凭证。
3.  浏览器(**用户代理**)然后将这些凭证发送到**授权服务器**。
4.  **授权服务器**验证凭证并将带有授权码的响应发送回**客户端**。
5.  一旦接收到授权码，**客户端**将与**授权服务器**进行交换，以获得访问令牌，并且可选地，获得刷新令牌。
6.  获得访问令牌后，**客户端**可以与**资源服务器**对话以获得受保护的资源。

授权代码流可用于 web 和移动应用客户端。通常，web app 客户端使用*客户端 ID* 和*客户端秘密*，而移动 app 客户端使用**证明密钥进行代码交换(PKCE)** 机制，并利用代码质询和代码验证器。

# 含蓄的

隐式授权类型是专门为浏览器中运行的单页 JavaScript 应用设计的。它与授权代码流非常相似。唯一的区别是在交换授权码的过程中。在隐式授权类型中，由于安全原因，与授权码授权类型相比，客户端将不会从**授权服务器**接收到授权码。

或者，一旦**用户代理**成功发送凭证，**授权服务器**直接向**客户端**发布访问令牌。因为隐式流的目标是单页 JavaScript 应用，所以刷新标记也是不允许的。下图描述了整个过程。

由于**授权服务器**直接发布访问令牌，因此**客户端**和**授权服务器**之间的请求-响应往返减少，与授权码流相比:

![](assets/9910f850-7806-4a80-9137-05a4462f6891.png)

该过程按以下顺序进行:

1.  客户端将在用户代理(浏览器)的一个单独窗口中打开该链接，该窗口包含一个登录表单，作为授权的第一步来验证用户。
2.  然后，用户(资源所有者)以用户名和密码的形式输入凭证。
3.  然后，浏览器(用户代理)将这些凭证发送给授权服务器。
4.  授权服务器验证凭证，并将访问令牌直接发送给客户端。
5.  获得访问令牌后，客户端可以与资源服务器对话以获得受保护的资源。

# 资源所有者密码凭据

资源所有者密码凭据授予类型应该用于高度可信的客户端，因为它直接处理用户凭据。换句话说，只有当**资源所有者**和**客户**之间有足够的确定性和信任时，才应该使用这种授权类型。大多数情况下，客户端将是第一方应用。凭证将由**客户端**直接使用，以与**授权服务器**交互并获得访问令牌。该流程可以用下图来描述:

![](assets/54da154e-3463-4a25-94b1-ca3c42307b4c.png)

该流程可以描述如下:

1.  **客户端**是高度可信的，所以它会直接要求**资源所有者**提供凭证。**客户端**可能是一个高度沉迷的应用。
2.  凭证将由**客户端**发送到**授权服务器**。**客户端**也将向**授权服务器**发送其自身的身份。作为响应，**授权服务器**将发回访问令牌，并且可选地发回刷新令牌。
3.  客户端使用访问令牌来访问**资源服务器**的受保护资源。

# 客户端凭据

客户机凭据授予类型类似于资源所有者密码凭据流。在客户端证书授予中，**客户端**与**授权服务器**交互，通过发送客户端 ID 和客户端秘密来提供标识，并获得访问令牌。一旦接收到访问令牌，**客户端**将与**资源服务器**进行交互。在这种情况下，不应使用刷新令牌。工艺流程如下图所示:

![](assets/c04d5470-6da0-402c-b287-ad9c20a87106.png)

1.  使用**客户端**配置客户端 ID 和客户端密码。**客户端**将与**授权服务器**交互以获得访问令牌。
2.  获得访问令牌后，**客户端**可以与**资源服务器**交互，访问受保护的资源。

# 应该使用哪种授权类型？

了解了每种授权类型的详细信息后，了解特定申请的正确授权类型非常重要。有各种因素在授权类型选择中起着至关重要的作用，如最终用户身份、客户端类型(服务器端、基于 web 的、本机、客户端)以及客户端和资源所有者之间的保证级别。

如果我们计划构建一个应用，并允许其他第三方应用访问资源，那么授权代码流是正确的选择。对于公开托管的应用，这是一种强烈推荐的授权类型。另一方面，如果客户机基于 JavaScript 并在浏览器中运行，我们应该为第三方客户机使用隐式授权类型，为第一方客户机使用资源所有者密码凭证授权。

如果客户端是本地(移动)应用，我们可以选择资源所有者密码凭据授予类型。如果资源所有者不需要最终用户的身份，并且客户端本身的行为类似于资源所有者，则我们应该使用客户端凭据授予类型。通常，客户端凭证授权用于机器(而不是用户)需要授权来访问受保护的资源，而不需要用户许可的情况。

# 与 OAuth 的 Spring 安全集成

了解了 OAuth 2.0 是什么以及它是如何工作的基本原理之后，我们现在来看看 OAuth 在 Spring Security 中的集成。我们将继续使用我们为 LDAP 创建的相同应用，并将对 OAuth 集成进行必要的更改。

对于 OAuth 演示，我们将使用现成的授权提供者。Spring Security 支持 Google、脸书、Okta 和 GitHub 提供商。选择其中一个只需要一定的配置，事情就会开始工作。我们将选择 Google 作为授权服务器(提供者),为我们的应用构建 OAuth。我们将在此集成中使用的授权类型是授权代码。

每个授权提供者都支持某种机制，使客户端能够与服务建立连接。这个过程被称为**应用注册**。

# 申请注册

让我们在 Google 注册(或创建)一个应用，它提供使用授权服务的连接访问。这是开始实现 OAuth 之前的一个重要步骤。Google 提供了一个 **API 控制台**来注册一个应用。访问 API 控制台需要有效的 Google 帐户。前往 https://console.developers.google.com/apis/credentials 的[并遵循以下步骤:](https://console.developers.google.com/apis/credentials)

1.  单击 credentials 选项卡中的 Create credentials 按钮，然后单击 OAuth 客户端 ID 选项。选择应用类型为 Web 应用。
2.  给个合适的名字(比如`SpringOAuthDemo`)。
3.  我们需要在 Google 控制台中设置授权重定向 URI，它代表用户被 Google 成功授权后被重定向的路径。Spring Security 为 Google 提供的默认实现将重定向 URI 配置为`/login/oauth2/code/google`。显然，在我们的例子中，有效的重定向 URI 应该是[http://localhost:8080/springuath/log in/oauth 2/code/Google](http://localhost:8080/springuath/login/oauth2/code/google)(考虑将`8080`作为端口，将`springauth` 作为上下文名称)。在 Google 控制台的授权重定向列表中给出这个 URI，然后点击创建按钮。

成功注册该应用后，Google 将以客户端 ID 和客户端密码的形式创建客户端凭据，如下图所示:

![](assets/6f5dc88c-7ffc-433d-b918-008d54e3e628.png)

客户机 ID 是一种公钥，Google 服务 API 使用它来标识我们已经注册的应用。它还用于构造 Google 登录表单的授权 URL。顾名思义，客户端秘密是一种私钥。当应用(我们注册的)请求用户帐户的详细信息时，在发送用户凭证时，将使用客户端密码来验证应用的身份。因此，客户端机密必须在应用和客户端之间保密。

# Spring Boot 应用的变化

完成前面的需求后，我们将开始对为 LDAP 身份验证创建的 Spring Boot 应用进行必要的更改。目标是构建一个中央认证和授权服务器，它将与两种技术(LDAP 和 OAuth)一起工作。

当用户输入简单的用户名和密码时，将使用 LDAP 进行身份验证和授权。我们将使用 Google 为 OAuth 配置我们的应用。OAuth 集成的第一步是声明相关的启动器。Spring Boot 以首发的形式为 OAuth 提供支持。在`pom.xml`文件中添加以下起始条目:

```java
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
```

在定义这个启动器后，Spring Boot 将自动添加下列依赖项，这些依赖项是 OAuth 集成的基础:

```java
<dependency>
  <groupId>org.springframework.security</groupId>
  <artifactId>spring-security-oauth2-client</artifactId>
</dependency>
<dependency>
   <groupId>org.springframework.security</groupId>
   <artifactId>spring-security-oauth2-jose</artifactId>
</dependency>
<dependency>
   <groupId>org.springframework.security</groupId>
   <artifactId>spring-security-oauth2-core</artifactId>
</dependency>
```

接下来，我们将在`application.propeties`文件中添加客户端 ID 和客户端密码的属性，以及提供者和客户端名称。这些属性的前缀是`spring.security.oauth.client.registration`，以及提供者名称和属性名称。使用我们在上一节中在 Google 开发者控制台中创建的`Client ID`和`Client Secret`来设置这些属性，如下所示:

```java
spring.security.oauth2.client.registration.google.provider=google
spring.security.oauth2.client.registration.google.client-name=Google
spring.security.oauth2.client.registration.google.client-id=<GOOGLE_CLIENT_ID>
spring.security.oauth2.client.registration.google.client-secret=<GOOGLE_SECRET>
```

# 默认的 OAuth 配置

Spring Security 允许配置多个 OAuth 客户端。除了 Google，Spring Security 还支持脸书、GitHub 和 Okta 的默认配置。这意味着所有需要的类和配置都是现成的，我们只需要定义客户端凭证(`Client ID`和`Client Secret`)。接下来，我们将更新`WebSecurityConfig`类的`configure(HttpSecurity http)`方法，如下所示:

```java
@Override
  protected void configure(HttpSecurity http) throws Exception {
     http.authorizeRequests()
      .anyRequest().authenticated()
      .and()
        .oauth2Login();
     super.configure(http);
  }
```

oauth2Login()方法将启动 oauth 调用。此时，在执行应用时，前面的方法将对 Google 进行 OAuth 调用。将要求用户提供有效的 Google 登录凭据。认证成功后，将显示主页。

如果我们为至少一个客户端设置属性，Spring Security 将自动启用`Oauth2ClientAutoConfiguration`类，这将为启用 OAuth 登录做好所有必要的安排，甚至不需要定义前面的`WebSecurityConfig`类。

如果在`application.properties`文件中配置了多个客户端，系统将显示这些客户端的列表，并带有默认登录(用户名和密码)表单。这将是自动生成的登录页面。我们可以使用这些已配置的客户端中的任何一个进行登录。

很明显，在顶部显示用户名，以指示哪个用户当前已登录。我们可以用下面的代码片段获得已经在 Google 认证的用户的名字:

```java
@ModelAttribute("currentUserName")
public String getCurrentUserName() {
  String name = "";
  if(SecurityContextHolder.getContext().getAuthentication() !=null) {
    if(SecurityContextHolder.getContext().getAuthentication() 
        instanceof OAuth2AuthenticationToken) {
      OAuth2AuthenticationToken oauth2Authentication = 
          (OAuth2AuthenticationToken)SecurityContextHolder.getContext().getAuthentication();
      name = (String)oauth2Authentication.getPrincipal().getAttributes().get("name");
    }else {
      String userName = SecurityContextHolder.getContext().getAuthentication().getName();
      LdapAuthUser ldapUser = ldapAuthService.getUser(userName);
      if(ldapUser !=null) {
        name = ldapUser.getFirstName()+" "+ldapUser.getSurName();
      }
    }
  }
  return name;
}
```

这个方法是用`ModelAttribute`定义的，这意味着它可以用`${currentUserName}`表达式直接在表示层中使用。我们正在获取一个`Authentication`的实例，并检查它是否属于类型`OAuth2AuthenticationToken`。`getPrincipal()`方法将返回用户的详细信息以及属性。`name`属性返回登录 Google 的用户的名字。

另一部分将在我们使用 LDAP 执行身份验证时执行，它从`Authentication`对象中获取`userName`，然后调用自定义服务方法(`ldapAuthService.getUser()`)获取 LDAP 用户对象。然后用它来获取用户的名字(名和姓)。

# 带有自定义登录页面的 OAuth

这就是 OAuth 与 Spring Security 集成的方式。在前面的配置中，Spring Boot 提供了一个自动生成的登录页面，这可能足以满足测试目的。在实际场景中，我们可能需要一个定制的登录页面。为了构建一个定制的登录页面，我们需要在`configure(HttpSecurity http)`方法中进行某些配置更改，如下:

```java
 http.authorizeRequests()
  .antMatchers("/","/login").permitAll()
  .antMatchers("/adminPage/").hasAnyAuthority("ADMIN")
  .antMatchers("/userPage/").hasAnyAuthority("USER")
  .anyRequest().fullyAuthenticated()
    .and()
  .oauth2Login().loginPage("/login")
    .defaultSuccessUrl("/privatePage",true)
    .failureUrl("/login?error=true")
    .and()
  .logout()
    .permitAll().logoutSuccessUrl("/login?logout=true");
```

这看起来类似于我们为 LDAP 配置的内容。唯一的变化是我们使用了`oauth2Login()`而不是`formLogin()`。`super.configure(http)` 的称呼已在末尾删除，因为不再需要。如果我们把它放在那里，Spring Boot 将显示一个自动生成的登录页面，所以一定要在最后删除它。

这一更改将显示自定义登录页面，但是 OAuth 提供者列表不会自动显示。我们需要手动准备列表，并在登录页面显示它们。为此，我们需要更新控制器方法`showLoginPage()`，如下所示。这个方法基本上显示了登录页面:

```java
@Autowired
private ClientRegistrationRepository clientRegistrationRepository;

@GetMapping("/login")
public String showLoginPage(@RequestParam(value = "error",required = false) String error,
    @RequestParam(value = "logout", required = false) String logout,Model model) {
  logger.info("This is login page URL ");

  if (error != null) {
    model.addAttribute("error", "Invalid Credentials provided.");
  }

  if (logout != null) {
    model.addAttribute("message", "Logged out");
  }

  String authorizationRequestBaseUri = "oauth2/authorization";
  Map<String, String> oauth2AuthenticationUrls = new HashMap<String, String>();

  Iterable<ClientRegistration> clientRegistrations = (Iterable<ClientRegistration>)  clientRegistrationRepository;

  clientRegistrations.forEach(registration -> 
  oauth2AuthenticationUrls.put(registration.getClientName(), 
      authorizationRequestBaseUri + "/" + registration.getRegistrationId()));
  model.addAttribute("urls", oauth2AuthenticationUrls);

  setProcessingData(model, LdapAuthConstant.TITLE_LOGIN_PAGE);

  return "login";
}
```

这是我们在本章开始时已经创建的登录方法，用于显示登录表单。这些更改是专门针对 OAuth 的。首先，注入`ClientRegistrationRepository`的实例，它代表存储库并存储 OAuth 客户机的主要细节。它是一个接口类型，Spring Boot 提供了`InMemoryClientRegistrationRepository`类的实例作为默认实现。`InMemoryClientRegistrationRepository`为`ClientRegistration`维护一个映射，T3 是一个代表 OAuth 提供者的类。

在前面的代码中，我们从`clientRegistrationRepository`获取了`ClientRegistration`的映射，对其进行迭代，并准备了 OAuth 提供者的列表，该列表带有名称和以`oauth2/authorization`为前缀的授权 URL。我们将它设置为一个模型属性，这样它就可以用于表示层。应用这些更改后，登录页面将如下所示:

![](assets/8b464a88-ab49-4f0f-9a25-08e2fa631a07.png)

# 使用 OAuth 和 LDAP 的双重身份验证

应用现在将显示一个定制的登录页面，以及我们配置的 OAuth 客户端列表。尽管如此，当我们在登录表单中手动输入凭证时，什么也不会发生，因为 Spring 安全性是为 OAuth 配置的。用户在登录表单中输入凭据时，应该使用 LDAP 进行身份验证。为了实现这一点，我们需要专门在 LDAP 中执行某些配置。

这里的目标是使用 LDAP 执行手动身份验证。Spring Security 通过实现`AuthenticationProvider`接口提供了一种定义定制身份验证提供者的方法。首先，我们将编写一个实现该接口并执行 LDAP 身份验证的类，如下所示:

```java
@Component
public class CustomLdapAuthProvider implements AuthenticationProvider{

  @Autowired
  LdapAuthService ldapAuthService;

  @Override
  public Authentication authenticate(Authentication authentication) throws AuthenticationException {
    String userName = authentication.getPrincipal().toString();
    String password = authentication.getCredentials().toString();

    boolean isAuthenticate = ldapAuthService.authenticateLdapUserWithContext(userName, password);

    if(isAuthenticate == true) {
      List<LdapGranntedAuthority> userRoles = ldapAuthService.getUserAuthorities(userName);
      return new UsernamePasswordAuthenticationToken(
          userName, password, userRoles);
    }else {
      return null;
    }
  }

  @Override
  public boolean supports(Class<?> authentication) {
    return authentication.equals(
        UsernamePasswordAuthenticationToken.class);
  }
}
```

类`CustomLdapAuthProvider`是用`@Component`注释定义的，这意味着 Spring 会将它配置为一个 bean，这样它就可以被其他带有`@Autowired`注释的组件使用。`AuthenticationProvider`接口声明了以下两个方法:

*   这是我们可以提供自定义认证的地方。
*   `boolean supports(Class<?> authentication)`:该方法表示该自定义认证提供者是否支持所表示的认证对象。

在`authenticate`方法中，我们首先从`Authentication`的实例中获取`username`和`password`。然后，我们通过调用定制服务方法`authenticateLdapUserWithContext`进行手动认证，我们已经为 LDAP 认证创建了这个方法。如果该方法返回`true`，则意味着凭证有效。

除了验证凭证，我们还需要获取用户拥有的权限(角色)。为了获得它们，我们在自定义存储库`impl`类(`LdapAuthRepositoryCustomImpl`)中定义了一个方法，如下所示:

```java
@Override
public List<LdapGranntedAuthority> getUserAuthorities(String userName) {
  AndFilter groupFilter = new AndFilter();
  groupFilter.and(new EqualsFilter("objectclass","groupOfNames"));
  groupFilter.and(new EqualsFilter("member","uid="+userName+",ou=users,o=packtPublisher"));
  List<LdapGranntedAuthority> userRoleLst =  ldapTemplate.search(LdapQueryBuilder.query().
                      filter(groupFilter),new LdapRoleMapper());
  return userRoleLst;
}
```

`getUserAuthorities`方法接受`userName`并返回权威列表。让我们回忆一下，对于角色，我们已经在 Apache DS 中创建了一个单独的实体(`ou=roles`)。它的所有子节点都代表实际的角色(用属性`cn`作为角色名)。任何属于特定机构(角色)成员的 LDAP 用户都添加了`member`属性。目的是获取当前用户所属的所有权限。

在`ldapTemplate`上的搜索方法接受`LdapQuery`和`ContextMapper`对象，并返回权威列表。`LdapQuery`是用`objectclass`的组过滤器和成员属性值构建的。`objectclass`的值与我们在 LDAP 中赋予实体(`ou=roles`)的`objectclass`的名称相同。成员属性的值将是有效的用户 DN；比如`uid=npatel`、`ou=users`、`o=packtPublisher`。`ContextMapper`是一种仅从`search`方法中检索所需值的机制。更具体地说，`ContextMapper`可用于检索定制结果(将所选值包装在定制 POJO 中)。

这可以通过提供一个`ContextMapper`接口的实现来实现。我们为此实现创建了一个类，如下所示:

```java
public class LdapRoleMapper implements ContextMapper<LdapGranntedAuthority>{

  @Override
  public LdapGranntedAuthority mapFromContext(Object ctx) throws NamingException {
    DirContextAdapter adapter = (DirContextAdapter) ctx;
    String role = adapter.getStringAttribute("cn");
    LdapGranntedAuthority ldapGranntedAuthority = new LdapGranntedAuthority();
    ldapGranntedAuthority.setAuthority(role);
    return ldapGranntedAuthority;
  }
}
```

`ContextMapper`接口是一个原始类型，所以我们将该类型定义为`LdapGranntedAuthority`，这只是一个定制的 POJO。在`mapFromContext`方法中，`DirContextAdapter`的对象用于获取属性为`cn`的角色的名称。然后在`LdapGranntedAuthority`的实例中设置这个角色名，最后返回它。`LdapGranntedAuthority`类如下所示:

```java
public class LdapGranntedAuthority implements GrantedAuthority {

  String authority;
  public void setAuthority(String authority) {
    this.authority = authority;
  }
  @Override
  public String getAuthority() {
    return authority;
  }
}
```

这个 POJO 实现了`GrantedAuthority`接口来设置权限(角色)的名称。现在，让我们回到`CustomLdapAuthProvider`类的 authenticate 方法。获得授权后，我们用用户名、密码和授权列表创建了`UsernamePasswordAuthenticationToken`类的对象。`UsernamePasswordAuthenticationToken`类基本上提供了一个`Authentication`接口的实现。

接下来，在这个自定义身份验证提供程序的帮助下，我们将进行手动身份验证。在此之前，我们必须更改登录表单的动作，因为默认(`/login`)将不再自动工作。在登录表单中，将路径从`/login`更改为`/ldapLogin`。我们还需要创建一个相应的控制器方法来手动处理登录流，如下所示:

```java
@Autowired
CustomLdapAuthProvider customLdapAuthProvider;

@PostMapping("/ldapLogin")
public String ldapAuthenticate(HttpServletRequest req,@RequestParam(value = "username",required = true) String username,
    @RequestParam(value = "password", required = true) String password,RedirectAttributes redirectAttributes) {

  UsernamePasswordAuthenticationToken authReq
  = new UsernamePasswordAuthenticationToken(username, password);
  Authentication auth = customLdapAuthProvider.authenticate(authReq);
  if(auth !=null) {
    logger.info(" If user is authenticated .... "+auth.isAuthenticated());
    SecurityContext sc = SecurityContextHolder.getContext();
    sc.setAuthentication(auth);
    HttpSession session = req.getSession(true);
    session.setAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY, sc);

    if(auth.isAuthenticated() == true) {
      return "redirect:/privatePage"; 
    }else {
      redirectAttributes.addAttribute("error", "true");
      return "redirect:/login";
    }
  }else { // failed authentication - either username or password fails.
    redirectAttributes.addAttribute("error", "true");
    return "redirect:/login";
  }
}
```

`CustomLdapAuthProvider`的实例被注入了`@Autowired`注释。这个方法是用`@PostMapping`注释定义的，用 POST 方法处理登录表单。我们使用登录表单中提交的用户名和密码创建了`UsernamePasswordAuthenticationToken`的实例，并将其传递给`CustomLdapAuthProvider`的`authenticate`方法，该方法主要使用 LDAP 进行身份验证并获取用户权限。一旦身份验证完成，我们将把身份验证对象存储在 Spring 安全上下文中。

最后，我们在 HTTP 会话中保存了安全上下文，这样 Spring Security 将在会话中创建和维护用户认证信息。执行完所有这些过程后，我们通过调用身份验证对象上的`isAuthenticated`方法来检查身份验证是否成功。根据身份验证状态(成功或失败)，我们将流重定向到私人页面(身份验证成功时)或登录页面(身份验证失败时)。这都是关于使用 LDAP 和 OAuth 的双重认证。接下来，我们将说明 OAuth 在定制授权服务器上的实现。

# 使用自定义授权服务器进行 OAuth 授权

现在，您已经看到了 OAuth 使用第三方提供商(Google)与 Spring 的集成。在本节中，我们将构建一个定制的授权服务器(提供者)并进行 OAuth 授权。我们还将构建自己的资源服务器，一旦授权完成，我们将访问这些资源。

在上一节中，Google 使用了授权码授权类型。我们将在本节中实现一个隐式授权类型。让我们回忆一下，隐式授权类型是专门为 JavaScript 应用设计的。由于它在浏览器中运行，授权服务器直接发送访问令牌。出于安全目的，不支持刷新令牌。

我们将首先开发一个定制的授权服务器(provider ),它将提供访问令牌。我们可以考虑用它来代替前一节中的 Google，在那里我们开发了一个用于授权的客户端。对于我们的自定义授权，我们将设置一个带有凭证(一个 ID 和密码)的客户端，它将用于提供授权(以提供访问令牌的形式)。

我们将为授权和资源服务器创建单独的 Spring Boot 应用，并且我们需要同时运行它们，以便测试功能。为了避免端口冲突(两个应用的默认端口都是 8080)，我们需要在运行它们时显式设置端口。为此，您需要在`application.properties`文件中使用属性`server.port`给出一个不同的端口。

# 授权服务器配置

我们将开发一个单独的 Spring Boot 应用，并应用必要的配置将其用作授权服务器。这是我们的定制授权服务器。创建一个名为`SpringCustomAuthorization` 的 Spring Boot 应用，并添加以下组件，这基本上是构建定制授权服务器的基本入口点:

```java
@Configuration
@EnableAuthorizationServer
public class CustomAuthorizationConfig extends AuthorizationServerConfigurerAdapter{

  @Autowired
    @Qualifier("authenticationManager")
    private AuthenticationManager authenticationManager;

  @Autowired
  PasswordEncoder encoder;

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) 
      throws Exception {
        clients.inMemory()
          .withClient("c1")
          .authorizedGrantTypes("implicit")
          .scopes("read", "write", "trust")
          .secret(encoder.encode("123"))
          .redirectUris("http://localhost:8082/privatePage")
          .resourceIds("oauth2-server");
    }

    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey("123");
        return converter;
    }

    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(accessTokenConverter());
    }

    @Override
    public void configure(
      AuthorizationServerEndpointsConfigurer endpoints) 
      throws Exception {
        endpoints
          .authenticationManager(authenticationManager)
          .tokenServices(tokenServices())
          .tokenStore(tokenStore())
          .accessTokenConverter(accessTokenConverter());
    }

    @Bean("resourceServerTokenServices")
    @Primary
    public DefaultTokenServices tokenServices() {
        DefaultTokenServices defaultTokenServices = new DefaultTokenServices();
        defaultTokenServices.setTokenStore(tokenStore());
        defaultTokenServices.setSupportRefreshToken(false);
        defaultTokenServices.setAccessTokenValiditySeconds(120);
        defaultTokenServices.setTokenEnhancer(accessTokenConverter());
        return defaultTokenServices;
    }
}
```

通过`@EnableAuthorizationServer`注释，这个类声称提供了授权服务器的配置。为了更详细地理解这个概念，我们将把配置定制授权服务器的每个步骤与我们在 Google OAuth 集成中已经做的事情联系起来。这个配置的第一步是定义一个客户机，它基本上与授权服务器对话以获得访问令牌。

`configure(ClientDetailsServiceConfigurer clients)`方法用于定义具有各种元数据的客户机，如客户机 ID、授权类型、范围、秘密和重定向 URI。`resourceId`用于与资源服务器配对。我们将在本章稍后创建资源服务器时配置相同的`resourceId`。我们在这里使用的客户机类型是内存中的，这适合于开发目的。

另一种类型是 JDBC，其中客户端详细信息可以存储在数据库中。我们可以用这种方法配置多个客户端，每个客户端都可以用`.and()`方法调用来分隔。客户端是在授权服务器中创建的。我们可以将这与我们在 Google 开发者控制台中创建的客户端联系起来。

`tokenStore()`方法用于构造一个访问令牌。Spring 提供了各种机制来创建令牌，比如`InMemoryTokenStore`、`JdbcTokenStore`、`JwkTokenStore`和`JwtTokenStore`。其中，我们使用了`JwtTokenStore`。`accessTokenConverter()`方法用于使用签名密钥对令牌进行编码/解码。

在资源服务器上配置令牌存储时，我们需要使用相同的签名密钥。`tokenServices()`方法用于配置带有令牌存储的令牌服务，以及一些设置。由于授权类型是隐式的，刷新令牌是不允许的，所以我们将`setSupportRefreshToken()`设置为`false`。我们还可以通过`setAccessTokenValiditySeconds()`方法设置令牌的有效期。由于这是一个隐式流，并将由 JavaScript 应用使用，出于安全原因，令牌应该是短期的。

最后，`configure(AuthorizationServerEndpointsConfigurer endpoints)`方法是一个粘合点，用于将我们到目前为止配置的东西组合在一起。一般来说，用户认证是在授权之前进行的，使用`AuthenticationManager`的对象来进行认证。定义授权配置后，让我们通过应用安全配置来确保它的安全，如下所示:

```java
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    @Bean("authenticationManager")
    public AuthenticationManager authenticationManagerBean() throws Exception {
      AuthenticationManager authenticationManager = super.authenticationManagerBean(); 
      return authenticationManager;
    }

    @Override
  public void configure(WebSecurity web) throws Exception {
    web.ignoring().antMatchers("/js/**");
    web.ignoring().antMatchers("/css/**");
  }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) 
      throws Exception {
        auth.inMemoryAuthentication()
          .withUser("john").password(new BCryptPasswordEncoder().encode("123")).authorities("USER");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
       http
         .authorizeRequests()
         .antMatchers("/oauth/authorize","/").permitAll()
         .and()
         .formLogin().loginPage("/login").permitAll();
    }

    @Bean("encoder")
    public BCryptPasswordEncoder encoder(){
        return new BCryptPasswordEncoder();
    }

}
```

使用`@EnableWebSecurity`注释，Spring 安全性将应用于授权服务器。这是一个普通的 Spring 安全配置，您已经在前面的章节中看到过了。`/oauth/authorize`是默认的授权端点。资源服务器将在这个路径上发起一个授权调用，所以我们在`configure`方法中配置了它。

我们已经创建了一个具有凭证和权限的内存用户。我们可以将它与 Google 中的用户帐户关联起来，当我们向 Google 发起授权时，会询问该帐户。在我们的例子中，当在定制授权服务器上启动授权过程时，我们将提供这个凭证。

我们的授权服务器现在已经准备好了。不能直接访问它；相反，资源服务器使用某些参数发起请求。接下来，我们将构建资源服务器。

# 资源服务器配置

顾名思义，**资源服务器**持有资源(以数据、服务、文件等形式)，资源所有者可以通过提供有效授权来访问这些资源。提供授权的过程以**令牌共享机制**的形式发生。

授权服务器在认证之后创建令牌，资源服务器使用该令牌来服务受限资源。对于所有进入的对受保护资源的请求，资源服务器将向授权服务器检查访问令牌的有效性。简而言之，这就是系统的流程。现在，我们将创建一个带有独立 Spring Boot 应用的资源服务器。

Spring 允许通过声明某些基本配置来创建资源服务器，如下所示:

```java
@Configuration
@EnableResourceServer
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {

private static final String RESOURCE_ID = "oauth2-server";

  @Override
  public void configure(ResourceServerSecurityConfigurer resources) {
    resources
      .tokenStore(tokenStore())
      .resourceId(RESOURCE_ID);
  }

  @Override
  public void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/api/**").authenticated()
            .and().exceptionHandling().accessDeniedHandler(new OAuth2AccessDeniedHandler());
  }

  @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(accessTokenConverter());
    }

  @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey("123");
        return converter;
    }

}
```

`@EnableResourceServer`注释将指示 Spring Security 将组件视为资源服务器，并使用访问令牌验证传入的请求。在这个配置中，我们使用授权服务器中使用的相同的`resourceId`。此外，创建和转换令牌以及签名密钥的过程与我们在授权服务器中实现的过程相同。

对于类型为`Jwt`的令牌，我们也可以使用公钥-私钥作为生成访问令牌的签名密钥。在正常情况下，在授权和资源服务器上声明的签名密钥必须相同。

这个类的`configure(HttpSecurity http)`方法是我们可以配置受保护资源的路径的地方。在我们的例子中，我们配置了`/api/**`，这意味着任何以`/api/`开头的路径都被认为是安全的。没有有效的令牌，用户无法访问该路径。我们还定义了适当的拒绝处理程序，以便在令牌无效或权限不足的情况下显示适当的消息。接下来，我们将为资源服务器配置 Spring 安全性，如下所示:

```java
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter{
      @Override
      protected void configure(HttpSecurity http) throws Exception {
         http
           .authorizeRequests()
           .antMatchers("/","/customAuth").permitAll()
        .anyRequest().authenticated();
      }
  }
```

这是一个简单的安全配置，我们已经声明了所有人都可以访问某些路径。接下来，我们将创建一个 Spring MVC 控制器，它将显示我们可以从中启动授权的页面，如下所示:

```java
@Controller
public class WebController {

  private Logger logger = LoggerFactory.getLogger(WebController.class);

  @GetMapping("/")
  public String showHomePage(Model model) {
    logger.info("This is show home page method ");
    setProcessingData(model, "Home Page");
    return "home";
  }

  @GetMapping("/privatePage")
  public String showControlPage(Model model) {
    logger.info("This is privaet page ");
      setProcessingData(model, "Private Page");
      return "private-page";
  }

  @GetMapping("/customAuth")
  public String authorizeUser(Model model,@Value("${custom.auth.authorization-uri}") String authorizationUri,
      @Value("${custom.auth.client-id}") String clientId,
      @Value("${custom.auth.client-secret}") String clientSecret,
      @Value("${custom.auth.grant-type}") String grantType,
      @Value("${custom.auth.response-type}") String responseType) {

      UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(authorizationUri)
                .queryParam("username", clientId)
                .queryParam("password", clientSecret)
                .queryParam("grant_type", grantType)
                .queryParam("response_type", responseType)
                .queryParam("client_id", clientId);

      return "redirect:"+uriBuilder.toUriString();
  }
}
```

前两个方法分别显示主页和私人页面。我们将在主页上显示一个启动授权过程的链接。这个链接会调用`authorizeUser()`方法(用链接`/customAuth`)。该方法获取在`application.properties`文件中定义的客户端元数据，如下所示:

```java
custom.auth.authorization-uri=http://localhost:8081/oauth/authorizee
custom.auth.client-id=c1
custom.auth.client-secret=123
custom.auth.grant-type=implicit
custom.auth.response-type=token
```

在`authorizeUser()`方法中，我们将流程重定向到授权 URI，以及`client-id`、`client-secret`、`grant-type`和`response-type`参数。`oauth/authorize`是默认的授权端点。

让我们回忆一下，在授权服务器中进行客户端设置时，我们将`redirectUri`配置为[http://localhost:8082/private page](http://localhost:8082/privatePage)，这意味着在授权之后，流程将返回到这个 URL，最终显示一个私有页面，以及访问令牌。

一旦我们得到令牌，我们就可以开始消耗受保护的资源。我们已经在资源服务器配置中将路径`/api/**`定义为受保护的资源。因此，让我们创建一个 REST 控制器，如下所示，它将提供资源。出于演示目的，我们将返回一些示例数据:

```java
@RestController
@RequestMapping("/api")
public class ServiceAPIController {

  private Logger logger = LoggerFactory.getLogger(ServiceAPIController.class);

  @RequestMapping("/currentUser")
  public Principal getUser(Principal user) {
    return user;
  }

  @RequestMapping("/adminresource")
  public String adminResource(Principal user) {
    return "{\"id\":\"" + user.getName() + "\",\"content\":\"Hello World\"}";
  }

  @RequestMapping(value="/usergreeting", method = RequestMethod.GET, produces = {MediaType.APPLICATION_JSON_VALUE})
  public String userResource(Principal user) {
    return "{\"id\":\"" + user.getName() + "\",\"content\":\"Hello World\"}";
  }

  @RequestMapping(value = "/userlist", method = RequestMethod.GET)
  public ResponseEntity<List<SampleUser>> listAllSampleUsers() {
      logger.info("Listing all users...");
      SampleUser s1 = new SampleUser();
      SampleUser s2 = new SampleUser();

      s1.setFirstName("Nilang");
      s1.setLastName("Patel");

      s2.setFirstName("Komal");
      s2.setLastName("Patel");

      List<SampleUser> users = new ArrayList<SampleUser>();

      users.add(s1);
      users.add(s2);
      return new ResponseEntity<List<SampleUser>>(users, HttpStatus.OK);
    }

}
```

REST 控制器配置了 path `/api`，这意味着它的所有方法都可以通过有效的授权令牌进行访问。现在，是运行应用和测试流程的时候了。我们将首先运行资源服务器应用( [http://localhost:8082](http://localhost:8082) ，假设它正在端口`8082`上运行)。它将显示一个链接，该链接会将流重定向到授权服务器。

在流到达授权服务器后不久，它会提示一个登录页面。这是因为授权服务器甚至在开始授权之前就需要有效的身份验证。这是有意义的，因为授权服务器将授权给定的用户帐户，为此，用户必须登录。我们将使用我们为授权服务器创建的内存中凭据。

登录后不久，授权服务器会显示一个中间页面，询问用户是允许还是拒绝。基于此，用户可以访问资源服务器上的受限资源，如下所示:

![](assets/56135b7d-db6e-4b8f-a40d-26515f933566.png)

这类似于我们在 Google 开发者控制台中创建一个客户端并对其进行授权。当时，首先，我们给 Google 凭据，认证后，它要求批准客户端的访问。当我们授权客户端时，它将使用访问令牌重定向到资源服务器的私有页面。

此时，响应中返回带有`#`字符的访问令牌。要访问任何受保护的资源，我们需要在访问令牌后面加上`?`，这样它将作为请求参数提供。否则，资源服务器将不允许访问任何受保护的资源。

现在，我们可以使用访问令牌访问受保护的资源。rest 控制器(路径为`/api`)将为资源提供服务。比如 URL[http://localhost:8082/API/user greeting？access _ token =<token _ string>](http://localhost:8082/api/usergreeting?access_token=%3Ctoken_string%3E)将给出以下输出:

![](assets/39988647-0eeb-4943-8c43-532f04a1dbaa.png)

如果请求是在令牌有效期结束后发出的，它将显示一个`token expired`错误。如果原始令牌被更改，它还会抛出一个`invalid token`错误。如果不提供令牌，它将显示类似于`Full authentication is required to access this resource`的错误。

# 方法级资源权限

现在，授权用户可以访问我们配置的所有资源。如果可以基于用户角色访问资源，那会有多好？它将提供对资源更细粒度的控制。这可以通过在 Spring Security 中应用方法级配置来实现。为此，首先，我们需要定义一个表示方法级 Spring 安全配置的类，如下所示:

```java
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {

  @Override
  protected MethodSecurityExpressionHandler createExpressionHandler() {
    return new OAuth2MethodSecurityExpressionHandler();
  }
}
```

在方法级别定义授权约束需要使用`@EnableGlobalMethodSecurity`注释。基类`GlobalMethodSecurityConfiguration`提供了方法级安全配置的默认实现。

我们已经覆盖了`createExpressionHandle`方法来提供`OAuth2MethodSecurityExpressionHandler`而不是现成的`DefaultMethodSecurityExpressionHandler`。Spring Security 使用 AOP 代理机制来应用方法级安全配置。

`prePostEnabled`和`securedEnabled`选项在方法级别启用各自的注释，以定义授权规则。例如，`prePostEnabled`将允许定义 Spring 安全前/后注释`@PreAuthorize`和`@PostAuthorize`。这些注释允许基于表达式的访问控制，这意味着我们可以使用 Spring **EL(表达式语言)**来描述规则。

`@PreAuthorize`将在进入方法之前评估表达式，而`@PostAuthorize`将在方法执行完成后验证表达式，并可能改变结果。`@EnableGlobalMethodSecurity`的`securedEnabled`选项用于定义`@Secured`注释。使用`@Secuired`注释，我们可以在一个方法上指定一个角色列表。让我们来看看这个注释的几个例子，如下所示:

```java
@Secured("ROLE_USER")
public String getUserAccnt() {
....
}
@Secured({ "ROLE_USER", "ROLE_ADMIN" })
public String getCompanyPolicy() {
....
}
```

角色为`ROLE_USER`的用户可以访问`getUserAccnt`方法。至少拥有`ROLE_USER`和`ROLE_ADMIN`中一个角色的用户将调用`getCompanyPolicy`方法。`@Secuired`注释不允许用 Spring EL 定义表达式。另一方面，`@PreAuthorize`和`@PostAuthorize`注释允许 Spring EL 定义表达式，这意味着我们可以定义更复杂的条件。我们来看一些`@PreAuthorize`的例子，如下:

```java
@PreAuthorize("hasAuthority('ADMIN') and #oauth2.hasScope('read')")
public String adminResource(Principal user) {
  ...
}
@PreAuthorize("hasAuthority('USER') and #oauth2.hasScope('read') or (!#oauth2.isOAuth() and hasAuthority('USER'))")
public String userResource(Principal user) {
  ...
}
@PreAuthorize("hasAuthority('ADMIN') or #oauth2.hasScope('trust') or (!#oauth2.isOAuth() and hasAuthority('ADMIN'))")
public ResponseEntity<List<SampleUser>> listAllSampleUsers() {
  ...
}
```

第一种方法(`adminResource`)对于具有`USER`角色的用户是可访问的，并且客户端应该具有`read`范围。让我们回忆一下，对于我们在授权服务器中配置的客户机，我们设置了三个范围:读、写和信任。`#oauth2`变量是现成提供的，用于检查客户端拥有的各种范围。我们可以在`#oauth2`变量上使用其他方法，比如`clientHasRole()`、`clientHasAnyRole()`、`hasAnyScope()`、`isOAuth()`、`isUser()`、`isClient()`等等。它们在类别`OAuth2SecurityExpressionMethods`中定义。简而言之，变量`#oauth2`代表这个类的对象。

第二种方法(`userResource`)稍微复杂一些，可以在以下条件下使用:

*   一个用户有一个`USER`角色，一个客户有一个`read`范围
*   一个请求不是 OAuth 类型的(它可能由机器客户端提出),并且一个用户有一个`USER`角色

第三种方法(`listAllSampleUsers`)类似于第二种方法，可以在以下情况下使用:

*   用户有一个`ADMIN`角色
*   客户端有一个`trust`范围
*   一个请求不是 OAuth 类型的(它可能由机器客户端提出),并且一个用户有一个`ADMIN`角色

这就是使用定制授权服务器实现隐式授权类型的方式。使用隐式授权类型时，需要注意一些事情。因为它是为 JavaScript 应用设计的，所以授权和资源服务器都应该可以安全地访问(通过 HTTPS)。第二件事是，在隐式授权类型中，访问令牌由授权服务器直接返回给浏览器，而不是在可信的后端；强烈建议配置短期访问令牌，以降低访问令牌泄露的风险。

隐式流中的另一个挑战是它不允许刷新令牌。这意味着在短期令牌过期后，应该提示用户再次启动流；或者，更好的方法可能是设置一种机制，比如`iframe`，以便不间断地获取新令牌。

作为一个练习，您可以在授权服务器中创建更多具有不同角色的用户，并使用这些角色配置资源方法，检查它们是如何可访问的。

# 摘要

安全性是任何系统的重要组成部分。它的有效性取决于各个方面，比如简单性、特性丰富性、与其他系统集成的容易程度、灵活性、健壮性等等。这一整章都是基于 Spring Security 的。这是一个成熟的框架，用于保护基于 J2EE 的应用。

在本章中，我们更深入地探讨了 Spring 安全性，尤其是它如何与 LDAP 和 OAuth 集成。我们从 LDAP 的基础开始，包括它的数据结构和设置；我们在 Apache DS 中创建了这个结构，Apache DS 是一个 LDAP 服务器。然后，我们研究了 Spring Security 所需的配置，以将其与 LDAP 集成。

除了使用 LDAP 进行身份验证，我们还探索了如何从 Spring 应用管理 LDAP 中的用户。我们使用 Spring 数据框架来实现这一点。接下来，我们为 LDAP 中的角色(权限)创建了一个结构。在相同的序列中，我们获取角色细节，并使用 LDAP 在 Spring Security 中实现授权。

在本章的后面，我们开始介绍另一种机制，叫做 OAuth。它是基于令牌授权的开放标准。我们从 OAuth 角色的基础开始，然后探讨了各种授权类型的细节；您还了解了应该在何时使用哪种授权。更进一步，我们开始了与 OAuth 的 Spring 安全集成。我们使用 Google 来实现 Spring Security 的授权代码流。

使用默认的 OAuth 实现，Spring Security 显示自动生成的登录页面。我们展示了如何在 OAuth 中实现定制的登录页面。到目前为止，您只看到了独立的两种不同的机制，LDAP 和 OAuth。我们将它们集成在一起，创建了双重身份验证。

然后，我们用授权代码流实现了 OAuth。接下来，我们展示了如何使用定制授权和资源服务器实现隐式流。我们为授权和资源服务器执行了一组配置，并且成功地实现了一个隐式流。最后，我们在 Spring Security 中应用了方法级授权。

在下一章，我们将探索另一个工具，叫做 JHipster。它是一个开源的应用生成器框架，主要用于开发 web 应用和微服务，以响应式 web 前端(Angular 或 React)和 Spring 框架作为后端。