# 二、构建反应式 Web 应用

在第一章、*中，我们通过探索 Spring 框架及其模块系统的一些基础知识开始了我们的旅程，创建了一个应用来列出世界各国的 GDP* 。让我们暂时离开 Spring Framework 的所有新的和高级的主题，在这一章中，我们来看一个最流行的主题:如何通过采用一个反应式范例来制作高度可伸缩和响应的应用。

技术世界正在从阻塞、同步和线程驱动的实现向非阻塞、异步和基于事件的系统迁移，这些系统具有弹性，能够以一致的响应时间管理大量数据。这是反应式系统解决的核心问题。

从编程模型的角度来看，反应式编程已经影响了从命令式到异步逻辑的声明式组合的范式转变。从版本 5 开始，Spring Framework 通过将反应流功能整合到其核心框架中实现了这一点。

在这一章中，我们将从不同的维度和角度讨论和探索反应式编程，主题如下:

*   什么是反应式系统
*   反应式编程简介
*   反应式编程的基础、优点和特性
*   Java 中的反应式编程
*   WebFlux 简介
*   反应式编程的Spring支持
*   使用 WebFlux 进行反应式编程的函数式工作方式
*   反应式范例中的 WebSocket 支持

# 技术要求

本章用到的所有代码都可以从以下 GitHub 链接下载:[https://GitHub . com/packt publishing/Spring-5.0-Projects/tree/master/chapter 02](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02)。该代码可以在任何操作系统上执行，尽管它只在 Windows 上测试过。

# 反应系统

reactive 这个词在今天变得很流行，对不同的人有不同的含义，比如轻量级、实时、异步、流式等等。**反应式**，从更广泛的意义上来说，指的是一套设计技术或原则，是一种在分布式环境下考虑系统架构的方式。它包括工具、设计方法和实现过程。

团队的类比可以用来描述一个反应系统:个体玩家相互合作以达到预期的目标。组件之间的交互是反应式系统区别于其他系统的主要特征。组件可以单独运行，也可以与其他组件协调工作，以实现整个系统的预期结果。换句话说，系统设计允许各个子应用形成一个单一的逻辑系统，执行特定的任务，并保持相互了解。这有助于做出决策，如负载平衡、伸缩、故障转移缓解等。

在谈论反应性话题时，主要是在软件设计和开发的背景下，人们通常会互换使用术语**反应性系统**和**反应性编程**，尽管它们并不完全相同。反应式系统是消息驱动的，并与网络上的分布式过程通信相关联，而反应式编程通常是事件驱动的，并在本地处理。

许多软件工程师认为反应式系统与异步的基于消息的系统是一样的。但是根据反应式宣言，反应式系统是一种以反应式风格开发分布式系统的架构方式。它具有以下基本特征:

*   **Responsive:** 它建议系统应该在合理的时间内处理和响应请求。

*   弹性:它表明即使在出现故障的情况下，系统也应该保持响应。简而言之，任何类型的错误都不应该将系统置于无响应状态。必须妥善处理所有可能导致系统错误的因素，而不会导致系统停机。
*   **弹性:**即使负载变化，系统也应该保持响应。它应该能够根据负载灵活地伸缩，并以合理的资源使用来处理它。为了实现这一点，应用的设计必须避免任何中心瓶颈。
*   **消息驱动:**反应式系统中的组件应该通过异步消息传递进行交互。这带来了组件之间的松耦合、职责上的隔离和位置上的透明。

在这些特征中，响应性、弹性和伸缩性是当今几乎每个现实应用的标准要求。它们看起来简单明了，但是实现起来很棘手。正是消息驱动的需求将响应式系统与其他系统区分开来。

反应式系统使用异步消息传递机制在组件之间进行交互。它还提供了一种非阻塞机制来控制数据流。在构建一个反应式系统时，在所有相关的点上，数据处理操作被组合成流。简而言之，反应式系统专注于流处理。

# 反应式编程

反应式编程可用于构建反应式系统。根据定义，**反应式编程**是一种围绕数据流和变化传播的编程实践或模式。数据中的更改由底层执行模型通过数据流自动传播。

简单来说，反应式编程是一种以更有效的方式处理异步数据流的方法。换句话说，它是处理异步数据流的编程，或者它可以被称为异步编程的子集。反应式编程是一种执行方式，其中新信息将推动流程向前，而不是由执行线程控制流程。

数据流是在系统执行过程中发生的一系列业务事件，例如各种键盘或鼠标事件、HTML 字段更改、HTTP 请求、通知、REST API 数据提取、触发验证、web 组件状态更改、数据更新或任何其他可能导致数据流更改或改变程序行为的事件。

简而言之，反应式编程涵盖了由异步数据流引起的流中的动态反应。当一个组件发生变化时，反应式库或框架会自动将这些变化传播到其他组件。很有可能定义一个静态的顺序来传播变更。

下图显示了反应式编程与命令式编程的不同之处:

![](assets/0706314d-9be6-4982-bbcf-c07d4b00c25e.png)

在**命令式编程**中，线程以同步的方式相互对话，导致通信阻塞。一个线程必须等待，直到资源的依赖线程空闲，这可能导致低效的利用和系统中容易出现瓶颈的情况。另一方面，反应式编程不需要等待；事实上，一旦资源可用，就会通知它，以便它可以同时做其他工作。这降低了系统挂起的风险，并使其响应迅速。这有效地保持了平稳的资源使用。

反应式编程建议将给定的需求分解成单独的步骤，这些步骤可以以异步、非阻塞的方式完成，然后组合起来形成最终的输出。在反应式编程环境中，异步意味着消息或事件的处理发生在某个任意时间，很可能是在未来。

反应式编程的异步和非阻塞特性在资源共享的应用环境中特别有用；当资源在别处被占用时，不需要暂停执行线程。

# 反应式编程基础

在过程编程模型中，任务被描述为按顺序执行的一系列动作。另一方面，反应式编程模型促进了传播变更的必要安排，这有助于决定做什么而不是如何做。

让我们用一个非常基本的例子来理解这个概念，如下所示:

```
    int num1=3;
    int num2=5;
    int num3 = num1 + num2;

    System.out.println("Sum is -->"+num3);
    num1=6;
    num2=8;
    System.out.println("Sum is -->"+num3);
```

这是我们通常在过程式编程风格中所做的。在这段代码中，我们只是简单地将两个数相加，然后输出第三个数。在下一行中，我们更改了前两个数字的值，但没有更新第三个数字。这是因为`num1 + num2`只在那一行被赋值给`num3`。现在考虑 Excel 表格中的相同等式，如下所示:

![](assets/e8c00769-ab38-455b-98c9-8dcdc5d03102.png)

在这种情况下， **E** 和 **F** 列的变化总是听 **G** 列的。这就是反应式编程的作用。它将更改传播给对这些更改感兴趣的人。

您可能在日常编码实践中不知不觉地使用了反应式编程。例如，如果您创建了一个用户注册屏幕，在该屏幕上您验证了系统中已经存在的用户输入的用户名，则发出一个 Ajax 调用并显示一条适当的消息，说明该用户名已经被使用。

另一个例子是侦听器或回调函数，您可以通过在网页上单击鼠标或击键来定义它。在这些情况下，鼠标点击和聚焦事件(用于用户名验证)可以被视为一个事件流，您可以对其进行监听并执行适当的操作或功能。

这只是事件流的一种用法。反应式编程允许您观察由事件流引起的任何变化并对其做出反应，例如数据库中的变化、用户输入、属性更新、来自外部资源的数据等等。我们举个现实生活中的例子来理解一下。

让我们说，你想投资于共同基金，有许多公司提供设施，代表你投资。他们还生成关于各种基金的表现以及它们的历史、市场份额、资本投资比率等的统计数据。在此基础上，他们给出了一些类别，如中度风险、低风险、中度高风险、高风险等。他们还根据每只基金的表现给出评级。

评级和类别将建议用户根据他们的需求(短期、长期等)和他们能够承受的风险类型选择特定的基金。评级和类别中发生的变化可以被认为是导致系统改变对用户的建议的事件(或数据流)。数据流的另一个实际例子是社交媒体提要，比如脸书、Twitter 等等。

**Function reactive** 是一个以函数方式对数据流做出反应的范例，提供了额外的特性，如过滤器、合并、缓冲区、地图等等。使用它们，您可以对数据流执行某些操作，这有助于它以更好的方式做出反应。以前面的共同基金为例，过滤功能可用于实时推荐那些投资安全的基金。

反应式编程主要用于构建交互式用户界面和其他需要时间交互的系统，如图形应用、动画、模拟、聊天机器人等。

# 反压力

在反应式编程中，你应该知道的一个重要概念是背压。与传统代码相比，它显著改进了反应式编程。到底是什么？它被认为是一种非阻塞调节机制，用于向流的源发送异步消息或反馈，以进行负载调节。返回到流发送方的通信可能是请求或警告停止。然而，它也可能是关于接收者处理更多信息的意图。返回给发送者的通信必须是非阻塞的。这很重要。

考虑这样一种情况，其中可观察对象(事件源)发送数据的速率高于订阅者实际能够处理的速率。在这种情况下，订户将处于紧张状态，无法正确处理流，并且系统很有可能会出现意外行为。为了避免这种情况，必须有一些安排来将订户可以消费数据的速度传送回可观测量。

通知事件源说，*嘿，我有压力，* *所以不要再发送消息了，因为我在特定时间*可以消耗 X 条消息，这种机制被称为**背压**。如果没有这种情况，系统可能会不断增加缓冲区大小，直到耗尽内存错误。当排放速度快于消耗速度时，就需要背压。它将确保系统在负载下保持弹性，并将提供用于做出系统是否需要额外资源的决定的信息。

# 反应式编程的好处

几年前，用户交互仅限于在网页上填写表单并提交给服务器。这在当时仅够自给自足的应用使用。今天，在移动和响应需求的时代，显示实时信息的丰富用户界面被期望提供广泛的交互可能性。

此外，不同类型的应用，如云环境、分布式应用、物联网和实时应用，需要大量的用户交互。这可以通过反应式编程来实现。它用于构建松散耦合、响应迅速且可伸缩的应用，这些应用对故障的容忍度更高。使用反应式编程有许多优点，如下所示:

*   **资源利用率:**反应式编程的一个重要优势是优化硬件资源利用率，如处理器、内存、网络等。它还通过减少序列化来提高性能。

*   **增强的用户体验:**反应式编程通过使用异步机制来提供更好的用户体验，使应用更流畅、响应更快、更易于交互。
*   一致性:你可以为每件事设计更加一致的 API，包括数据库调用、前端、网络、计算，或者任何你可能需要的反应式编程。
*   **轻松处理:**反应式编程对开箱即用的异步操作有一流的支持和明显的机制。此外，它使处理 UI 交互和事件管理变得更加容易。
*   **简单的线程管理:**反应式编程比常规线程机制更简单。复杂的线程实现，使并行以同步的方式工作，并在函数完成时执行回调，这些用反应式编程更容易实现。
*   **提高开发人员的工作效率:**在典型的命令式编程模型中，开发人员必须做大量的工作来维护一种简单的方法来实现异步和非阻塞计算。另一方面，反应式编程通过提供开箱即用的特性来解决这一挑战，因此开发人员不需要元素之间的显式协调。

# 反应式编程技术

反应式编程在大多数情况下是基于事件的。在反应式编程中，API 有以下两种形式:

*   **回调:**在这种类型中，匿名例程作为回调函数注册到事件源。当事件被数据流触发时，它们将被调用。
*   **声明性:**通过定义良好的功能组合来观察事件，如过滤器、映射和其他基于流的操作，如计数、触发等。

反应式编程将重点放在数据流上，而不是控制流上，因此将其视为数据流编程并不罕见。有多种技术可用于实现反应式编程，如下所示:

*   **期货与承诺:**它是指一种定义变量并赋予其值的技术。虽然期货和承诺可以互换使用，但它们并不完全相同。future 用于描述变量的只读视图(或者说，定义变量)，而 promise 是一个可写的单赋值容器，用于设置未来变量的值。
*   **反应流:**它被定义为异步流处理的标准，能够在事件发起的源和事件被观察到的目的地之间实现无阻塞、反压力转换。
*   **数据流变量:**其值依赖于给定的输入、操作和其他单元格的变量，当源实体发生变化时自动更新。您可以将数据流变量视为电子表格单元格，其中一个单元格的值的更改会根据分配的公式对其他单元格产生连锁反应。

除此之外，还有各种前端库可用，如 React.js、AngularJS、Ractive.js、Node.js 等，用于开发反应式前端应用。为反应式应用提供本地支持的其他编程语言和框架有 Scala、Clojure 和 GoLang，以及 Java 9 和 Spring 5。我们将在本章后面看到 Spring 5 的反应特性。

# Java 中的反应式编程

异步处理方法非常适合处理大量数据或大量用户。它将使系统响应迅速，并改善整体用户体验。用定制代码在 Java 中实现异步处理会很麻烦，也更难实现。在这种情况下，反应式编程将是有益的。

Java 不像其他基于 JVM 的编程语言(如 Scala 或 Clojure do)那样提供对反应式编程的原生支持。然而，从版本 9 开始，Java 已经开始支持反应式编程。除了 Java 9 中的本地支持之外，还有其他实现层可以帮助实现旧版本 Java(比如 Java 8)的反应式编程。我们将看到其中的一些，如下所示。

# 反应流

反应流被简单地描述为一种为具有非阻塞背压的异步流处理提供标准的倡议。这是一个简单明了的陈述。然而，需要注意的是，这里首先关注的是异步流处理，而不仅仅是异步编程。如前所述，异步系统已经存在很长时间了。

在处理流之前，接收流数据。异步地，这将意味着管理流世界中的不确定性风险。例如，还能有多少数据或消息？另一个挑战可能是如何知道流何时完成发送数据。可能会有很多问题，我们一会儿就会看到所有的问题。

Reactive Streams 用于在 Java 中执行反应式编程。它是一个 API 规范，或者说，是由 Pivotal、网飞、Red Hat、Twitter、Lightbend(以前称为 Typesafe)、Kaazing、Oracle 等许多公司合作提供的底层合同。你可以认为反应流 API 就像 JPA 或 JDBC。实际的实现由不同的供应商提供。

例如，JPA 规范有不同的供应商，如 Hibernate、TopLink、Apache OpenJPA，它们提供实际的实现。类似地，有许多流行的基于 JVM 的库支持反应式编程，如 Reactor、Akka stream、Ratpack、Vert.x 等等。它们都提供了反应流规范的实现，带来了可互换性。

# 反应流规格

让我们更详细地了解一下，反应流的规范是什么。它处理流的异步处理。让我们看看在[https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm)提供的规格。它包括以下两个部分:

*   **API** :描述规范。
*   **技术兼容性套件** ( **TCK** ):这是一个标准或标准测试套件，用于实现的符合性测试。简而言之，它将确保给定的实现符合声明的规范。

仔细观察 API，我们发现它相当简单，仅包含如下四个接口:

*   **Publisher** :这个接口表示一个实体，它充当无限数量的有序事件或元素的提供者。它将按照订户的要求发布元素。
*   **订户:**它代表来自发布者的事件的消费者。为此，它将订阅出版商。
*   **订阅:**这个接口演示了订阅者向发布者订阅或注册的过程。

*   **处理器:**由发布者和订阅者两者组成。它表示实现两者契约的处理阶段。

Java 9 已经开始提供对反应流的本地支持。这些接口的实现是 Java 9 中 Flow API 的一部分。查看包含反应流的 JAR 的结构，我们发现以下结构:

![](assets/946a8436-aacd-43e4-9a11-d8b1498daa00.png)

这看起来相当简单，对于任何 Java 开发人员来说，实现一组接口应该不是一个挑战。我们能够将这些接口的实现投入生产吗？它会给我们一个稳定的系统吗？我们准备好开始反应式开发了吗？答案是，*还没有*。

以异步方式传递消息是反应式流关注的关键领域。它确保不仅仅是消费者受到保护，不会被所有的分布式系统淹没。在一个或多个订阅者处理消息缓慢的情况下，发布者也受到保护。它主要说这是你应该以一种受保护的方式将消息从线程 *A* 传递到线程 *B* 的方式，以确保发布者和订阅者都受到保护。

让我们更深入地研究一下规范，(稍后我们将会谈到 TCK)，看看它们是如何与 Reactive Streams 宣言的最初陈述相一致的。从发布者开始，我们看到规范还定义了一组规则，规范的实现者必须遵守这些规则。

这些规则是为所有四个接口定义的:发布者、订阅者、订阅者和处理者。这里不可能介绍所有的规则，也不是必需的，因为这些规则可以从以下网址获得:[https://github . com/reactive-streams/reactive-streams-JVM/blob/v 1 . 0 . 2/readme . MD](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md)。

然而，为了从反应流宣言中得出一些相关性，让我们看看一些重要的规则。我们将分析所有四个接口中的一个或两个规则，以帮助您理解它们是如何布局的。在阅读这些规则和规范之前，请务必查看术语表。

你应该看看其余的规则，因为浏览它们会让你很好地了解这些规则有多详细。当您阅读完所有的规则时，您将会很好地理解从反应式流的实现中可以期待什么。

# 发布者规则

`Publisher`有如下接口定义:

```
  public static interface Publisher<T> { 
       public void subscribe(Subscriber<? super T> subscriber); 
  }
```

规则编号 1.1 规定，由`Publisher`向`Subscriber`发送的`onNext` 的总数必须小于或等于该`Subscriber` 订阅在任何时候请求的元素总数*。这个定义有多个方面。让我们试着逐一分析:*

*   首先，必须有从`Subscriber`(总数→ 1 - N)到`Publisher`的消息请求。因此，`Publisher` 不能自己开始向不知情的订户发送消息，因为这些订户可能仍在决定何时开始接收消息。此外，有些人可能仍在执行一些初始任务，以便开始接收消息。
*   其次，只有在`Publisher`收到请求后，它才能开始向`Subscriber`发送消息。作为对来自`Publisher`的消息请求的响应，订户接收`Subscription`。现在`Subscriber` 可以使用`Subscription`与`Publisher`交互，反之亦然。`Subscription`中提到了`Publisher`应该发送多少条消息，因此`Subscribers`请求的消息应该小于或等于该数字`[message count <= total number]`。
*   第三，`Publisher`不能向`Subscriber`发送比`Subscriber`所请求的更多的消息。

这三点共同构成了我们从反应流开始时提到的背压的一部分。

是的，`Subscriber`从`Publisher`请求的计数根据另一条规则对`Publisher`没有约束力，与消息的计数无关。`Publisher`被允许从`Subscriber`发送少于请求数量的消息。这可以用下面的内容来描述。

# 订户规则

`Subscriber`有如下接口定义:

```
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

规则编号 2.1 说，`Subscriber`必须通过 Subscription.request(long n)发出需求信号才能接收`onNext`信号。该规则符合`Publisher`规则 1.1，因为它确定了`Subscriber`的责任，通知它何时能够并愿意接收多少消息。

规则编号 2.4 规定，`.onComplete()`和`Subscriber.onError(Throwable t)`在收到信号*后，必须考虑取消`Subscription`。*这里再次强调了设计意图。发送的设计顺序确保消息从`Publisher`发送到`Subscriber`的过程是完全解耦的。因此，`Publisher`不受`Subscriber`保持监听意图的约束，从而确保了非阻塞安排。

一旦`Publisher`发出消息，它就没有消息要与`Subscriber.onComplete()`一起发送，并且`Subscription`对象不再有效/可用。这类似于用`Subscriber.onError(Throwable t)` *抛出异常时。*对象`Subscription`不能再被`Subscriber`用来请求更多的消息。

值得一提的是围绕同一设计的另外几条规则。这些是关于`Subscription.request(long n)`的规则编号 2.9 和 2.10。该规则规定`Subscriber`可以得到`onError`信号或`onComplete`信号，不管是否有对`Subscription.request(long n)`的在先呼叫。

# 订阅规则

以下界面描述了`Subscription`符号:

```
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

规则编号 3.2 说，`Subscription`必须允许`Subscriber`从`onNext`或`onSubscribe` *内部同步调用`Subscription.request`。*仅当`Publisher`从`Subscriber`获得进一步请求的信号时，通过限制发布消息来防止`Publisher`和`Subscriber`。这以同步方式发生，以避免堆栈溢出。

在类似的上下文中，另一个规则 3.3 规定，`Subscription.request()`必须对`Publisher`和`Subscriber`之间可能的同步递归设置一个上限。它通过以`onNext()`和`request()`调用的形式决定`Publisher`和`Subscriber`之间递归交互的上限，在某种意义上补充了规则 3.2。设置上限将避免在调用线程堆栈时溢出。从编号 3.5 到 3.15 的规则描述了取消和完成请求的行为。

# 处理器规则

`Processor`用以下接口定义描述:

```
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

它只有两条规则。第一个规则讨论了`Subscriber`和`Publisher`都必须遵守的契约，而第二个规则旨在处理错误情况，或者恢复或者传播到`Subscriber`。

# 活性流 TCK

实现 Reactive Streams 规范中定义的接口不仅仅是构建 Reactive Streams。该规范包括一组组件和规则。组件部分由我们讨论过的四个接口负责，而规则由反应流**技术兼容性工具包** ( **TCK** 定义。

反应流 TCK 是反应流实现者根据规范中定义的规则验证其实现的指南。TCK 是用一个名为 **TestNG** 的 Java 测试框架开发的，可以用于其他基于 JVM 的编程语言，比如 Kotlin 和 Scala。

TCK 涵盖了规范中定义的大部分规则，但不是全部，因为对于一些规则，不可能构建自动化测试用例。所以从理论上讲，不能完全对照规范进行验证；然而，验证大多数重要的规则是有帮助的。

TCK 由四个 TestNG 测试类组成，包含测试用例，可由实现者扩展，并提供其`Publisher`、`Subscriber`、`Subscription`和`Processor`的实现，以对照规范规则进行验证。你可以从链接得到更详细的信息:[https://github . com/reactive-streams/reactive-streams-JVM/tree/master/tck](https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck)。

# RxJava

从版本 8 开始，Java 开始支持反应特性作为内置功能，但是它们没有被广泛使用，也没有在开发人员中流行起来。然而，一些第三方用 Java 实现的反应式编程显示了它的优势，并且它在 Java 社区越来越受欢迎。

除了一套叫做**反应式扩展**(或简称为 ReactiveX)的工具之外，没有任何东西允许实现反应式编程，以使用可观察序列来编写异步和基于事件的程序。它是反应式扩展的 Java VM(虚拟机)实现。Reactive Extension 最初是在微软平台上编写的，它为各种其他编程语言提供了反应能力，其中最流行的一种是 Java 编程语言 RxJava。

它是第一个专门针对 Java 平台*的反应式扩展 API。* RxJava 兼容旧版本的 Java，提供了为 Java 和 Android 平台编写异步的、基于事件的程序的工具，非常方便。ReactiveX 还涵盖了其他具有反应式扩展的编程语言，如 RxJs、Rx.Net、UnixRx、RxScala、RxCloujure、RxCPP、Rx.rb 和 RxKotlin，以及其他平台和框架，如 rxc 可可、RxAndroid 和 RxNetty。

# RxJava 剖析

RxJava 基本上扩展了 observer 模式，以支持事件/数据序列的迭代，并允许在抽象出底层细节(如线程、同步、并发和线程安全)的同时形成序列。

在撰写本文时，RxJava-2.6 的当前版本只依赖于 Reactive Streams API，并支持 Java 6 和更高版本，以及 Android 2.3+。在深入 RxJava 之前，我们先来看看 ReactiveX 的基本构建块，如下所示:

*   它基本上是一个数据流，或者说是一个数据源。它可以只发送一次数据，也可以根据配置以连续的方式定期发送数据。`Observable`可以根据与`Observable`一起使用的操作符发送特定事件的特定数据。简而言之，`Observable`是其他组件的数据提供者。
*   `Observer`:观察者消费`Observable`发出的数据流。为此，他们需要使用`subscribeOn()`方法订阅`Observable`。一个或多个观察者可以订阅`Observable`。当`Observable`发送数据时，所有注册的观察者通过`onNext()`回调方法接收数据。一旦接收到数据，您就可以对其执行任何操作。如果传输过程中出现任何错误，观察者将通过`onError()`回调得到错误数据。
*   `Scheduler` : 用于线程管理，实现 ReactiveX 中的异步编程。他们将指示`Observable`和`Observer`选择特定的线程来执行操作。为此，`Scheduler`分别为`Observer`和`Observable`提供了`observerOn()`和`scheduleOn()`方法。

让我们用一个实际的例子来理解这些概念。我们将在 Eclipse 中创建一个 Maven 项目，设置如下:

![](assets/a177cf08-19f9-42db-af13-7b18e75118aa.png)

我们需要给 RxJava 特定的依赖。目前的版本是 2.2.6。添加依赖项后，`pom.xml`应该如下所示:

```
<project  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>rx-java</groupId>
  <artifactId>simple-rx-java-demo</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>Simple RxJava demo</name>
  <dependencies>
    <dependency>
 <groupId>io.reactivex.rxjava2</groupId>
 <artifactId>rxjava</artifactId>
 <version>2.2.6</version>
 </dependency>
  </dependencies>
</project>
```

使用适当的包创建一个新的 Java 类，并向其中添加以下代码:

```
public class RxJavaBasics {
  public static void main(String[] args) {
    /* Observable */
    Observable<String> adminUsers = 
        Observable.just("Dave", 
                "John", 
                "Nilang", 
                "Komal",
                "David");

    /* Observer in form of lambda expression */
    adminUsers.subscribe(s -> System.out.println(s));
  }
}
```

`adminUsers`实例属于类型`Observable<String>`，它推送五个字符串文字(管理员用户名)，这本质上是一个数据流或数据源。为了简单起见，我们采用了字符串文字，但是`Observable`可以从任何来源推送数据或事件，比如数据库查询结果、社交媒体提要、REST API 响应或任何类似的内容。
`Observable.just()`方法用于发出一组固定的字符串。代码的最后一行描述了`Observer`如何通过`subscribe()`方法订阅`Observable`。它被定义为一个 lambda 表达式，指定如何处理从`Observable`接收的字符串。下图描述了这种关系:

![](assets/cd64d3e2-a436-40b8-bf0c-6115074fbd17.png)

在这段代码中，`Observer`只是打印字符串文字。RxJava 提供了几个可以在`Observable`和`Observer`T6 之间使用的运算符。这些操作符用于转换或操作在它们之间传递的每个推送数据。每个操作员处理来自前一个`Observable`的数据并返回新的`Observable`。让我们使用一个名为`map`的操作符，并将代码更新如下:

```
adminUsers.map(s->s.startsWith("D") ? s:"*******")
                .subscribe(s -> System.out.println(s));
```

在这段代码中，由`adminUsers`可观察对象发出的数据在被发送到`Observer`之前通过一个 map 操作符。这里的`map`操作符提供了一个 lambda 表达式，用于处理从`adminUsers`提交的数据。它基本上打印出以`D`开头的返回字符串，或者简单地返回一个带有星号标记的字符串(`*`)。`map`操作符返回 new `Observable`，new`Observable`返回`map`操作符处理后的数据，最后发送给`Observer`。您将看到如下输出:

![](assets/5d72c518-2035-4803-a37e-fd3542deda26.png)

# 观察者事件调用

到目前为止，我们讨论的是关于如何在 RxJava 中使用`Observable`的非常高级的信息。它基本上通过一系列操作符(如果定义的话)推送(发出)给定类型的项(数据或事件)，直到到达`Observer`。让我们深入了解更多细节，以理解这种交互之间的内在机制，以及 RxJava 如何符合 Reactive Streams 规范。

`Observable`通过以下事件调用与`Observers`交互:

*   `onNext`:这是发送数据/事件的调用，一次一个，直到所有注册的`Observers`。
*   `onComplete`:该事件用于向所有人发出通信完成的信号。
*   `Observers`:它只是表示不再有`onNext`个呼叫发生。
*   `onError`:如果在`onComplete()`调用之前发生任何错误，则使用`onError()`事件将错误从`Observable`通知给`Observers`。`Observable`将停止发送数据，而`Observers`将处理错误。

这些事件被定义为`Observer`类型中的`abstract`方法，我们将在本章后面看到实现类型。首先让我们看看这些事件调用是如何在与以下代码的交互过程中发生的:

```
public class RxJavaCreateDemo {

  public static void main(String[] args) {
    Observable<String> daysOfWeek = Observable.create(
        sourceEmitter -> {
        try {
          sourceEmitter.onNext("Sunday");
          sourceEmitter.onNext("Monday");
          sourceEmitter.onNext("Tuesday");
          sourceEmitter.onNext("Wednesday");
          sourceEmitter.onNext("Thursday");
          sourceEmitter.onNext("Friday");
          sourceEmitter.onNext("Saturday");
          sourceEmitter.onComplete();
         }catch(Exception e) {
            sourceEmitter.onError(e);
         }
      });
    Observable<String> daysInUpperCase= daysOfWeek.map(day->day.toUpperCase())
                                             .filter(day->day.startsWith("S"));
    daysInUpperCase.subscribe(day->System.out.println("Day is -->"+day));
  }
}
```

`Observable.create()`是一个工厂方法，用于创建带有发射器的`Observable`。发射器的`onNext()`方法用于将数据/事件(一次一个)发射(发送)到`Observable`链(最终到达注册的`Observers`)。`onComplete()`方法用于终止进一步的通信。

如果您尝试在`onComplete()`之后拨打`onNext()`电话，数据将不会传输。如果出现任何错误，就会调用`onError()`方法。它用于将错误推送到`Observable`链，由`Observer`处理。在这段代码中，不可能出现任何异常，但是您可以用`onError()`处理任何错误。

我们已经使用了`map`和`filter`操作符将数据细化为大写，并分别从`D`开始。最后由`Observer`打印出来。数据流将从`onNext()` → `map` → `filter` → `Observer`开始。每个操作符将返回链中新的`Observable`类。

您会注意到，在第一个例子中，我们使用了`Observable.just()`方法来发出数据。它在内部为每个推送的值调用`onNext()`方法。在得到最后一个值时，它将调用`onComplete()`。所以`Observable.just()`相当于`Observable.create()`在每个数据上调用`onNext()`，在最后一个数据上调用`onComplete()`。`create()`方法通常用于本质上无反应的源。

# 迭代器的可观察性

`Observable`支持从任何可迭代的数据源发出数据，例如，列表、映射、集合等等。它会在 iterable 类型的每一项上调用`onNext()`，一旦迭代器结束，它会自动调用`onComplete()`。Java 中的 Iterable 常用于集合框架，所以在从集合类中获取数据时可以使用带有 iterable 的`Observable`。

下面我们来看看如何使用:

```
public class RxJavaIterableDemo {
  public static void main(String[] args) {
    List<EmployeeRating> employeeList = new ArrayList<EmployeeRating>();
    EmployeeRating employeeRating1 = new EmployeeRating();
    employeeRating1.setName("Lilly");
    employeeRating1.setRating(6);
    employeeList.add(employeeRating1);

    employeeRating1 = new EmployeeRating();
    employeeRating1.setName("Peter");
    employeeRating1.setRating(5);
    employeeList.add(employeeRating1);

    employeeRating1 = new EmployeeRating();
    employeeRating1.setName("Bhakti");
    employeeRating1.setRating(9);
    employeeList.add(employeeRating1);

    employeeRating1 = new EmployeeRating();
    employeeRating1.setName("Harmi");
    employeeRating1.setRating(9);
    employeeList.add(employeeRating1);

    Observable<EmployeeRating> employeeRatingSource = 
                                Observable.fromIterable(employeeList);

    employeeRatingSource.filter(employeeRating -> 
                employeeRating.getRating() >=7).subscribe(empRating -> 
                System.out.println("Star Employee: " + empRating.getName() 
                + " Rating : "+empRating.getRating()));
  }
}
```

我们正在填充列表`EmployeeRating`并通过传递这个列表用`fromIterable()`方法创建`Observable`。类`EmployeeRating`是一个简单的 POJO，包含如下的`name`和`rating`属性:

```
class EmployeeRating{
  private String name;
  private int rating;
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public int getRating() {
    return rating;
  }
  public void setRating(int rating) {
    this.rating = rating;
  }
}
```

RxJava 通过提供接口的实现符合反应流规范。让我们回忆一下，`onNext()`、`onError()`、`onSubscribe()`和`onComplete()`方法是观察者接口的一部分。RxJava 提供了这些接口的实现来处理各自的事件。

# 自定义观察员

我们已经看到了数据如何从`Observable`发出，通过下游的操作符，最终到达`Observer`。显然，我们可以说数据是从一系列的`Observable`中传递出来的，因为每个操作者都返回新的`Observable`，这就形成了一个`Observable`链。发射源的第一个`Observable`称为`Observable`源。因此，我们可以说`Observable.create()`和`Observable.just()`返回了`Observable`源。

我们可以提供我们的定制实现来处理`Observer`事件，如下所示:

```
public class RxJavaCustomObserverDemo {

  public static void main(String[] args) {

    Observable<String> months =
        Observable.just("January", "February", "March", "April", 
            "May","June","July","August");

    Observer<String> customObserver = new Observer<String>() {
      @Override
      public void onSubscribe(Disposable d) {
        System.out.println(" Subscription initiated ...");
      }
      @Override
      public void onNext(String value) {
        System.out.println("The value " + value +" is received from Observable");
      }
      @Override
      public void onError(Throwable e) {
        e.printStackTrace();
      }
      @Override
      public void onComplete() {
        System.out.println("Done!");
      }
    };

    months.filter(month -> month.endsWith("y"))
            .subscribe(customObserver);
  }
}
```

像前面的例子一样，我们用月份列表定义了`Observable`。我们还定义了 custom `Observers`,它实现了将为特定事件调用的各种方法。当我们注册观察者(在我们的例子中是`customObserver`)时，`Observable`将在`Observer`上调用`onSubscribe()`方法。

每次`Observable`发出数据时，都会调用注册的观察者的`onNext()`，然后由观察者进行处理。在发送最后一个数据时，`Observable`将调用`Observer`上的`onComplete()`方法。如果中间出现错误，`Observable`会调用`Observer`上的`onError()`方法。

当然，数据将通过`Observable`链传递。在前一种情况下，从`Observable`源发出的数据(在这种情况下是`months`)将向下游转发到`filter`操作符，然后到达观察者或端点，在那里消费和处理数据。所谓已处理，我们指的是数据可以保存到数据库，作为服务器响应发送，写入外部文档管理系统，组成 UI 呈现的结构，或者简单地在控制台中打印。

您将获得如下输出:

![](assets/b47c535e-e710-4c86-a677-40b006a98446.png)

在这个例子中，我们使用了一个匿名类来提供 Observer 方法的自定义实现。但是，您可以为此使用 lambda 表达式。

# 可观察类型

在我们在 RxJava 部分前面的小节中看到的例子中，数据是在 Observable 中创建的。然而，在真实的场景中，数据来自其他来源，比如数据库、REST APIs 等等。任何一组数据/值的表示都被称为生产者。根据引用程序的位置，可观察性大致分为以下两类。

# 冷观察到的

当`Observable`自己创建过程，或者说`Observable`自己产生数据流时，它被称为冷`Observable`。一般来说，`Observable`本质上是懒惰的，这意味着它只在任何`Observer`订阅它时才发出数据。Cold `Observable`总是为每个订阅者启动一个新的执行。

换句话说，cold `Observable`为各个观察者发出单独的数据/事件流。到目前为止，我们看到的所有例子都是冷的`Observable`类型，我们用`just()`或`create()`方法创建了一个数据流。通过下面的例子，让我们看看`Observable`对于多个订阅的观察者是如何工作的。

```
public class RxJavaColdObservable {
  public static void main(String[] args) {
    Observable<String> source =
        Observable.just("One","Two","Three","Four","Five");
    //first observer
    source.filter(data->data.contains("o"))
       .subscribe(data -> System.out.println("Observer 1 Received:" + data));
    //second observer
    source.subscribe(data -> System.out.println("Observer 2 Received:" + data));
  }
}
```

在这段代码中，数据是由`Observable`自己创建的，所以它被称为**冷可观测的**。我们已经预订了两个不同的观察员。当您运行此代码时，您将得到如下输出:

![](assets/e87f0f89-91c7-4f0c-9e0b-6b8fc87e0818.png)

Cold `Observable`为每个`Observer`提供单独的数据流，因此当我们对第一个`Observer`应用过滤器时，对第二个`Observer`没有影响。同样，如果有一个以上的`Observer`，那么`Observable`将向所有观察者逐一发送数据序列。

# 热可观察

另一方面，Hot `Observable`让生产者在它之外创建或激活。Hot `Observable`发出由所有观察者共享的流。让我们看看这个例子，如下所示:

```
public class RxJavaHotObservable1 {
  public static void main(String args[]) {
    Observable<Long> observableInterval = Observable.interval(2, TimeUnit.SECONDS);
    PublishSubject<Long> publishSubject = PublishSubject.create();
    observableInterval.subscribe(publishSubject);
    publishSubject.subscribe(i -> System.out.println("Observable #1 : "+i));
    addDelay(4000);
    publishSubject.subscribe(i -> System.out.println("Observable #2 : "+i));
    addDelay(10000); 
  }
  private static void addDelay(int miliseconds) {
    try {
            Thread.sleep(miliseconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
  }
}
```

在这个例子中,`observableInterval` observable 发出事件而不是数据。`interval`方法用于以给定的时间间隔发出序列号。我们已经使用`PublishSubject`使其成为一个可观察的热点类型。它可以表现为`Observable`或`Observer`。在这种情况下，它是`Observable`链的一部分。然后，我们简单地向`PublishSubject`添加两个订户，中间有一些延迟。您将获得如下输出:

![](assets/a217de70-15dd-4b7d-b788-333717a26b7d.png)

第二个`Observer`在一些延迟之后被订阅到第一个`Observer`。`Observable`每两秒钟发出一次序列号。第二个`Observer`从第四秒开始。Hot `Observable`只发射一个单独的流，由所有`Observers`共享。因此，在第二个`Observer`的情况下，实际值从`2`而不是`0`开始，因为它在一段时间后订阅。

从这个意义上来说，hot `Observable`可以比作订阅一个电台。开始收听的人将无法听到他订阅之前播放的内容，因为这对于所有订阅者(或者用反应性语言说观察者)来说是常见的。还有其他方法来制造热`Observable`。我们将看到其中一个如下:

```
public class RxJavaHotObservable2 {
  public static void main(String args[]) {
    Observable<Long> observableInt = Observable.interval(2, TimeUnit.SECONDS);
    ConnectableObservable<Long> connectableIntObservable = observableInt.publish();
    connectableIntObservable.subscribe(i -> System.out.println("Observable #1 : "+i));
    connectableIntObservable.connect();
    addDelay(7000);
    connectableIntObservable.
       subscribe(i -> System.out.println("Observable #2 : "+i));
    addDelay(10000);
  }

  private static void addDelay(int miliseconds) {
    try {
            Thread.sleep(miliseconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
  }
}
```

在这段代码中，用`ConnectableObservable`创建热可观察对象。直到对它调用了`connect`方法，它才会开始发送数据，这使得它更容易控制。在`connect`方法被调用后不久，它将启动一个单独的流，在观察者之间共享。您将获得如下输出:

![](assets/94131b24-bdd1-43f9-8bcd-2faec6bfba0f.png)

您可以看到第二个观察者错过了前几个条目，因为它的订阅有一些延迟。你可以通过调用上面的`publish`方法将任何冷可观察转换成`ConnectableObservable`。

# 获得可观察性的其他方法

到目前为止，我们已经看到了如何用`just()`、`create()`和`interval()`得到`Observable`。然而，还有其他来源得到了`Observable`。您可以从以下网址获得每个来源的详细信息:[https://github . com/react vex/rx Java/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables):

1.  `range`:如果想发出一个连续的整数范围，可以使用`Observable.range(int from, int to)`调用。顾名思义，它将从起始值开始以递增的方式发出一个数字，直到达到结束计数。
2.  `empty`:在极少数情况下，你需要创建一个不发光的`Observable`，并调用`onComplete()`。在这种情况下，您可以通过`Observable.empty()`调用使用这个源类型。
3.  `never`:相当于`empty`，不同的是它永远不会调用`onComplete()`，保持`Observable`等待发射状态。这也是不常用的。
4.  `error`:如果你想创建一个能立即调用`onError()`的`Observable`，你可以使用这个资源调用`Observable.error()`。它主要用于测试目的。
5.  很久以前它就被引入，并被用作尚未产生的结果的占位符。`Observable`比`future`更强大，但是如果你正在使用旧的库，你可以通过`Observable.future()`调用将`Observable`转换为`future`。
6.  `defer`:这基本上是用来为每个`Observer`创建一个单独的状态。当流的源是有状态的时，这是有用的。如果您希望您的观察者反映出发生在`Observable`状态的变化，那么您可以通过`Observable.defer()`调用来使用这个源类型。
7.  `single`:这种类型的`Observable`只发出一个值，可以和`Single.just()`方法调用一起使用。
8.  `maybe`:类似于`single`型，唯一的区别是它最多发射零个或一个数据，可以用于`Maybe.just()`呼叫。
9.  `fromCallable`:如果您想在发出数据之前执行某些计算动作，您可以通过一个`Observable.fromCallable()`调用来使用这个数据源。如果发生任何错误，并且您想通过一个`onError()`调用将它传递给`Observable`链，而不是抛出错误，那么您可以使用这个源类型。

# 经营者

在前面的例子中，我们已经看到了像 map 和 filter 这样的操作符。它们基本上用于对数据流执行特定的操作，并返回新的`Observable`以形成一个`Observable`链。操作员本身是他们被召唤的`Observable`的`Observers`。

RxJava 有一组丰富的操作符，用于执行以下类别的各种操作:

*   **创建可观测量:**用来创建新`Observable`的一组操作符。
*   **转换可观测量:**操作者用来转换他们所调用的可观测量发出的项目。
*   **过滤可观察:**用于发射选择性数据的算子。
*   **组合可观测量:**用于将多个源可观测量组合成一个`Observable`。
*   **错误处理:**用于从`Observable`通知的错误状态中恢复的操作符。
*   **实用运算符:**用来与`Observable`一起执行一些杂项操作。
*   **条件和布尔运算符:**用于计算一个或多个`Observable`甚至发射的项目。
*   **数学和聚合:**用于对整个发射数据序列执行各种操作的运算符。

最好访问:【http://reactivex.io/documentation/operators.html】[以获得关于每个运营商的全部细节，而不是在这里列出细节。](http://reactivex.io/documentation/operators.html)

# 项目反应堆

该反应器可以被称为 JDK 顶部的反应库。Java 本身不支持反应式编程，Reactor 是众多库中的一个。Reactor 来自开源集团 Pivotal，符合 Reactive Streams 标准。它是基于 Java 8 和 ReactiveX 词汇表构建的。

这里值得注意的是，尽管异步似乎是反应式编程的一个重要属性，但 Reactor 并不强迫您去异步/同步，因为它支持两者。这取决于选择的调度程序。这是你的选择。为了更好地理解反应器，我们需要更详细地理解反应流。

# 反应器特征

Reactor 提供基于事件的体系结构，用于并发和异步处理大量请求，从而形成一个无阻塞和反压的系统。使用 Project Reactor，您不需要自己实现反应流，因为它提供了一组嵌入的和可互操作的模块。它提供了以下令人惊叹的功能:

# 处理高容量数据流

Project Reactor 能够为特定的数据基数提供 API 支持，范围从生成无穷无尽的数据流到发布单个数据条目。

Project Reactor 使订阅者能够在数据流的元素到达时处理它们，而不是等待整个数据流被处理。通过提高资源利用率，这使得数据处理操作更加灵活和优化。需要分配给订户的存储器是有限的，因为数据处理发生在特定时间到达的项目的子集，而不是一次性处理整个数据流。此外，这使得系统响应更快，因为结果将在接收到第一组元素时立即开始，而不是等到所有项目都被接收和处理后才提供最终输出。

# 推拉机构

Project Reactor 为证明推/拉特性提供了很好的帮助。在实际场景中，消费者获取数据的速度比生产者发布数据的速度慢。在这种情况下，生成器将引发该事件，并等待观察者将其拉出。在某些情况下，消费者比生产者工作得更快。为了处理它，消费者等待从生产者端推送的事件。项目反应堆使这种流动在任何必要的时候都是动态的。它将受到生产和消费速度的控制。

# 独立处理并发

reactor 执行范例能够独立处理并发性，这真正使它成为并发不可知的。Reactor 库以更抽象的方式处理数据流，而不是谈论如何执行不同类型的流。在各种操作中发生的事务都是安全的。Reactor 提供了一组操作符，它们以不同的方式处理不同的同步流。

# 经营者

Reactor 提供了一组操作符，通过以不同的方式处理不同的同步流，这些操作符在执行模型中起着至关重要的作用。这些运算符可用于过滤、映射、选择、转换和组合数据流。它们可以与其他操作符结合，构建高级、易于操作、高度定制的数据管道，以您想要的方式处理流。

# 反应堆子项目

Project reactor 由以下各种子项目组成:

*   这个项目提供了反应流规范的实现。Spring Framework 5.0 以 Reactor Core 子项目为基础，提供了对反应式编程的支持。
*   **反应堆测试:**包含测试验证的必要工具。
*   **Reactor Extra:** 在反应堆堆芯的顶部，这个项目提供了各种操作人员来处理数据流，以执行所需的操作。
*   **反应堆 IPC:** 该项目通过各种网络协议，如 HTTP、TCP、UDP 和 web sockets，提供背压提供的无阻塞进程间通信支持。由于这个性质，这个模块在构建异步微服务架构时也很有帮助。
*   **Reactor Netty:** 用于为开发网络应用的客户端服务器框架 Netty 提供一个反应性的特性。
*   **反应式 Kafka:** 它是一个用于基于 Apache Kakfa 的项目的反应式 API。它用于以非阻塞和功能性的方式与 Kakfa 通信。
*   **Reactive RabbitMQ:** 这个项目用于为 RabbitMQ(一个消息代理系统)配备反应能力。

# 反应器类型

Project Reactor 根据处理的元素数量分为两种核心类型。它们被认为是使用反应器创建反应系统的主要构件。他们是`Flux`和`Mono`。它们都实现了`Publisher<T>`接口，符合反应流规范，并配备了反应拉和反压功能。他们还有其他几种有用的方法。下面我们来探讨一下细节:

*   `Flux`:可以认为相当于 RxJava 的 Observable，可以发出零个或多个项，成功结束或有错误信号。简而言之，它表示具有零个或多个元素的异步事件流。
*   它一次最多只能发射一种元素。它相当于 RxJava 端的`Single`和`Maybe`可观察类型。一个`Mono`类型可以用于一对一的请求-响应模型实现；例如，一个任务希望发送一个完成信号可以使用一个`Mono`型反应堆。

一种反应器类型可以处理的元素数量之间的明显差异提供了有用的语义，并使选择哪种反应器类型变得容易。如果型号是那种*开火然后忘记*的型号，那么选择`Mono`型。如果执行处理流中的多个数据项或元素，那么`Flux`类型更合适。

此外，不同的运营商在决定反应器的类型方面起着至关重要的作用。例如，在`Flux<T>`类型上调用`single()`方法将返回`Mono<T>`，而将`Mono<T>`类型的多个实体与`concatWith()`连接在一起将产生`Flux<T>`类型。反应器类型会影响我们可以使用哪些操作符。例如，一些运算符适用于`Flux`或`Mono`中的一个，而其他运算符可用于两者。

# 运行中的反应堆

让我们通过一个实际的例子来了解更多关于 reactor API 的知识。创建一个新的 Maven 项目，类似于我们在 RxJava 一节中创建的项目。在撰写本文时，Project Reactor 的当前版本是 3.2.6。我们需要为反应器提供一个 Maven 依赖，如下所示:

```
<project 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
             http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>reactor-demo</groupId>
  <artifactId>simple-reactor-demo</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>Smiple Reactor Dmo</name>
  <dependencies>
    <dependency>
 <groupId>io.projectreactor</groupId>
 <artifactId>reactor-core</artifactId>
 <version>3.2.6.RELEASE</version>
 </dependency>
  </dependencies>
</project>
```

当我们定义一个反应器依赖时，反应流 JAR 将被添加为一个可传递的依赖。接下来，是添加一个 Java 类，如下所示:

```
public class ReactorBasic {
  private static List<String> carModels = Arrays.asList(
              "Era","Magna","Sportz","Astha","Astha(O)");
  public static void main(String args[]) {
       Flux<String> fewWords = Flux.just("Hello", "World");
       Flux<String> manyWords = Flux.fromIterable(carModels);
       Mono<String> singleWord = Mono.just("Single value");
       fewWords.subscribe(t->System.out.println(t));
       System.out.println("-----------------------------");
       manyWords.subscribe(System.out::println);
       System.out.println("-----------------------------");
       singleWord.subscribe(System.out::println);
  }
}
```

我们已经使用`Flux`和`Mono`创建了不同的发布者。`just()`方法用于填充流。我们还可以通过`fromIterable()`方法到达可迭代类型(如`List`、`Set`、`n`)以形成数据流。其他一些方法，如`from()`、`fromArray()`和`fromStream()`分别用于从其他生成器、数组和现有的 Java 流中构造数据流，可以如下使用:

```
public class ReactorFromOtherPublisher {
  public static void main(String[] args) {
    Flux<String> fewWords = Flux.just("One","Two");
    /* from array */
    Flux<Integer> intFlux = Flux.fromArray(new Integer[]{1,2,3,4,5,6,7});
    /* from Java 8 stream */
    Flux<String> strFlux = Flux.fromStream(Stream.of(
      "Ten", "Hundred", "Thousand", "Ten Thousands", "Lac","Ten Lac", "Crore"));
    /* from other Publisher */
    Flux<String> fromOtherPublisherFlux = Flux.from(fewWords);
    intFlux.subscribe(System.out::println);
    strFlux.subscribe(System.out::println);
    fromOtherPublisherFlux.subscribe(System.out::println);
  }
}
```

可以用`subscribe()`方法插入订户。这类似于我们在 RxJava 中对 Observable 所做的。使用`Flux`，我们可以创建一个有限或无限流的发布者。

我们还可以控制生成一个带值的流或者只是一个空流。所有这些都可以通过`Flux`类提供的一些实用方法来完成，如下所示:

*   `Flux.empty()`:用于生成一个没有值的空流，只执行完成事件。
*   `Flux.error()`:用于通过生成一个没有任何值只有错误的错误流来表示错误情况。
*   顾名思义，它生成一个没有任何类型事件的流。
*   `Flux.defer()`:当订阅者订阅`Flux`时，用于构造发布者。简而言之，就是天性懒惰。

# 订户类型

`Flux`和`Mono`类都允许 Java 8 lambda 表达式作为订阅者。它们还支持各种重载版本的`subscribe()`方法，如下所示。

```
public class ReactorWithSubscriberWays {

  public static void main(String[] args) {
    List<String> monthList = Arrays.asList(
            "January","February","March","April","May");

    Flux<String> months = Flux.fromIterable(monthList);
/* 1) No events is consumed. */
    months.subscribe();
/* 2) Only value event is consumed */
    months.subscribe(month->System.out.println("->"+month));

/* 3) Value and Error (total 2) events are handled */
    months.subscribe(month->System.out.println("-->"+month),
              e->e.printStackTrace());

/* 4) Value, Error and Completion (total 3) events are subscribed */
    months.subscribe(month->System.out.println("--->"+month),
                    e->e.printStackTrace(),
            ()->System.out.println("Finished at THIRD PLACE.. !!"));

/* 5) Value, Error, Completion and Subscription (total 4) events are subscribed */
    months.subscribe(month->System.out.println("---->"+month),
                                       e->e.printStackTrace(),
      ()->System.out.println("Finished at FOURTH PLACE ..!!"),
             s -> {System.out.println("Subscribed :");
                   s.request(5L);});
  }
}
```

用字符串列表创建了`Flux`类。使用`subscribe()`方法有五种不同的变体，每种都有捕捉各种事件的规定。详细情况如下:

*   第一个版本不消耗任何事件。
*   第二个变体使用值事件，它是用 lambda 表达式定义的。
*   第三个`subscribe()`方法将错误事件作为第二个参数与值事件一起监听。我们只是通过 lambda 表达式打印堆栈跟踪。
*   第四个使用值、错误和完成事件。在数据流完成时，将执行完成事件，我们用 lambda 表达式监听它。
*   第五个版本使用值、错误、完成和订阅事件。`Subscription`类型的最后一个参数使得这个版本的`subscribe()`成为一个特例。`Subscription`类型有一个叫做`request()`的方法。发布者不会发送任何事件，除非订阅者通过`Subscription.request()`调用发送需求信号。这仅适用于为用户定义了`Subscription`的情况。我们必须像`s.request(5L)`一样进行方法调用，这意味着发布者只能发送五个元素。它小于 publisher 中的总值，并引发一个完成事件。在我们的例子中，数据流中的元素总数是 5，因此它将调用一个完成事件。如果传递的次数少于五次，将不会收到完成事件调用。

# 自定义订户

在某个场景中，在`Publisher`上调用`Subscribe`方法是不合适的，您可能想要编写自己处理的自定义订阅者。Reactor framework 通过扩展`reactor.core.publisher.BaseSubscriber<T>`抽象类为定义定制订阅者提供支持。您不需要直接实现 Reactive Streams 规范的`Subscribe`接口。相反，您只需要扩展该类来应用自定义实现，如下所示:

```
static class CustomSubscriber extends BaseSubscriber<String>{
  @Override
  protected void hookOnSubscribe(Subscription subscription) {
  System.out.println("Fetching the values ...!!");
  subscription.request(10);
 }
  @Override
  protected void hookOnNext(String value) {
  System.out.println("Fetchig next value in hookOnNext()-->"+value);
 }
  @Override
  protected void hookOnComplete() { 
  System.out.println("Congratulation, Everything is completed successfully ..!!");
 }
  @Override
  protected void hookOnError(Throwable throwable) {
  System.out.println("Opps, Something went wrong ..!! "+throwable.getMessage());
 }
  @Override
  protected void hookOnCancel() {
  System.out.println("Oh !!, Operation has been cancelled ..!! ");
 }
  @Override
  protected void hookFinally(SignalType type) {
  System.out.println("Shutting down the operation, Bye ..!! "+type.name());
 }
}
```

`BaseSubscriber`类提供了各种钩子方法，代表相应的事件。它是一个占位符，用于提供自定义实现。实现这些方法类似于使用各种版本的`subscribe()`方法，我们已经在*类型的订阅者*部分看到过。例如，如果你只实现了`hookOnNext`、`hookOnError`、`hookOnComplete`方法，那么它就相当于第四版的`subscribe()`。

`hookOnSubscribe()`方法有助于订阅事件。背压由`subscription.request()`提供。您可以请求任意多元素。例如，更新`hookOnSubscribe()`方法的代码，如下所示:

```
 @Override
     protected void hookOnSubscribe(Subscription subscription) {
       System.out.println("Fetching the values ...!!");
       for(int index=0; index<6;index++) {
         try {
          Thread.sleep(1000);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
         subscription.request(1);
       }
     }
```

我们通过循环调用`subscription.request(1)`来逐个请求记录。为了了解它是如何工作的，我们在两者之间放置了两秒钟的延迟，这样您将会得到每两个请求的记录。一旦所有数据都完成了，就会触发完成事件，调用`hookOnComplete()`方法。输出如下所示:

![](assets/82109b35-b274-45f0-a097-21e7a1dee3bb.png)

# 反应堆生命周期方法

Reactor 提供了生命周期方法来捕获发布者-订阅者通信中发生的各种事件。那些生命周期方法与反应流规范相一致。Reactor 生命周期方法可用于挂钩给定事件的定制实现。让我们通过下面的代码来理解它是如何工作的:

```
public class ReactorLifecycleMethods {

  public static void main(String[] args) {
    List<String> designationList = Arrays.asList(
        "Jr Consultant","Associate Consultant","Consultant",
        "Sr Consultant","Principal Consultant");
    Flux<String> designationFlux = Flux.fromIterable(designationList);

    designationFlux.doOnComplete(
        () -> System.out.println("Operation Completed ..!!"))
    .doOnNext(
        value -> System.out.println("value in onNext() ->"+value))
    .doOnSubscribe(subscription -> {
      System.out.println("Fetching the values ...!!");
      for(int index=0; index<6;index++) {
          try {
            Thread.sleep(1000);
          } catch (InterruptedException e) {
          e.printStackTrace();
          }
          subscription.request(1);
        }
      })
    .doOnError(
        throwable-> {
          System.out.println("Opps, Something went wrong ..!! "
              +throwable.getMessage());
        })
    .doFinally(
        (signalType->
          System.out.println("Shutting down the operation, Bye ..!! "
          +signalType.name())))
    .subscribe();
  }
```

我们用列表中的数据创建`Flux`对象，然后调用各种生命周期方法，比如链中的`doOnComplete()`、`doOnNext()`、`doOnSubscribe()`、`doOnError()`和`doOnTerminate()`。最后，我们调用`subscribe()`方法，它不消耗事件，但是所有的生命周期方法将在适当的事件被触发时被执行。

这类似于*自定义订户*部分中的自定义订户实现。您将看到类似的输出。这些生命周期方法的详细信息如下:

*   `doOnComplete()`:一旦`Subscriber`收到所有的数据，这个方法就会被调用。
*   `doOnNext()`:该方法将监听来自生产者的值事件。
*   `doOnSubscribe()`:用于塞住`Subscription`。它可以通过定义一个`subscription.request()`调用还需要多少元素来控制背压。
*   `doOnError()`:如果出现错误，将执行该方法。
*   `doOnTerminate()`:一旦操作完成，无论成功或出错，都将调用该方法。在手动取消事件中不会考虑它。
*   `doOnEach()`:顾名思义，流处理过程中引发的所有`Publisher`事件都会调用它。
*   `doFinally()`:这将在由于错误、取消或事件成功完成而导致流关闭时调用。

# 鼠笼

Ratpack 是一组 Java 库，它们是事件驱动的、非阻塞的、高性能的，并且本质上是异步的，用于通过 HTTP 构建可伸缩的服务。它符合 Reactive Streams 规范，这意味着它具有开箱即用的互操作性。它构建于 Netty 之上，Netty 是一个通过网络构建客户机-服务器应用的框架，开发起来既快速又简单。

它是一个 web 框架，用于开发高效、轻量级的基于 JVM 的应用。它有自己的测试库，可以轻松设置测试用例。Spring 为 Ratpack 提供支持。可以从 Ratpack 的官方网站获取更多关于 ratpack 的信息: [https://ratpack.io](https://ratpack.io) 。

# 阿卡河

Akka stream 在 Akka toolkit 的基础上提供了一个反应式流规范的实现，它使用 Actor 模式作为并发执行模型。它使用 Actor 以非阻塞的反压力方式异步处理数据流。除了 Java，Akka 还可以很好地与 Scala 语言兼容。点击链接[https://akka.io/docs](https://akka.io/docs)了解更多关于阿卡河的信息。

# 垂直 x

Vert.x 是 Eclipse Foundation 项目提供的另一个工具包，用于构建基于 JVM 的反应式系统。它还提供了类似于 Ratpack 的反应流规范的实现。Vert.x 支持并允许使用 RxJava 构建反应式系统。不用说，Vert.x 是基于事件的，本质上是非阻塞的。它支持各种编程语言，比如 Java、JavaScript、Ruby、Groovy、Ceylon、Scala、Kotlin 等等。可以在: [https://vertx.io](https://vertx.io) 了解更多。

# Spring 框架中的反应式支持

Spring 是一个模块化框架，用于构建从 web 到持久层的应用的各个方面。每个模块都被认为是一个子框架，针对一个特定的发展领域。例如，为了用 servlet API 支持 web 层，Spring 框架中包含了 Spring MVC 模块。

类似地，为了支持 web 层中的反应式堆栈，Spring Framework 5 中引入了 Spring WebFlux。它是完全无阻塞、反压、异步的，并且符合反应流规范。它可以在 Servlet 3.1+，Netty 和 Undertow 容器上运行。

Spring Framework 同时拥有 Spring Web MVC 和 spring-WebFlux 两个栈，开发者可以自由使用其中任何一个，或者在某些场景下混合使用两者来开发基于 Spring 的 Web 应用。典型的例子是使用 spring MVC 控制器和反应式 WebClient 我们将在本章的后半部分详细讨论这一点。

# Spring网流量

Spring 5 令人印象深刻地支持用 Spring WebFlux 创建一个反应式系统。它是一个新的反应式 web 应用框架，基于 Project Reactor API 开发，也可用于构建微服务。使任何应用具有反应性的最显著和最直接的好处是给它带来了异步特性。

非反应式和传统的基于 Java 的应用使用线程机制进行异步和并行编程。然而，线程的使用无论如何都是不胜任和不可扩展的。另一方面，Spring WebFlux 鼓励基于事件循环的编程，这种方式是异步和非阻塞的。本节将在 Spring 框架和反应式编程的背景下介绍 WebFlux。

# Spring MVC 与 Spring WebFlux

从第 2 版开始，Spring MVC 就是 Spring 框架的一部分，从那以后，在使用 Spring 框架开发基于 web 的应用时，它已经成为事实上的标准。为了支持反应式编程，Spring 引入了 WebFlux 模块。因此，了解 Spring MVC 和 Spring WebFlux 的异同很重要。

Spring 团队已经艰难地做到了这一点，并保持了与 Spring MVC 相似的 WebFlux 语法，但在底层它拥有全新的技术。这两个模块之间的主要区别之一是它们处理请求的机制。Spring MVC 基于一个纯 servlet API，使用线程池。这意味着，每个请求都有一个从控制器到持久层的线程，并且可能会因为需要资源而被阻塞。

然而，Spring WebFlux 基于反应式架构，并与事件循环机制一起工作，提供开箱即用的非阻塞支持。在事件循环机制中，所有事情都是作为对事件的反应而发生的。它类似于回调函数；当任何事件发生时，回调函数被触发。Node.js 引入了事件循环这个概念。

在内部，WebFlux 需要 servlet API 支持，它作为一个适配器层工作，以便 WebFlux 可以部署在 servlet 和非 servlet 容器上。Spring MVC 构建在 servlet API 之上，本质上是同步的(像 Filter、servlet 等等),并且还执行阻塞 IO 流。

另一方面，WebFlux 是在异步 API (WebHandler、WebFilter 等)和非阻塞 IO 机制(如`Flux`和`Mono`)上开发的，这些机制分别用于处理最多一个值和多个元素的流。尽管 Spring WebFlux 是基于 reactor 的，并且默认使用，但它也支持其他反应式实现，如 Java 9 Flow API、RxJava 和 Akka stream。

然而，这两个框架都支持一些共同的特性，比如使用一些注释(比如`@Controller`和`@RequestMapping`)以及对一些知名服务器的支持。

我们在用 WebFlux 讨论 String 中的反应式编程支持；这并不意味着 Spring MVC 没有用。这两个框架都解决了应用的不同问题。像任何框架一样，WebFlux 可能不是所有应用类型的最佳选择。

因此，您需要根据需求来选择框架，而不是根据它的特性来选择框架。如果现有的 Spring MVC 应用运行良好，完全没有必要将它移植到 WebFlux 上。WebFlux 的优秀之处在于，它可以毫无问题地与 Spring MVC 结合使用(如果明确需要的话)。

除此之外，如果您现有的 Spring MVC 应用依赖于其他本质上是同步和阻塞的部分，那么调整 WebFlux 特定的更改将会阻碍充分利用 reactive 范型的好处。但是，如果您的应用主要处理数据流，您可以选择 WebFlux。如果可伸缩性和性能是您正在寻找的，那么您可以在您的应用中使用 WebFlux 特定的更改。

# Spring模块的反作用跨度

通过引入反应式 web 框架 WebFlux，Spring 还在其他模块上做了必要的改动，为 WebFlux 提供一流的支持。Spring Boot、Spring Security、百里香和 Spring Data 是少数几个配备了 WebFlux 功能的模块。这可以用下图来描述:

![](assets/7676979f-25e9-46da-aceb-6a29a9fef044.png)

Spring Data 采用了一种反应式范式，并开始支持来自带有`@Tailable`注释的数据库的无限流。Spring Data JPA 主要与 RDBMS 相关联，RDBMS 本质上是阻塞的，因此它不能支持反应式编程。

Spring MVC 本质上是天生的阻塞；但是，我们可以对某些部分使用反应式编程，这些部分可以转换为反应式。例如，Spring MVC 控制器可以配备`Flux`和`Mono`类型，以反应方式处理数据流。

除此之外，WebFlux 还支持一些注释，比如`@Controller`、`@RequestMapping`等等，这样你就可以用增量的方式将 Spring MVC 应用转换成 WebFlux。我们将通过创建一个示例应用，通过 WebFlux 看到更多关于 Spring 框架中反应式支持的细节。

# Spring WebFlux 应用

我们将使用 WebFlux 框架创建一个示例 web 应用。该应用将简单地从数据存储中访问现有的学生信息。我们不会开发一个完全成熟的应用，而是将重点放在如何使用 WebFlux 框架以一种反应式的方式访问数据。

我们将利用 Spring Boot 来启动开发。对于那些不熟悉 Spring Boot 的人来说，它是 Spring Horizon 的一个工具和一部分，Spring Horizon 旨在加速和简化新的基于 Spring 的应用的引导和开发。

在 Spring 项目中，您可能会反复遇到庞大的 XML 和其他配置。Spring 团队很好地意识到了这一点，并最终开发了一个名为 Spring Boot 的工具，旨在将开发人员从提供样板配置中解放出来，这不仅乏味而且耗时。

我们将使用 MongoDB 作为数据存储创建一个示例 web 应用。在使用反应式编程时，建议使用非阻塞和反应式数据存储，如 MongoDB、Couchbase、Cassandra 等。我们将使用一个名为**Spring Tool Suite**(**STS**)的工具，这是一个基于 Eclipse 的 IDE。它为创建基于 Spring Boot 的应用提供支持。从 https://spring.io/tools3/sts/all[下载并安装在你的本地机器上。](https://spring.io/tools3/sts/all)

这里给出的 STS 链接是 3.x 版本，在撰写本文时，STS 的当前版本是 4.x，本书中创建的所有代码都是用 STS 3.x 创建的，因此给出的链接是 3.x 版本，但是，您可以下载最新版本的 STS 并使用代码，没有任何问题。

下载完成后，打开它，选择*文件|新建|* Spring Starter 项目菜单，并填写如下表格:

![](assets/6e3d6a05-6110-42c1-a873-a1366090b9de.png)

单击 Next 按钮，将要求您定义依赖项。选择下列依赖项。您可以使用文本框来搜索特定的依赖关系:

*   **Web:** 用于添加 Spring MVC 特定的依赖项。
*   **反应式 Web:** 添加 WebFlux 特定依赖项。
*   **DevTools:** 有助于开发，因为它会自动刷新嵌入式容器中的更改，以快速查看更改。
*   **反应式 MongoDB:** 在反应式范例中工作的 MongoDB 的 Spring 数据依赖。确保不要选择 MongoDB，它是在非反应式模型中使用 MongoDB 的依赖项。

单击 Finish，您将看到在 STS 的 Package Explorer(或 Project Explorer)部分创建了一个项目。一旦创建了项目，我们将执行以下步骤。

# MongoDB 安装

首先，您需要将 MongoDB 安装到您的本地机器上。它作为独立的服务器和云服务分发。从[https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community)下载最新版本。从列表中选择合适的操作系统，并将其安装在您的计算机上。

MongoDB 没有任何用户界面来访问它。然而，它提供了另一个叫做指南针的工具，可以从:[https://www.mongodb.com/download-center/compass](https://www.mongodb.com/download-center/compass)下载。选择合适的版本和目标平台，并下载它们。在大多数情况下，它是直接可执行的。默认情况下，可以通过`27017`端口访问 MongoDB。只需将 Compass 连接到 MongoDB 服务器，确保它在连接之前正在运行。

# MongoDB 数据结构

在使用 MongoDB 之前，理解其中使用的模式和数据结构非常重要。像关系数据库一样，我们需要首先在 MongoDB 中创建一个数据库。除了数据库，我们还需要创建一个集合。您可以认为集合类似于 RDBMS 中的数据库表。

连接指南针(默认:没有凭证)并单击 CREATE DATABASE 按钮，您将看到如下模型窗口:

![](assets/f78bb8f4-b00b-4848-8fb3-dd8f463fad8a.png)

您需要给出数据库名称和集合名称，并在模型窗口中单击 CREATE DATABASE 按钮。现在可以将学生收集的数据插入 MongoDB。

# 创建 Spring 数据存储库

Spring Data 提供了一致的基于 Spring 的编程模型来访问数据。它抽象出了底层的样板细节，可以用来访问各种各样的数据存储，包括 SQL(关系和非关系)数据库、map-reduce 框架、基于云的数据服务等等。Spring 数据存储库基本上实现了数据访问层，并提供了与底层数据存储交互的抽象访问。

我们将配置 Spring 数据存储库来与 MongoDB 交互。第一步是创建一个实体对象(域模型)。Spring Data 允许以面向对象的方式访问数据，所以首先我们需要定义实体类，并提供与持久性模型的必要映射。实体类可以按如下方式创建:

```
@Document(collection="Student")
public class Student {
  @Id
  @JsonIgnore
  private String id;

  @NotNull(message="Roll no can not be empty")
  private Integer rollNo;

  @NotNull(message="Name can not be empty")
  private String name;

  @NotNull(message="Standard can not be empty")
  private Integer standard;

 //.. getter and setter
}
```

这个 POJO 类用`@Document`注释表示 MongoDB 中的学生实体。您需要在这里给出与我们在 MongoDB 中创建的集合相同的名称。属性 ID 将由 MongoDB 自动生成，并且可以被认为是`Student`实体的主键，因此它用`@Id`注释进行了标记。

接下来添加一个 Spring 数据存储库。Spring 为特定数据存储提供了存储库支持。对于 MongoDB，Spring 数据存储库应该如下所示:

```
@Repository
public interface StudentMongoRepository extends ReactiveMongoRepository<Student, String>{
  public Mono<Student> findByRollNo(Integer rollNo);
  public Mono<Student> findByName(String name);
}
```

Spring Data 提供了`ReactiveMongoRepository`接口，可以扩展该接口来定义一个定制的存储库。它属于`Student`类型，当我们想要与 MongoDB 和`String`交互时，它是一个对象实体类型，表示主键(在我们的例子中是 ID)。

Spring 数据存储库提供了一个很好的特性，称为**查询**方法，它用于按照特定的命名约定基于特定的列或属性值访问数据。例如，`findByName(String name)`将返回具有匹配名称的`StudentData`。Spring Data 提供了这些方法的底层实现。为了简单起见，我们只保留了两个方法。

为了确保 Spring 应用连接到 MongoDB，我们需要在`application.properties`文件中添加以下属性:

```
spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
spring.data.mongodb.database=StudentData
```

这相当于在数据库中定义连接属性。

# WebFlux 编程模型

Spring WebFlux 足够灵活，可以支持不同的开发模式。您可以使用以下两种编程模型在 WebFlux 中创建应用:

*   **带注释的控制器**:这个和 Spring MVC 控制器很像。
*   **功能端点**:功能端点用于处理和路由具有功能编程特性的请求。

我们将在用 Spring 数据仓库和实体类创建的示例 WebFlux 应用中探索这两个选项。下一步是创建一个控制器，可以通过以下两种方式完成。

# 注释控制器

WebFlux 以类似于 Spring MVC 框架的方式提供对基于注释的配置的支持。首先，我们将创建一个带注释的控制器类，它从服务器端发布`Student`实体的反应流，如下所示:

```
@RestController
@RequestMapping("api")
public class StudentWebFluxController {

  @Autowired
  private StudentMongoRepository studentMongoRepository;

  @GetMapping("/getStudent/{rollNo}")
  public Mono<ResponseEntity<Student>> getStudent(@PathVariable("rollNo") Integer rollNo) {
    Mono<Student> studentMonoObj = studentMongoRepository.findByRollNo(rollNo);
    return studentMonoObj.map(student -> ResponseEntity.ok(student))
        .defaultIfEmpty(ResponseEntity.notFound().build());
  }
}
```

`StudentWebFluxController`是带注释的控制器。它类似于 Spring MVC 控制器。`@RestController`注释用于将该控制器定义为 REST 控制器。`@RequestMapping`注释用于定义这个控制器的 URL 映射。

Spring 数据仓库支持非阻塞的反应流。`getStudent()`方法将基于`rollNo`输入值返回一个单独的`Student`对象。然而，返回类型不仅仅是为了响应`Student`；相反，它属于`Mono`类型，因为它最多返回一个元素，所以`Mono`类型更合适。

知识库根据`rollNo`给出`Mono<Student>`；然后我们调用 map 函数将`Mono<Student>`类型的对象映射到`Mono<ResponseEntity<Student>>`，然后由 WebFlux 框架负责返回学生数据。直接从 MongoDB 添加一些值，在 REST 客户端(例如 Postman)中尝试用 URL[http://localhost:8080/API/get student/21](http://localhost:8080/api/getStudent/21)(使用`8080`端口，student `rollNo`为`21`)访问，会得到如下输出:

![](assets/2e5e5589-fb50-4f7f-81cf-8e3340895527.png)

如果我们想要访问多个学生，我们需要使用`Flux`返回类型，因为它发出 0 到 N 个元素。让我们向控制器添加一个方法来获取所有学生，如下所示:

```
  @GetMapping("/getAllStudent")
  public Flux<Student> getAllStudent() {
    Flux<Student> allStudents = studentMongoRepository.findAll();
    return allStudents;
  }
```

从 MongoDB 添加一些学生数据，点击 URL[http://localhost:8080/API/getall student](http://localhost:8080/api/getAllStudent)，您将看到如下结果:

![](assets/2a4c5d53-2e30-4c7c-a57d-fbdc2bc1473b.png)

WebFlux 控制器端点以`Flux`或`Mono`的形式返回一个发布者。在我们返回所有学生的第二种方法中，它可以是一个**服务器发送给浏览器的事件** ( **SSE** )。为此，您需要将返回类型定义为`text/event-stream`。SSE 是一种允许浏览器通过 HTTP 连接从服务器接收自动更新的技术。

这是什么意思？如果我们有一个非常大的流，那么 WebFlux 控制器将发送它从反应式存储库(在我们的例子中是从 MongoDB)接收的数据，并将其发送到浏览器，而不是获取所有记录，这会导致阻塞情况。这就是用 Spring WebFlux 在反应式编程中处理大量流的方式。

# 功能端点

Spring Framework 5 支持使用 WebFlux 的反应式 web 应用的函数式编程模型。这是使用 Spring MVC 风格的带注释控制器的一种替代方法。Spring WebFlux 中的函数式编程使用了以下基本组件:

*   `HandlerFunction` : 它用来处理请求。它是 Spring MVC 控制器处理程序方法的替代方法，工作方式与之类似。
*   `RouterFunction`:用于路由传入的 HTTP 请求。`RouterFunction`是使用带有`@RequestMapping`注释的请求映射的替代方法，工作方式与之类似。

# 函数式反应式编程中需要的工件

我们先来了解一下这些组件。它们在 Spring WebFlux 中被定义为一个接口。`HandlerFunction`界面如下所示:

```
@FunctionalInterface
public interface HandlerFunction<T extends ServerResponse> {
  Mono<T> handle(ServerRequest request);
}
```

这个接口类似于`Function<T,R>`类型，它接受值(属于`T`类型)并返回另一个值(属于`R`类型)。这种情况下相当于`Function<ServerRequest,Mono<T>`。它很像一个 servlet。`T`类型是应该实现`ServerReponse`接口的函数的响应类型，表示服务器端 HTTP 响应。

`handle()`方法接受`ServerRequest`对象类型并返回一个`Mono`对象类型。`ServerRequest`表示 HTTP 请求，我们可以从中获得请求的头部和主体。`ServerRequest`和`ServerResponse`都是 Spring WebFlux 的反应式 API 的一部分。

您可能会注意到，不是将请求和响应放在同一个方法调用中，而是从`handle()`方法中返回响应，这确实使它没有副作用并且易于测试。我们来看看`RouterFunction`长什么样。同样，它的接口类型如下:

```
@FunctionalInterface
public interface RouterFunction<T extends ServerResponse> {
  Mono<HandlerFunction<T>> route(ServerRequest request);
  //.. other methods.
}
```

这个接口有返回与给定请求匹配的`HandlerFunction`的`route()`方法。该方法用于通过应用`RequestPredicate`创建路线。当谓词匹配时，它将返回处理程序函数，该函数基本上处理请求。`RequestPredicate`是 Java8 的功能接口，也是 Spring WebFlux 的反应式 API 的一部分。它用于测试路由的给定`ServerRequest`,如下所示:

```
@FunctionalInterface
public interface RequestPredicate {
  boolean test(ServerRequest request);
//Other functions
}
```

让我们用函数式编程来创建控制器。我们将编写一个控制器，它的工作方式与带注释的控制器完全相同，只是在功能上有所不同。

# Spring WebFlux 中函数方法的先决条件

为了以功能的方式工作，我们需要做的第一件事就是让我们的项目 WebFlux 知道。为此，我们需要向主 bootstrap 类添加`@EnableWebFlux`注释，如下所示:

```
@SpringBootApplication
@EnableWebFlux
public class SpringWebFluxDemoApplication {
 // other code ..
}
```

我们还需要通过在`application.properties`文件中添加以下属性来指示 Spring 应用属于`reactive`类型:

```
spring.main.web-application-type=reactive
```

# 定义路由器和处理程序

下一部分是定义获取学生数据的路由器和处理程序。让我们回忆一下，路由器用于路由请求，因为它们在带注释的控制器中服务于`@RequestMapping`的目的，而处理程序实际上处理传入的请求，这类似于 Spring MVC 控制器处理程序方法。路由器类如下所示:

```
@Configuration
public class StudentRouter {
    @Autowired
    private StudentHandler studentHandler;
     @Bean
      RouterFunction<ServerResponse> returnStudent() {
          return RouterFunctions.route(RequestPredicates.GET("/api/f/getStudent/{rollNo}"),
              studentHandler::getStudent);
      }
     @Bean
      RouterFunction<ServerResponse> returnAllStudent() {
          return RouterFunctions.route(RequestPredicates.GET("/api/f/getAllStudent"),
              studentHandler::getAllStudent);
      }
}
```

需要用`@Configuration`注释声明 router 类，这样 Spring container 将在上下文加载时选择这个类并进行必要的配置。我们有两种方法分别获取单个学生和所有学生数据的列表。

路由器是用`RouterFunctions.route()`调用创建的。`RouterFunctions`实用程序类有很多有用的函数。`route()`方法需要两个参数。第一个参数是`RequestPredicate`的。键入另一个助手类`RequestPredicates`用于为每个路由器方法定义带有 URL 模式的`RequestPredicate`。`RequestPredicate`类有各种对应于 HTTP 方法的方法。

我们使用了`GET`方法，因为我们想用`GET`方法从 REST 客户端获取数据。这里重要的是定义任何路径变量以及 URL 模式，这些变量将在处理程序中接收，以执行必要的操作。

第二个参数属于`HandlerFunction<T>`类型，由`StudentHandler`类的相应方法提供。`studentHandler::getStudent`和`studentHandler::getAllStudent`双列符号将分别调用`StudentHandler`类的`getStudent()`和`getAllStudent()`方法。`StudentHandler`类应该如下所示:

```
@Component
public class StudentHandler {
  @Autowired
  private StudentMongoRepository studentMongoRepository;

  public Mono<ServerResponse> getStudent(ServerRequest serverRequest) {
    int rollNo = getInt(serverRequest.pathVariable("rollNo"));
    Mono<Student> studentMonoObj = studentMongoRepository.findByRollNo(rollNo);
    return ServerResponse.ok().body(studentMonoObj, Student.class);
  }
  public Mono<ServerResponse> getAllStudent(ServerRequest serverRequest) {
    Flux<Student> allStudents = studentMongoRepository.findAll();
    return ServerResponse.ok().body(allStudents, Student.class);
  }
  private int getInt(String intStr) {
    int returnVal=0;
    if(intStr !=null !intStr.isEmpty()) {
      try {
        returnVal = Integer.parseInt(intStr);
      }catch(Exception e) {
        e.printStackTrace();
      }
    }
    return returnVal;
  }
}
```

每个处理程序方法都有一个对象`ServerRequest`作为参数，当它们被路由器调用时，这个参数将由 Spring WebFlux 框架提供。`ServerRequest`类表示 HTTP 请求，我们可以从中获取参数和主体。

在`getStudent()`方法中，我们读取`rollNo`路径变量，并将其传递给存储库方法以获取学生数据。此处的路径变量名称必须与路由器中声明为 URL 模式一部分的路径变量名称相同(`/api/f/getStudent/{**rollNo**}`)。最后，`ServerResponse`类用于构造一个响应并返回它。为了区分功能端点，我们更新了 URL 模式(在两者之间添加了`/f/`来表示其功能端点)。您将获得与带注释的控制器类似的输出。

处理程序方法不需要用`@Bean`注释来定义，否则在启动应用时会出错。

# 结合处理器和路由器

我们为处理器和路由器编写了两个不同的类；然而，我们可以在一个类中声明包含路由器和处理器功能的配置。这可以通过将处理程序和路由器方法组合成一个方法来实现，如下所示:

```
@Configuration
public class StudentRouterHandlerCombined {

  @Autowired
  private StudentMongoRepository studentMongoRepository;

  @Bean
  RouterFunction<ServerResponse> returnStudentWithCombineFun(){

        HandlerFunction<ServerResponse> studentHandler = 
                serverRequest -> {
                 int rollNo = getInt(serverRequest.pathVariable("rollNo"));
                 return ServerResponse.ok().
                    body(studentMongoRepository.findByRollNo(rollNo)
                    , Student.class);
             };

    RouterFunction<ServerResponse> studentResponse =
        RouterFunctions.route(
             RequestPredicates.GET("/api/f/combine/getStudent/{rollNo}"),
             studentHandler);

    return studentResponse;
    }

  @Bean
  RouterFunction<ServerResponse> returnAllStudentWithCombineFun(){
        HandlerFunction<ServerResponse> studentHandler = 
                serverRequest -> 
                 ServerResponse.ok().
                 body(studentMongoRepository.findAll(), Student.class);

    RouterFunction<ServerResponse> studentResponse =
        RouterFunctions.route(
            RequestPredicates.GET("/api/f/combine/getAllStudent"),
            studentHandler);

    return studentResponse;
    }

  private int getInt(String intStr) {
    int returnVal=0;
    if(intStr !=null !intStr.isEmpty()) {
      try {
        returnVal = Integer.parseInt(intStr);
      }catch(Exception e) {
        e.printStackTrace();
      }
    }
    return returnVal;
  }
}
```

这个类有两个方法分别获取单个学生和所有学生。在每个方法中，我们首先创建一个处理程序的实例，然后在创建路由器时将它传递给`route()`方法。lambda 表达式用于定义处理程序。代码简单明了。同样，为了使它变得独特，我们更改了 URL 模式，在两者之间添加了`/combine/`，这样获取单个学生和所有学生的端点可以分别通过 URL[http://localhost:8080/API/f/combine/get student/21](http://localhost:8080/api/f/combine/getStudent/21)和[http://localhost:8080/API/f/combine/get all student，](http://localhost:8080/api/f/combine/getAllStudent)进行访问。您将得到与我们分别定义处理器和路由器时类似的输出。

你可能想知道这是如何在引擎盖下工作的。`RouterFunctionMapping`类型的 bean 在启动应用时扫描包并检索所有的`RouterFunctions`。这个 bean 是在`WebFluxConfigurationSupport`中创建的，它是 Spring WebFlux 配置的总部。当我们定义主 bootstrap 类的`@EnableWebFlux`注释和`spring.main.web-application-type=reactive`属性时，所有这些事情就开始发生了。

# 复合路由器

如果您的配置中有很多路由器，那么基本上可以用`and`操作符将它们组成一个链。在前面的例子中，我们用两种不同的方法定义了两台路由器。这可以通过以下一种方法来实现:

```
@Configuration
public class StudentCompositeRoutes {

  @Autowired
  private StudentMongoRepository studentMongoRepository;

  @Bean
  RouterFunction<ServerResponse> compositeRoutes(){

    RouterFunction<ServerResponse> studentResponse =
        RouterFunctions.route(RequestPredicates.
            GET("/api/f/composite/getStudent/{rollNo}"),
            serverRequest -> {
              int rollNo = getInt(serverRequest.pathVariable("rollNo"));
              return ServerResponse.ok().
                  body(studentMongoRepository.
                      findByRollNo(rollNo), Student.class);
            })
        .and(
            RouterFunctions.route(RequestPredicates.
                GET("/api/f/composite/getAllStudent"),
                serverRequest -> 
            ServerResponse.ok().
            body(studentMongoRepository.findAll(), Student.class))
            );

    return studentResponse;
  }
  private int getInt(String intStr) {
    int returnVal=0;
    if(intStr !=null  !intStr.isEmpty()) {
      try {
        returnVal = Integer.parseInt(intStr);
      }catch(Exception e) {
        e.printStackTrace();
      }
    }
    return returnVal;
  }
}
```

`and`操作符用于合并两个路由器。此外，`rout()`函数的第二个参数是`HandlerFunction<T>`类型的，用 lambda 表达式定义。这就是如何用`and`操作符在单个链调用中组合多个路由器。为了区分这个特性，我们再次改变了端点 URL 模式，因为我们在 URL 模式中添加了`/composite/`而不是`/combine/`。不用说，在这种情况下，您也会得到类似的输出。

# WebSocket 支持

WebSocket 是一种允许服务器和客户端之间进行全双工双向通信的协议。建立连接时，它使用 HTTP 进行初始握手。一旦完成，它将请求协议升级。Spring WebFlux 框架支持基于 Java WebSocket API 的客户端和服务器之间的反应式 WebSocket 通信。定义 WebSocket 的过程分为两步，如下所示:

*   定义处理程序来管理 WebSocket 请求
*   定义映射以访问特定的处理程序

在 WebFlux 中，通过实现`WebSocketHandler`接口来处理 WebSockets。它有一个叫做`handle()`的方法。每次建立到处理程序的连接时，它都提供有`WebSocketSession`的对象。顾名思义，`WebSocketSession`代表单个客户端形成的连接。

通过`Flux`类型的`receive()`和`send()`方法可访问的两个独立的流与`WebSocketSession`相关联，分别用于处理传入请求和传出消息。我们将首先如下定义处理程序映射:

```
 @Autowired
 SampleWebSocketHandler studentWebSocketHandler;

 @Bean
 public HandlerMapping webSockertHandlerMapping() {
   Map<String, WebSocketHandler> map = new HashMap<>();
   map.put("/student", studentWebSocketHandler);

   SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
   mapping.setUrlMap(map);
   return mapping;
 }
 @Bean
 public WebSocketHandlerAdapter handlerAdapter() {
   return new WebSocketHandlerAdapter();
 }
```

`@Bean`带注释的方法`webSockertHandlerMapping`用于将我们的自定义处理程序映射到一个特定的 URL 模式，通过该模式可以访问它。`SampleWebSocketHandler`定制处理程序被注入了`@Autowired`注释，如下所示:

```
@Component
public class SampleWebSocketHandler implements WebSocketHandler{

  private ObjectMapper objMapper = new ObjectMapper();

  @Autowired
  StudentMongoRepository studentMongoRepository;

  @Override
  public Mono<Void> handle(WebSocketSession webSocketSession) {
    Flux<Student> allStudentSource = studentMongoRepository.findAll();
    System.out.println(" ****** Incoming messages ****** ");
    webSocketSession.receive().subscribe(System.out::println);

    System.out.println(" ****** Sending Student data ****** ");
    return webSocketSession.send(allStudentSource.map(student->{
      return writeValueAsSTring(student);
     }).map(webSocketSession::textMessage)
     );
  }

  private String writeValueAsSTring(Object obj) {
    try {
      return objMapper.writeValueAsString(obj);
    } catch (JsonProcessingException e) {
      e.printStackTrace();
    }
    return "No data";
  }
}
```

`SampleWebSocketHandler`类用`handle()`方法提供了`WebSocketHandler`接口的实现。在那个方法中，我们简单地从`StudentMongoRepository`获取所有学生数据，并在`WebSocketSession`上调用`send()`方法。在`send()`方法中，我们先用`ObjectMapper`将`Student`对象转换成 JSON 字符串，最后调用`WebSocketSession`的`textMessage()`方法将其转换成`WebSocketMessage`。

接下来，是创建客户端。我们会用 JavaScript 写客户端代码，从浏览器调用服务器，看看流数据是怎么一个一个接收的。您可以用下面的代码创建一个 HTML 文件。

```
<html>
  <body>
    Hello
  </body>
  <script>
      var socket = new WebSocket('ws://localhost:8080/student');
      socket.addEventListener('message', function (event) {
      window.alert('message from server: ' + event.data);
      });
  </script>
</html>
```

几乎所有现代浏览器都支持 WebSocket 通信。在浏览器中打开这个 HTML，你会看到一个接一个的学生数据，并有浏览器提示。这就是 WebSocket 通信在 Spring WebFlux 的反应式范例中是如何发生的。

# 摘要

Reactive 无疑是一种有前途的新技术，它将有助于构建可伸缩的高性能应用。Spring 用一个叫做 WebFlux 的新框架在支持反应式系统方面做了令人印象深刻的工作。Reactive 是下一代应用的未来，几乎任何地方都需要它:数据存储、中间层、前端，甚至移动平台。

通过本章，我们学习了反应式系统和反应式编程的基础知识，以及实现反应式编程的各种技术。然后我们学习了反应流，这是实现反应系统的最流行的方法之一。从反应流规范和基本原理开始，我们探索了各种基于 JVM 的库，这些库提供了特定规范的实现。我们用 RxJava 和 Project Reactor 做了一些实践工作，学习了底层原理。

在同一个方向上，我们已经看到了 Spring 框架是如何在一个反应式范例中提供支持的。然后，我们通过创建一个基于 Spring Boot 的 web 应用探索了 Spring WebFlux 框架。除了对 WebFlux(类似于 Spring MVC)基于注释的支持之外，Spring 还支持用函数式编程范例创建反应式系统。我们通过一系列例子探讨了函数式编程中的各种选项。

为了充分利用 Spring WebFlux 的反应式功能，数据存储还应该支持反应式编程，这就是我们选择 MongoDB 作为数据存储的原因，我们学习了如何使用 Spring Boot 工具在 web 应用中配置它。

到目前为止，这是一个非常令人兴奋的旅程，我们将在下一章继续我们的旅程，探索 Elasticsearch 与 Spring 框架集成的有趣主题。我们将开发一个名为 **Blogpress** 的示例应用。我们还将更详细地研究 Spring Boot、百里香等；请继续关注，并准备在下一章中进一步探索。