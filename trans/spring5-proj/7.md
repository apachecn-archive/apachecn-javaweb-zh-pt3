# 七、使用 Spring 和 Kotlin 的任务管理系统

在迄今为止的章节中，我们已经深入探讨了各种主题和概念。从纯 Spring 框架开始，到 Spring Boot，我们了解了如何快速轻松地使用 Spring Boot 创建企业级应用。

我们还了解了 Spring 框架与其他工具和技术的集成，比如 Elasticsearch、LDAP 和 OAuth，都在 Spring Boot 上下文的范围内。然后我们学习了一种新的方法，用 Spring 作为后端，Angular 作为前端，用一个叫做 **JHipster** 的工具来创建一个应用。

然后，我们发现如何在分布式环境的维度上创建一个具有现代架构的应用，称为**微服务**。在这一章中，我们进一步探索 Spring 框架的一个完全不同的维度，看看一种叫做 **Kotlin** 的新编程语言是如何支持它的。

作为一种编程语言，Kotlin 很快在开发者和公司中流行起来。Kotlin 的第一个稳定版本于 2016 年正式发布。就在第二年，Google 正式宣布 Kotlin 是 Android 平台上支持移动开发的语言。这大大增加了 Kotlin 的知名度和采用率。

从版本 5 开始，Spring 宣布支持 Kotlin 在 Spring 框架上开发企业应用。在这一章中，我们将探索如何用 Kotlin 开发一个基于 Spring 的应用。我们将与 Spring Boot 和科特林一起构建一个名为“任务管理”的应用，并将涵盖以下内容:

*   科特林简介
*   Kotlin 作为编程语言的基本特征
*   科特林对 Java
*   Kotlin Spring 支架
*   用 Kotlin 在 Spring 中开发任务管理应用

# 技术要求

本章用到的所有代码都可以从以下 GitHub 链接下载:[https://GitHub . com/packt publishing/Spring-5.0-Projects/tree/master/chapter 07](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07)。该代码可以在任何操作系统上执行，尽管它只在 Windows 上测试过。

# 介绍科特林

Kotlin 是一种用于 Java 虚拟机的语言，因此可以用来代替 Java。无论是服务器端、移动端还是 web 端，目前只要使用 Java 的地方都可以使用 Kotlin。它由一家名为 **JetBrains** 的公司赞助；它是开源的，你可以从 GitHub([https://github.com/jetbrains/kotlin](https://github.com/jetbrains/kotlin))下载源代码。他们计划在不久的将来为嵌入式和 iOS 平台推出 Kotlin。

Kotlin 作为函数式编程语言提供了很好的支持。术语“函数式编程”用于描述声明性范例，其中程序是通过表达式或声明而不是通过命令的执行来创建的。函数式编程模型固有地为应用带来了某些品质，例如更具压缩性和可预测性的代码、易于测试的能力、可重用性等等。Kotlin 以内置特性的形式带来了一种功能范式。

Java 和 Kotlin 有很多相似之处，所以问题来了，当 Java 已经被广泛使用和流行了二十多年的时候，我们为什么还需要另一种编程语言。答案在于 Kotlin 的一些很酷的特性，这些特性使它成为开发基于 JVM 的应用的更好选择。

# 互用性

Kotlin 最有前途的特性之一是它的互操作能力。Kotlin 与 Java 100%互操作。应用可以结合两种语言。可以从 Kotlin 调用 Java 库，无需任何转换或麻烦。同样，用 Kotlin 编写的代码也可以轻松地从 Java 中调用。这极大地帮助了 Java 开发人员毫无困难地从 Java 迁移到 Kotlin。

将代码从一种编程语言移植到另一种编程语言是一项非常乏味且耗时的任务，尤其是当这些编程语言在规则、语法、特性等方面不兼容时。尽管 Kotlin 中有许多特性是 Java 中没有直接或间接提供的，但正是 Kotlin 的互操作性允许同时用两种编程语言运行代码。您不必将所有 Java 代码迁移到 Kotlin。Kotlin 的**互操作性**如下图所示:

![](assets/e3cc5dc9-95a7-4c99-a716-6a793669cb62.png)

最重要的是，Kotlin 标准库依赖于 Java 类库，这允许重用依赖关系，并且在任何地方都不需要代码重构。比如:Kotlin 的集合框架是建立在 Java 的集合 API 之上的。

# 简洁而有力

与 Kotlin 一起工作时，你会发现它的另一个优点是简洁。Kotlin 语法易于阅读和解释，即使事先没有任何编程语言的知识。Kotlin 有一些特性使它成为一门真正简洁的语言，比如类型接口、数据类、属性、智能类型转换等等。我们将在本章的后面看到关于它们的更多细节。

有了这些特性，用 Kotlin 编写的代码既紧凑又不失其功能。Kotlin 在许多方面比 Java 更简洁，正因为如此，我们可以用更少的代码行实现相同的功能。这大大提高了易读性和易用性。开发人员可以轻松地阅读、编码和更新程序，即使它是由他人编写的。

此外，Kotlin 通过各种特性(如默认参数、扩展函数和对象声明)加速了日常开发任务。您的代码更加紧凑和健壮，不会引起任何可维护性问题。这将减少系统出现错误的可能性。

Kotlin 是作为 Java 的一个增强而发展起来的，而不是一种全新的语言。所以你对 Java 的技能和知识可以应用到 Kotlin 上，使它成为一种容易学习的语言。

# 安全装置

你会喜欢 Kotlin 的另一个原因是它的安全特性。用 Kotlin 写的代码远比用 Java 写的安全。Kotlin 的设计可以避免常见的编程缺陷，从而使系统更加稳定，崩溃和故障更少。

对于任何允许空引用的编程语言，都会在应用执行期间创建一个运行时异常，比如`NullPointerException`。对这种情况处理不当可能会导致突然的系统冲突。如果您以前有过 Java 的经验，您可能会经历过这样的场景。

Kotlin 在设计时就考虑到了这一点，并将引用类型定义为两类:可空的和不可空的。默认情况下，Kotlin 不允许引用 null 值，并强制开发人员以特定的方式处理它们。这就大大降低了`NullPointerException`引发问题的可能性。

# IDE 支持

**JetBrains** ，Kotlin 背后的公司，以**I**integrated development environment(IDE)名为 **IntelliJ IDEA** ，而显然对 Kotlin 有着一流的支持。就 IDE 而言，Eclipse 也是 Java 开发人员最喜欢的工具之一，因此 JetBrains 也为 Eclipse 提供了一个 Kotlin 插件。

在 Java 刚刚发展的早期，初始阶段没有 IDE，开发人员必须使用文本编辑器来编写代码。没有 IDE 的安全性和便利性，很难工作。当 Eclipse 上市时，开发人员很快采用了它，从那时起，它在 Java 开发人员中变得流行并被广泛接受。

另一方面，Kotlin 很幸运，从第一天起就获得了 IDE 支持。这迅速提升了科特林的知名度。真的很方便，也很容易学。开发人员能够快速生成高质量的代码，从而改善软件开发生命周期。

不用说，Kotlin 允许用文本编辑器编码。此外，您可以使用命令提示符来构建 Kotlin 应用。此外，如果你是一名 Android 开发人员，它有自己的 IDE，名为 **Android Studio** ，基于 IntelliJ IDEA IDE 开发。

# 科特林特色

Kotlin 的设计目的不是与 Java 竞争，而是成为一种优秀的 JVM 语言，增加了 Java 中没有的特性。与 Java 相比，Kotlin 作为一种语言，有许多令人兴奋的新特性，增加了代码的可读性和可维护性。

了解科特林的基本特征至关重要。在这一节中，我们将探索其中几个对于在 Kotlin 中构建应用至关重要的部分。

# 函数的概念

根据定义，函数是执行特定任务的一组相关语句。它是任何程序的基本构件。你可以把 Kotlin 中的函数等同于 Java 中的方法；但是，也有一定的区别。Kotlin 中的函数可以在顶层定义，这意味着它不需要包含在类中。该函数可以是类的一部分，也可以在另一个函数中定义。

在 Kotlin 中，函数得到了一流的支持，这意味着它支持所有的操作，可以存储在变量和数据结构中，作为参数传递给其他函数，也可以从其他(顶级)函数返回，可以定义为表达式，等等。所有这些特性带来了极大的灵活性，使 Kotlin 变得非常简洁。我们将在 Kotlin 中看到函数的以下用法。

# 用作表达式

编写函数时，需要将代码放在函数体中。但是，在 Kotlin 中，您可以将函数定义为表达式。例如:您想找出两个数字之间的最小值，您编写了一个名为`min()`的函数，如下所示:

```java
fun main(args: Array<String>) {
    print(min(4,7))
}
fun min(numberA: Int, numberB:Int) : Int {
    if(numberA < numberB){
        return numberA
    }else{
        return numberB
    }
}
```

这将返回两个给定数字中的最小数字。该函数可以写成如下表达式:

```java
fun min(numberA: Int, numberB:Int) : Int = if(numberA < numberB){ numberA }else{ numberB }
```

这就是代码看起来富有表现力和紧凑的方式。另外，请注意，我们已经删除了`return`关键字，因为 Kotlin 足够聪明，可以在不显式指定`return`关键字的情况下返回最后一个值。这就是所谓的**单线**或**单线**功能。但是，对于一个复杂的函数，您可以将它写成多行，如下所示:

```java
fun min(numberA: Int, numberB:Int) : Int
   =  if(numberA < numberB){
            numberA
        }else{
            numberB
        }
```

这样看起来更紧凑，更有表现力。

# 默认函数参数

通常，我们提供给函数或构造函数的数据量在不同的用例中是不同的。即使我们没有提供所有参数的值，系统也应该足够灵活以产生期望的结果。

如果你想在 Java 中实现这一点，你需要根据你的需要编写一些重载函数或构造函数。您最终将使用不同的输入参数集多次编写相同的方法，并使用默认值调用其他构造函数或方法。这很快就会产生冗长的代码——为同一件事反复编写代码。

Kotlin 为这个场景提供了一个直观的解决方案，它的特性叫做默认函数参数。这听起来很简单。您需要为那些您认为在执行函数时可能没有提供值的函数参数定义一个默认值。

例如:假设我们编写了如下函数来计算立方体的体积:

```java
fun getVolume(length:Int, width:Int,height:Int):Int{
    return length * width * height;
}
```

调用这个函数时，需要传递所有三个参数，否则编译器会发出错误信号。现在，假设我们希望系统将默认高度作为`10`，如果它没有被明确提供的话。可以这样写:

```java
fun getVolume(length:Int, width:Int,height:Int =10):Int{
    return length * width * height;
}
```

该功能可以被称为`getVolume(2,4)`，`10`将被替换为`height`的默认值。

# 扩展功能

如果您需要用一组新功能扩展一个类，您需要更新 Java 源代码。但是，如果您使用第三方库，您可能没有源代码。需要扩展一个类来容纳其他函数。为此，您还可以使用各种设计模式，如装饰和策略。

然而，Kotlin 允许直接将额外的函数添加到现有的类中，这个特性被称为 **e** **扩展函数**。顾名思义，扩展函数扩展了类的功能，而不涉及它的源代码。换句话说，您不再需要继承要扩展的类。这听起来真的很有趣。它的行为就像其他成员函数一样，但它是在类之外声明的。

假设您需要将给定的字符串转换成 camel case。Kotlin `String`类不提供将给定的字符串转换成 camel case 的功能。我们将使用扩展函数来定义一个单独的函数，该函数将实际完成如下工作:

```java
fun String.camelCase():String{
    var camelCaseStr = StringBuffer()
    var wordLst : List<String> = this.trim().split(" ")
    for(word in wordLst){
        camelCaseStr.append(word.replaceFirst(word[0], word[0].toUpperCase())).append(" ")
    }
    return camelCaseStr.trim().toString()
}
```

`camelCase()`函数是`String`类的扩展函数，它返回字符串。自定义逻辑驻留在该函数的主体中。您可以对任何字符串文字调用`camelCase()`函数，如下所示:

```java
fun main(args: Array<String>) {
    print("this is just for sample".camelCase())
 // This will print as—This Is Just For Sample
}
```

`camelCase()`函数是我们的自定义函数，所以你可以使用任何你认为合适的名字。让我们再看一个扩展函数的例子。假设你想求给定整数的平方。同样，Kotlin 没有为此提供直接函数，但我们可以编写如下扩展函数:

```java
fun Int.square():Int{
    return this * this
}
```

`square()`扩展函数可以用整数来调用，如下所示:

```java
fun main(args: Array<String>) {
    print(3.square())
}
```

这是一个非凡的特性，我们可以用它来扩展功能，而无需更新代码或继承基类。

# Lambda 表达式或函数文字

每种编程语言都有定义文字的规定，如字符串、整数、双精度等。它们可以用特定的方式定义，比如字符串型的`Hello`，双字符型的`34.23`，等等。Kotlin 允许我们通过将代码括在大括号中来将函数定义为文字，如下所示:

```java
//This is functional literal
{ println(" This is function literal ")}
```

这个函数可以用一种普通的方式声明，如下所示:

```java
fun printMsg(message:String){
    println(message)
}
```

它本质上和函数文字是一样的。但是函数文字看起来很紧凑，但却很有表现力。可以将函数文本赋给变量，并在代码的后面调用，如下所示:

```java
//Functional literal assigned to variable
var greetingMsg = { println("Hello World ...!!!")}

//Calling the function through literal
greetingMsg()
```

可以像第一行一样将函数文本赋给一个变量。就像其他函数一样，函数文本可以用变量(带括号)调用，如第二行所示。函数文字的某些特征如下:

*   它表示没有任何名称的函数块或函数体。
*   它不与任何实体(如类、接口或对象)关联或绑定，因此不允许使用访问修饰符。
*   由于它没有名字，所以叫做**匿名。**
*   可以作为参数传递给其他函数(主要是高阶函数)。
*   它通常用花括号括起来，没有关键字`fun`。
*   它也被称为 lambda 表达式。

Kotlin 还允许向函数文字或 lambda 表达式传递参数，如下所示:

```java
//Lambda with parameter
var showWarning = {message : String -> println(message)}

//Calling Lambda expression with parameter
showWarning(" Warning 1 occurred ..!!!")
showWarning(" Warning 2 occurred ..!!!")
```

lambda 表达式由一个箭头(`->`)分成两部分。左边部分是参数部分，右边部分是 lambda 或函数体。允许多个参数使用逗号分隔的列表，并且不用括号括起来，如下所示:

```java
//Multiple parameters
var addition = { num1: Int, num2: Int ->
        println("sum of $num1 and $num2 is ..${num1+num2}")
     }
addition(3, 5)
```

我们可以用稍微不同的方式编写这段代码，如下所示:

```java
var addition2 : (Int,Int)-> Unit = { num1, num2 ->
    println("sum of $num1 and $num2 is ..${num1+num2}")
}
addition2(3, 5) 
```

在这段代码中，参数的声明从 lambda 表达式中移出。Kotlin 中的`Unit`函数相当于 Java 中的`void`。这个特性使 Kotlin 成为真正的函数式语言。函数文字也可以是另一个函数的参数。

# 将 lambda 传递给另一个函数

Kotlin 允许我们使用 lambda 表达式将一个函数作为参数传递给其他(高阶)函数。这种函数可以接受 lambda 表达式或匿名函数作为参数。在进一步讨论这个话题之前，让我们先了解一下什么是函数类型。

Kotlin 是一种静态类型语言，函数也需要有一个类型。它被称为**函数类型**。我们将看到一些如何定义它们的例子，如下所示:

*   `()->Int`:返回整数类型且不带参数的函数类型。
*   `(Int)->Unit`:采用整数参数，不返回任何值的函数类型。
*   `()->(Int)->String`:返回另一个函数的函数类型，最终返回一个字符串。后一个函数接受一个整数作为参数。

现在，让我们看看如何将函数类型定义为外部函数的输入参数。考虑一个场景，您正在设计一个申请银行贷款的应用。你需要检查资格标准，并决定贷款是否适用。完成这项工作的函数应该如下所示:

```java
data class Applicant(
                    var applicantId: Int,
                    var name: String,
                    var age: Int,
                    var gender: String)

fun isEligibleForLoan (mobileNo:String, eligibilityScore:(applicantId:Int)->Double) : Boolean{
    //Business logic to fetch applicant details from given mobileNo
    var applicant = Applicant(12,"Nilang",38,"M");
    var score = eligibilityScore(applicant.applicantId);
    return score >80
}
```

`isEligibleForLoan()`函数是一个带两个参数的高阶函数。第一个参数是申请人的手机号码，它将从中获取申请人的详细信息。第二个参数是函数类型，我们可以将其视为一种接口类型。它只是根据给定的申请者 ID 计算资格分数。函数类型的实际实现将在如下调用`isEligibleForLoan()`函数时提供:

```java
var isEligible = isEligibleForLoan("9998789671",{
     applicantId -> //Write logic to calculate the 
                   //eligibility of candidate and return the score
     85.23 // This is sample value
 })
 println(" isEligibile: $isEligible ")
```

我们需要在第二个参数中传递一个 lambda 表达式。它只是一个匿名函数，将应用 ID 作为输入参数，并计算合格分数。分数将返回到`isEligibleForLoan()`函数，根据分数，我们返回贷款是否适用。

如果函数类型是最后一个参数，那么 Kotlin 允许以稍微不同的方式调用它。可以按如下方式调用前面的函数:

```java
var isEligible2 = isEligibleForLoan("9998789671"){
        applicantId -> //Write logic to calculate the eligibility 
                       //of candidate and return the score
    75.23 // This is sample value
}
```

这样，lambda 表达式就放在了括号之外，更有表现力。但这只有在最后一个参数声明了函数类型时才有可能。将 lambda 表达式作为函数类型传递是很有用的，特别是对于 Ajax 调用，我们希望在不冻结 UI 的情况下从响应中获得数据后更新页面元素。通过 lambda 表达式注入的函数将作为回调函数工作。

# 从另一个函数返回一个函数

我们已经看到了在调用另一个函数时如何将函数类型定义为参数。在 lambda 表达式的帮助下，它变得更加简单。更进一步，Kotlin 允许从一个函数返回另一个函数。让我们来理解它是如何工作的。

假设我们有一个名为`WildAnimal`的接口，它由如下三个类实现:

```java
interface WildAnimal{
    fun setName(name:String)
    fun bark():String
}

class Dog : WildAnimal{
    private var dogName: String = ""
    override fun bark(): String {
        print(" Bhao bhao ...")
        return "${dogName} Dog is barking ..."
    }
    override fun setName(name: String) {
        this.dogName = name
    }
}
class Fox : WildAnimal{
    private var foxName: String = ""
    override fun bark(): String {
        print(" Haaaaoooooo...")
        return "${foxName} Fox is barking ..."
    }
    override fun setName(name: String) {
        this.foxName = name
    }
}
class Lion : WildAnimal{
    private var lionName: String = ""
    override fun bark(): String {
        print(" HHHHHAAAAAAAAAAA...")
        return "${lionName} Lion is Barking ..."
    }
    override fun setName(name: String) {
        this.lionName = name
    }
}
```

每个类都实现了两个方法——`setName()`和`bark()`，它们将分别设置动物并显示吠声。我们将为每个类创建一个实例，设置它的名称，并调用`bark()`函数来打印吠声和动物的名字。为此，我们将编写如下函数:

```java
fun getAnimalVoiceFun(animal: WildAnimal):(String) -> String{
    return {
        animal.setName(it)
        animal.bark()
    }
}
```

`getAnimalVoiceFun`函数以`WildAnimal`的实现作为参数，返回以`String`作为参数，返回`String`作为输出的函数。写在`getAnimalVoiceFun`函数体的`{ }`括号内的代码表示从该函数返回的函数。`it`参数指向封闭函数的`String`参数。

实际返回字符串的`animal.bark()`函数最终将从一个封闭函数中返回。该函数可以用稍微不同的方式编写，如下所示:

```java
fun getAnimalVoiceFun(animal: WildAnimal):(name:String) -> String{
    return {
             animal.setName(name=it)
             animal.bark()
        }
}
```

不同之处在于，我们声明了类型字符串的参数名称— `name`，并在封闭函数中将它用作一个`name=it`表达式。在前两种方式中，括号代表函数，所以`fun`关键字是无声的。但是，您可以将其声明如下:

```java
fun getAnimalVoiceFun(animal: WildAnimal):(String) -> String{
  return fun(name:String):String {
     animal.setName(name)
 return animal.bark()
}
```

这样，我们显式地使用`fun`关键字来封闭函数。此外，您必须在封闭函数中明确提到`return`关键字。你可以用这两种方法中的任何一种来声明`getAnimalVoiceFun`函数。您可以按如下方式调用此函数:

```java
println(getAnimalVoiceFun(Lion())("Jake"))
println(getAnimalVoiceFun(Dog())("Boomer"))
println(getAnimalVoiceFun(Fox())("Lilli"))
```

我们用相应类的实例调用`getAnimalVoiceFun`函数。您可以看到包含在单独括号中的第二个字符串参数是如何提供给函数`getAnimalVoiceFun`中定义的函数的。您将获得如下输出:

![](assets/e42631de-5550-4cfc-9cc8-32fdebc12724.png)

在 Kotlin 中，函数可以定义为类型。我们可以使用函数类型来声明前面的函数，如下所示:

```java
val getAnimalVoice: (WildAnimal) ->(String)-> String = {
        animal:WildAnimal -> {
               animal.setName(it)
               animal.bark()
         }
}
```

`getAnimalVoice`变量被定义为一个函数类型，它接受`WildAnimal`对象并返回另一个函数，该函数接受`String`作为输入参数(带有`it`关键字)并返回一个`String`输出(通过调用`animal.bark()`)。λ表达式用于定义该函数。这可以被称为如下:

```java
println(getAnimalVoice(Lion())("Lio"))
println(getAnimalVoice(Dog())("Tommy"))
println(getAnimalVoice(Fox())("Chiku"))
```

输出如下所示:

![](assets/cca14107-1d57-453e-af30-9f17e0808088.png)

可能有其他直接的方法来设置动物名称和打印吠声。然而，我们已经看到了如何从另一个函数返回这个函数。您可以编写一些适用于多个函数的公共逻辑，将公共代码作为一个单独的函数返回是将该函数用作另一个函数的返回类型的理想场景。这就是科特林的灵活和简洁。

# 零安全

在使用 Java 时，当程序执行并试图访问设置为 null 的变量，而这些变量没有用正确的值初始化时，它会使系统崩溃并产生一个经典的异常`NullPointerException`。

正如我们所知，Kotlin 是一种静态类型语言，所以一切都被定义为一种类型，包括空值。可空性是 Kotlin 中的一种类型。默认情况下，Kotlin 编译器不允许任何类型为空值。一般来说，当我们定义变量时，我们在声明的时候设置它们的值。

但是，在一些例外的情况下，你不想在声明的时候初始化变量。在这种情况下，当使用这些变量时，Kotlin 编译器会引起注意。例如:下面的代码将在 Kotlin 中给出一个错误信号:

```java
var msg:String = "Sample Message !!"
msg = null
var anotherMsg :String = null
```

用某个值初始化的变量不允许用空值重新赋值。同样，任何用 type 定义的变量(在我们的例子中是`String`)都不允许用 null 初始化。Kotlin 编译器有这个限制来避免`NullPointerException`，所以它会在编译时捕获这个错误，而不是导致运行时错误，导致突然的系统冲突。

Kotlin 希望我们在声明时初始化类型化变量。正如我们所说的，有些情况下我们必须用 null 来初始化变量，而 Kotlin 以不同的方式允许这样做，如下所示:

```java
var nullableMsg : String? = " I have some value ..!! "
println(nullableMsg)
nullableMsg=null
```

可空变量可以用一个问号来定义，这个问号的变量类型叫做**安全调用操作符**。您现在可以分配空值。但是，当我们定义一个可空变量并试图调用它的方法时，编译器将显示如下错误:

```java
var nullableMsg2 : String? = " I have some value ..!! "
println(nullableMsg2.length) // Compiler will show an error here.
```

这是因为 Kotlin 不允许在没有显式检查空值或以安全方式调用方法的情况下调用可空类型的方法。可以通过以下方式重写前面的代码以避免编译错误:

```java
//Correct ways to call nullable variable
if(nullableMsg2 !=null){
    println(nullableMsg2.length) // Option 1
}
println(nullableMsg2?.length) // Option 2
```

`nullableMsg2?`方法是调用可空变量的安全方法。如果变量为空，Kotlin 将自动绕过该调用并返回一个空值。在 Kotlin 中，这是一种更简洁的安全空值检查方法。但是，如果您希望确保返回该值，即使它是 null，那么您可以使用另一种方法，如下所示:

```java
println(nullableMsg2?.length ?: -1)
```

附加的问号和冒号(`?:`)被称为**猫王操作符**。它基本上类似于 if-else 块，如果不为 null 则返回长度。如果为空，那么它将返回`-1`。这基本上是三进制操作符的简称，比如`if(a) ? b : c`，但是更简洁、更紧凑。这将防止运行时出现任何意外`NullPointerException`。

# 数据类别

您可能已经创建了一个简单的数据容器类，没有特定的业务逻辑或功能。这种情况发生在遵循值对象或数据传输对象模式时。通常，此类如下所示:

```java
// Java code
public class StudentVOJava {
    private String name;
    private int age;
    private int standard;
    private String gender;
    public StudentVO(String name, int age, int standard, String gender) {
        this.name = name;
        this.age = age;
        this.standard = standard;
        this.gender = gender;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public int getStandard() {
        return standard;
    }
    public void setStandard(int standard) {
        this.standard = standard;
    }
    public String getGender() {
        return gender;
    }
    public void setGender(String gender) {
        this.gender = gender;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        StudentVO studentVO = (StudentVO) o;
        return age == studentVO.age &&
                standard == studentVO.standard &&
                Objects.equals(name, studentVO.name) &&
                Objects.equals(gender, studentVO.gender);
    }
    @Override
    public int hashCode() {
        return Objects.hash(name, age, standard, gender);
    }
    @Override
    public String toString() {
        return "StudentVO{" +
                "name='" + name + '\'' + ", age=" + age +
                ", standard=" + standard +
                ", gender='" + gender + '\'' +
                '}';
    }
}
```

这个类没有什么特别的，只有一些属性、getters、setters、constructor 以及`hashCode()`、`equals()`和`toString()`的实现。大量样板代码确实会分散任何业务功能。因此，代码的可读性、可搜索性和冗长性都降低了。

在现代 ide 的帮助下，只需点击几下鼠标就能生成这段代码，但仍然存在可读性问题。用 Kotlin 编写的相同代码不仅第一次看起来更整洁，而且有助于将重点放在枯燥的样板文件中的重要部分，如下所示:

```java
data class StudentVOKotlin(var name: String, var age: Int,
                           var standard: Int, var gender: String)
```

所有内容都包含在一行代码中，并且可读性更好。这样的声明将创建 setters、getters、constructor、`toString()`、`hashCode()`和`equals()`方法的实现，以及 Kotlin 幕后的其他有用功能。如果你想让你的类不可变，就用`val`而不是`var`来声明属性，如下所示:

```java
data class StudentVOKotlin(val name: String, val age: Int,
                           val standard: Int, val gender: String)
```

不可变变量可以用 Kotlin 中的`val`来定义。您现在只能调用`StudentVOKotlin`类的对象上的 getters。我们可以如下使用这个类:

```java
fun main(args: Array<String>) {
    var student = StudentVOKotlin("Nilang",10,5,"M")
    println("Student is  $student") // This will call toString()
    //This will call getter of respective properties
    println("age of ${student.name} is ${student.age}") 
}
```

这确实使代码简洁易读。

# 互用性

正如我们所见，Kotlin 与 Java 完全互操作，因此您可以在同一个项目中编写 Java 和 Kotlin 函数，并相互调用它们。让我们来理解这种神奇是如何发生的。在此之前，我们先来看看幕后的事情是如何发生的。

例如，您在`CheckOperability.kt`文件中编写了一个 Kotlin 函数，如下所示:

```java
fun greeting(name: String){
    print(" Hello $name !!!")
}
```

这段代码将由 Kotlin 编译器编译并转换成字节码。生成的 Java 类文件如下所示:

```java
public final class CheckInterOperabilityKt
{
  public static final void greeting(@NotNull String name)
  {
    //Some code for null type check added by Kotlin at this place.
    String str = " Hello " + name + " !!!";System.out.print(str);
  }
}
```

如您所见，Kotlin 将`.kt`文件(`CheckInterOperabilityKt.class`)转换成相应的 Java 类。Kotlin 中定义的`greeting()`函数也被转换成 Java 函数。默认情况下，Kotlin 中的所有函数都是静态的。此外，Kotlin 不会强迫你定义一个`void`，以防没有返回值。(科特林实际上用`Unit`代替了`void`。)转换时，它会将`void`和一个`static`关键字添加到函数中。

我们现在将看到如何从 Kotlin 调用 Java 代码，反之亦然。

# 从 Java 调用 Kotlin 代码

让我们创建一个 Kotlin 函数，它简单地将`KotlinFile.kt`文件中的两个给定数字相乘，如下所示:

```java
fun multiply(a:Int, b:Int):Int{
    print("Calling multiply function From Kotlin....")
    return a * b
}
```

我们想在 Java 类中调用一个 Kotlin `multiply()`函数。正如我们所知，Kotlin 编译器将这个文件处理成一个 Java 类，其中它将`multiply()`方法定义为`KotlinFileKt.class`生成的类文件的静态方法，这样就可以用`KotlinFileKt.multiply()`表达式访问它。

如果您希望更改 Kotlin 源代码中的 Java 类文件名，您需要在 Kotlin 文件中将其定义为`@file:JvmName("CustomKotlinFile")`。在这种情况下，Kotlin 编译器将生成`CustomKotlinFile.class`文件，并且可以通过`CustomKotlinFile.multiply()`调用来访问该函数。

让我们首先添加 Java 类并调用 Kotlin 函数，如下所示:

```java
public class JavaFile {
    public  static void  main(String args[]){
        System.out.print(KotlinFileKt.multiply(3,4));
    }
}
```

这就是从 Java 类中调用 Kotlin 函数的方式。现在让我们看看如何从 Kotlin 调用 Java 函数。

# 从 Kotlin 调用 Java 代码

让我们定义一个函数，它简单地将 Java 文件中的两个数字相加，如下所示:

```java
public static int add(int num1, int num2){
    return num1+num2;
}
```

这可以在 Kotlin 文件中调用，就像我们在 Java 中调用 Kotlin 代码一样。由于这是一个静态函数，我们可以用 Kotlin 中的 Java 类调用它，如下所示:

```java
fun main(args: Array<String>) {
    var total = JavaFile.add(5,6)
    print("Value from Java is $total")
}
```

Kotlin 中的`main`函数代表类似 Java 中的`public static void main()`的执行点。

# 智能转换

使用 Java 时，您可能会遇到需要在进一步处理之前转换对象的情况。然而，即使您传递的对象类型是确定的，您仍然需要在 Java 中显式地转换对象，如下所示:

```java
//Java code
public static void  main(String[] args){
    Object name = "Nilang";
    if(name instanceof String){
        greetingMsg((String) name);
    }
}
private static void greetingMsg(String name){
    System.out.print(" Welcome "+name+" ..!!");
}
```

如果我们试图在没有显式强制转换的情况下调用`greetingMsg()`，Java 编译器将显示一个错误，因为`name`变量属于`Object`类型。在这种情况下，虽然编译器知道`name`只能是`String`类型(通过条件`if(name instanceOf String)`)，但是 Java 编译器需要显式的强制转换。换句话说，我们需要进行造型，尽管这实际上是多余的。

但是，在 Kotlin 的情况下，如果一个参数被证明是所需的类型，则不需要进行显式强制转换。这段代码可以用 Kotlin 编写如下:

```java
//Kotlin code
fun main(args: Array<String>) {
    val name: Any = "Nilang"
    if(name is String) {
        greetingMsg(name)
    }
}
private fun greetingMsg(name: String) {
    print(" Welcome $name ..!!")
}
```

Kotlin 中的`Any`类型相当于 Java 中的`Object`。在这段代码中，编译器知道给`greetingMsg`函数的输入只能是`String`类型(带有`if`条件)，所以不需要显式强制转换。这在科特林叫**聪明** **施法**。

# 运算符重载

运算符重载是 Kotlin 的另一个便利特性，这使得它更具表现力和可读性。它允许您使用`+`、`-`、`*`、`/`、`%`、`<`、`>`等标准符号对任何对象进行各种操作。在幕后，操作符重载启动一个函数调用来执行各种数学运算、比较、数组索引操作等等。

int、byte、short、long、double、float 等类为每个操作符定义了相应的函数。例如:如果我们对一个整数做`a+b`，Kotlin 将内部调用`a.plus(b)`如下:

```java
var num1 = 10
var num2 = 5
println(num1+num2)
println(num1.plus(num2))
```

两个打印语句显示相同的结果。我们可以通过重载相应的函数来定义操作符如何为自定义类工作。例如，我们有一个名为`CoordinatePoint`的类，它表示图中给定点的 x 和 y 坐标。如果我们想覆盖这个类的操作符，那么它应该编码如下:

```java
data class CoordinatePoint(var xPoint: Int, var yPoint: Int){
    // overloading + operator with plus function
    operator fun plus(anotherPoint: CoordinatePoint) : CoordinatePoint {
        return CoordinatePoint(xPoint + anotherPoint.xPoint, yPoint + anotherPoint.yPoint)
    }
    // overloading - operator with minus function
    operator fun minus(anotherPoint: CoordinatePoint) : CoordinatePoint {
        return CoordinatePoint(xPoint - anotherPoint.xPoint, yPoint - anotherPoint.yPoint)
    }
}
fun main(args: Array<String>) {
    var point1 = CoordinatePoint(2,5)
    var point2 = CoordinatePoint(4,3)

    //This will call overloaded function plus()
    var point3 = point1 + point2 

   //This will call overloaded function minus()
    var point4 = point1 - point2

    println(point3)
    println(point4)
}
```

`CoordinatePoint`类是我们的自定义类，`plus()`和`minus()`函数实际上是在这个类的对象和相应的操作符一起使用时被调用的。`operator`关键字用于将相应的函数与运算符相关联。

除了算术之外，Kotlin 还支持其他运算符，如**索引访问**运算符、中的**运算符、**调用**运算符、**自变量** **赋值**运算符、**等于**运算符、**函数**运算符等等。通过操作符重载，这段代码更加简洁，当然也更加清晰。**

# 科特林对 Java

在经历了 Kotlin 的特性丰富性之后，将其与 Java 进行比较会非常有帮助。这并不是要证明某一种语言比另一种更合适，而是要列出不同之处，以便在不同的情况下更容易做出选择:

*   空安全:Kotlin 提供了一种定义和处理可空类型的好方法，而 Java 没有现成的类似特性。
*   **扩展函数** : Java 需要一个继承来扩展类，而 Kotlin 允许你在不继承任何类的情况下定义扩展函数。您也可以为自定义类定义一个扩展函数。
*   类型引用:在 Java 中，我们需要明确地指定变量的类型，但是 Kotlin 会根据赋值来处理它，所以你不必在所有的场景中定义类型。
*   **函数式编程** : Kotlin 是一种函数式语言，为函数提供了很多有用的特性。另一方面，Java 已经开始支持 lambda 表达式。
*   协程支持:协程是轻量级线程，用于处理异步、非阻塞代码。Kotlin 支持开箱即用的协程。协同例程由用户管理。另一方面，Java 支持由底层操作系统管理的多线程的类似功能。

*   **数据类**:在 Java 中，我们需要手动声明构造函数、getters、setters、`toString()`、`hashCode()`和`equals()`，而 Kotlin 在幕后完成所有这些工作。
*   **智能强制转换** : Java 需要显式检查强制转换，而 Kotlin 智能地完成了这项工作。
*   **检查异常** : Java 支持检查异常，而 Kotlin 不支持。

# Kotlin Spring 支架

由于其惊人的特性，Kotlin 迅速流行起来，许多框架已经开始支持它。从版本 5 开始，Spring 框架允许使用 Kotlin 开发 Spring 应用。虽然 Kotlin 完全可以与 Java 互操作，但是您可以用纯粹的、完全符合习惯的 Kotlin 代码编写应用。Kotlin 的各种特性提高了生产率，并与 Spring 很好地结合起来进行应用开发。

正如我们所看到的，Kotlin 中的扩展函数是一种非侵入性的方式，它为实用程序类提供了更好的替代方案，或者为添加新功能创建了一个类层次结构。Spring 利用这个特性将新的 Kotlin 特定功能应用到现有的 Spring APIs 中。它主要用于依赖关系管理。同样，Spring 也让框架 APIs null safe 充分利用了 Kotlin。

从 2.x 版本开始，甚至 Spring Boot 也有一流的 Kotlin 支持。这意味着您可以用 Kotlin 编写基于 Spring 的应用，就好像 Spring 是 Kotlin 的原生框架一样。2018 年 10 月发布的 Kotlin 当前版本为 1.3，Spring 支持 Kotlin 1.1 及更高版本。

# 开发应用-任务管理系统

本章旨在与 Spring Boot 和科特林一起创建一个名为**任务管理系统** ( **TMS** )的应用。在前几章中，我们用 Java 创建了各种应用。在这一节中，我们将学习如何和 Spring Boot 一起用 Kotlin 开发基于 Spring 的应用。

通过 TMS，我们将实现以下功能:我们不再开发功能全面的应用，而是关注如何在开发基于 Spring 的应用时利用 Kotlin 的功能:

*   任务创建和分配给用户。
*   管理员用户查看、更新和删除任务。
*   由任务被分配到的管理员和普通用户向给定任务添加注释。
*   使用 Spring Security 实现身份验证和授权。
*   为了简单起见，我们将公开 REST 服务来添加用户。将有一个管理员用户和一个或多个普通用户。

# 与科特林一起创建 Spring Boot 项目

第一件事是通过 Spring Boot 初始化器创建一个项目结构。在前面的所有章节中，我们在**Spring Tool Suit**(**STS**—一个基于 Eclipse 的 IDE)中创建了一个项目结构。还有一种方法可以从网络上创建它。进入 https://start.spring.io/网址[，填写如下数据:](https://start.spring.io/)

![](assets/b2d965e3-a06a-4333-b41c-5bbe1b59bdce.png)

确保选择 Kotlin 作为编程语言选项，同时选择最新稳定的 Spring Boot 版本(目前为 2.1.2)。另外，按如下方式选择依赖关系:

*   JPA:用于通过 **Java 持久性 API** ( **JPA** )与数据库交互
*   Web:添加 Spring **模型-视图-控制器** ( **MVC** )具体特性
*   安全性:添加 Spring 安全性功能所必需的

*   DevTools:在代码改变时实时重载
*   百里香叶:使用百里香叶模板设计视图
*   MySQL:与 MySQL 数据库交互的 Java 连接器

单击 Generate Project 按钮，您将看到一个应用结构被下载为一个 ZIP 包。在你的本地机器上解压就行了。到目前为止，我们已经在前面的章节中使用 STS——一个 Eclipse IDE——作为开发各种应用的 IDE。然而，为了获得更全面的体验，我们将在本章中使用 IntelliJ IDEA(一个著名的支持 Kotlin 的 IDE 原生程序)。

IntelliJ IDEA 有两个版本:社区版和终极版。前者可免费用于基于 JVM 和 Android 的开发，而后者用于 web 和企业开发，支持更多特性。它适用于流行的操作系统——Windows、macOS 和 Linux。我们将使用社区版本。从[https://www.jetbrains.com/idea/download](https://www.jetbrains.com/idea/download)网址下载，并安装在你的本地机器上。

要导入项目，请打开 IntelliJ IDEA IDE，选择 File | Open 菜单，然后选择我们从 Spring initializer 下载的解压缩项目结构文件夹。您将在基于 Kotlin 的 Spring 应用中看到的第一个区别是文件夹结构。与标准的基于 Java 的应用的`src/main/java` 相比，Kotlin 源代码将驻留在`src/main/kotlin`中。

为了支持 Kotlin，Spring 需要某些依赖项，这些依赖项在从 Spring 初始化器生成时会自动添加到`pom.xml`中。您将看到 Kotlin 特定的依赖关系如下:

```java
<dependency>
   <groupId>org.jetbrains.kotlin</groupId>
   <artifactId>kotlin-reflect</artifactId>
</dependency>
<dependency>
   <groupId>org.jetbrains.kotlin</groupId>
   <artifactId>kotlin-stdlib-jdk8</artifactId>
</dependency>
<dependency>
   <groupId>com.fasterxml.jackson.module</groupId>
   <artifactId>jackson-module-kotlin</artifactId>
</dependency> 
```

Kotlin 1.2 和更高版本需要`kotlin-stdlib-jdk8`依赖项。对于 Kotlin 1.1，需要使用`kotlin-stdlib-jre8`。Kotlin-reflect 是 Kotlin 中使用的反射功能。

# 数据库设计

为了存储与任务相关的数据，我们将使用 MySQL 数据库。我们还将在数据库表中存储用户和角色信息。这些表及其关系的详细信息如下所示:

![](assets/7735aa6d-919b-4860-9a9d-53929f0626f6.png)

该表的详细信息如下:

*   **任务:**该表存储了添加到系统中的任务的详细信息。它与**评论**表有一对多的关系。
*   **评论:**当用户输入一条**任务**评论时，它将被添加到该表中。
*   **用户:**这是一个存储用户详细信息的主表。它与表**角色**有多对多的关系。它与**任务**和**评论**表也有一对多的关系。
*   **角色:**这是角色的主表。主要有两个角色——`ROLE_USER`和`ROLE_ADMIN`。它与表**用户**有多对多的关系。
*   **user_role:** 这是一个链接表，将存储**角色**和**用户**的关联数据。

# 实体类

我们将使用 Spring Data JPA 与数据库进行交互，因此首先我们需要编写实体类。实体类将被映射到数据库表，其属性被映射到表列。JPA 实体类是一个用户定义的 POJO 类，它只是一个普通的 Java 类，带有特定于 JPA 的注释，能够在数据库中呈现对象。

我们将为每个表创建一个单独的实体类，除了链接表 **user_role** ，它是用`@ManyToMany`注释处理的。具体如下。

# 用户

`users`表的实体类应该如下所示:

```java
@Entity
@Table(name="users",catalog="task_mgmt_system")
class User {
    @Id
    @GeneratedValue(strategy= GenerationType.IDENTITY)
    @Column(name = "id")
    private var id:Int? = null

    @Column(name="username")
    private var username : String? = null

    @Column(name="password")
    private var password : String? = null

    @Column(name="firstname")
    private var firstname : String? = null

    @Column(name="lastname")
    private var lastname : String? = null

    @Column(name="enabled")
    private var enabled : Boolean = false

    @ManyToMany(cascade = [CascadeType.PERSIST],fetch = FetchType.EAGER)
    @JoinTable(
            name = "user_role",
            joinColumns = [JoinColumn(name = "user_id",referencedColumnName = "id") ],
            inverseJoinColumns = [JoinColumn(name = "role_id",referencedColumnName = "id")]
    )
    private var roles: Set<Role>? = null

    @OneToMany
    @JoinColumn(name ="user_id")
    private var comments : MutableSet<Comments>? = null

  //.... Getters and Setters
}
```

`@Entity`注释用于声明该类是一个 JPA 实体。`@Table`注释用于将类映射到特定的数据库表。这个类的属性被映射到带有`@Column`注释的各个列。这些属性被定义为可空的，因为它们将在运行时被填充。

`@JoinTable`注释用于声明链接表，而`JoinColumn`用于定义与链接表相关联的多对多关系的表之间的列引用。Kotlin 中的多对多关系声明与 Java 中的略有不同。相同的配置在 Java 中声明如下:

```java
@ManyToMany(cascade = CascadeType.PERSIST,fetch = FetchType.EAGER )
@JoinTable(
   name = "user_role",
   joinColumns = @JoinColumn(name = "user_id",referencedColumnName = "id"),
   inverseJoinColumns = @JoinColumn(name = "role_id",referencedColumnName = "id")
)
```

这里明显的区别是`@JoinTable`注释的`joinColumns`属性的声明。在 Java 中，它是用注释声明的，而在 Kotlin 中，它被定义为一个数组。另一个区别是在`@ManyToMany`注释中定义了`cascade`属性。

# 作用

对应于`role`表的实体类如下所示:

```java
@Entity
@Table(name="role",catalog="task_mgmt_system")
class Role {
    @Id
    @GeneratedValue(strategy= GenerationType.IDENTITY)
    @Column(name = "id")
    private var id:Int? = null

    @Column(name="role")
    private var role : String? = null

    @ManyToMany(mappedBy = "roles",cascade = [CascadeType.PERSIST])
    private var users:Set<User>? = null
 // ... Getters and Setters
}
```

在`User`和`Role`实体之间的多对多关系中，所有权属于`User`实体，因此`Role`实体中的`@ManyToMany`注释用`mappedBy`属性定义。

# 工作

与`task`表相关联的实体类应该如下所示:

```java
@Entity
@Table(name="task",catalog="task_mgmt_system")
class Task {
   @Id
   @GeneratedValue(strategy=GenerationType.IDENTITY)
   @Column(name = "id")
   private var id :Int?=null

   @Column(name="title")
   private var title : String? = null

   @Column(name="detail")
   private var detail : String? = null

   @Column(name="assigned_to")
   private var assignedTo : Int? = null

   @Column(name="status")
   private var status : String? = null

   @OneToMany
   @JoinColumn(name ="task_id")
   private var comments : MutableSet<Comments>? = null

  // .. Getters and Setters
}
```

`@OneToMany`注释用于声明与`comments`表的一对多关系。`@JoinColumn`注释用于声明`comments`表中的列引用。

# 评论

`comments`表的实体类应该如下所示:

```java
@Entity
@Table(name="comments",catalog="task_mgmt_system")
class Comments {
   @Id
   @GeneratedValue(strategy=GenerationType.IDENTITY)
   private var id :Int?=null

   @ManyToOne
   @JoinColumn(name = "user_id",nullable = false)
   private var user : User? = null

   @ManyToOne
   @JoinColumn(name = "task_id", nullable = false)
   private var task : Task? = null;

   private var comment:String? = null

  // .. Getters and Setters
}
```

`@ManyToOne`注释用于声明与**任务**表的多对一关系。`@JoinColumn`注释用于定义引用列(主键)。

# Spring 安全

Spring Security 是在基于 Spring 的应用中实现安全约束的事实上的标准。在前面的章节中，我们在实现用户认证和授权时使用了带有内存模型的 Spring Security。内存模型只应用于测试目的。在真实的场景中，从其他系统获取身份验证和授权细节，使其与应用代码松散耦合，如 LDAP、OAuth 等。

在[第三章](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml)、*Blog press——一个简单的博客管理系统*中，我们详细学习了如何用 LDAP 和 OAuth 配置 Spring 安全。在本章中，我们将使用数据库表来存储认证和授权的详细信息。首先，让我们创建一个类，并如下定义安全配置:

```java
@Configuration
@EnableWebSecurity
@ComponentScan("com.nilangpatel.tms.security")
class WebSecurityConfig : WebSecurityConfigurerAdapter() {

    @Throws(Exception::class)
    override fun configure(web: WebSecurity){
        web.ignoring().antMatchers("/js/**")
        web.ignoring().antMatchers("/css/**")
    }

   @Throws(Exception::class)
   override fun configure(http: HttpSecurity) {
    // .... HttpSecurity specific configuration
   }
}
```

这是典型的安全配置。我们为 Kotlin 声明注释的方式类似于我们对 Java 所做的。但是，存在以下差异:

*   在 Kotlin 中，我们可以使用冒号(`:`)来声明继承。`WebSecurityConfigurerAdapter`类是一个父类，但令人惊讶的是它是一个 Java 类。您可以从另一个 Java 类扩展您的 Kotlin 类，这绝对没问题。这就是 Kotlin 与 Java 深度互操作的方式。另一个区别是父类与构造函数符号(带括号)一起使用。
*   为了覆盖父类的方法，Kotlin 使用了`override`关键字。
*   因为 Kotlin 不直接支持检查异常，所以使用了`@Throws`注释来定义异常细节。

接下来，需要为系统中的各个页面配置访问机制。这可以通过重写 configure 方法来实现，它基本上提供了一个 HTTP 特定的安全配置。它看起来如下:

```java
@Throws(Exception::class)
override fun configure(http: HttpSecurity) {
    http.authorizeRequests()
        .antMatchers("/","/login","/api/register").permitAll()
        .antMatchers("/controlPage/**","/getAllUsers/**",
            "/allTaskList/**","/addTaskComment/**","/viewTask/**")
            .hasAnyAuthority(TaskMgmntConstant.ROLE_USER,TaskMgmntConstant.ROLE_ADMIN)
        .antMatchers("/showAddTask/**","/showEditTask/**",
                    "/addTask/**","/updateTask/**","/deleteTask/**")
            .hasAnyAuthority(TaskMgmntConstant.ROLE_ADMIN)
        .and()
     .formLogin().loginPage("/login").permitAll()
        .defaultSuccessUrl("/controlPage",true)
        .failureUrl("/login?error=true")
     .and().csrf().disable()
        .logout()
        .permitAll().logoutSuccessUrl("/login?logout=true")
}
```

这里值得注意的是，我们已经为所有用户配置了各种可访问的 URL，即使没有登录，只有管理员需要登录。我们还配置了登录、成功和失败 URL 以及注销 URL。我们将在*定义 Spring MVC 控制器*一节中详细讨论它们。

现在，我们将配置一个身份验证机制。Spring 支持各种选项，比如内存中、LDAP、OAuth 等等。对于这个应用，我们将从数据库中获取用户详细信息。要实现数据库的 Spring 安全性，有两种方法。

# 查询方法

Spring Security 需要用户及其角色细节来执行安全检查。在这种方法中，我们将使用 SQL 查询获取用户和角色的详细信息。我们将在`application.properties`文件中如下定义一个查询:

```java
spring.queries.users-query= select username, password, enabled from users where username=?
spring.queries.roles-query= select u.username, r.role from users u inner join user_role ur on(u.id=ur.user_id) inner join role r on(ur.role_id=r.id) where u.username=?
```

第一个查询获取用户详细信息，而第二个查询检索给定用户名的角色列表。这些属性可以在`WebSecurityConfig`类中读取，如下所示:

```java
@Value("\${spring.queries.users-query}")
private val usersQuery: String? = null

@Value("\${spring.queries.roles-query}")
private val rolesQuery: String? = null
```

在 Kotlin 中，符号`$`用于打印`String`中的变量，而没有显式使用`+`操作符。因为我们想从`application.properties`文件中读取属性，我们必须使用转义符(`\`)和`$`操作符。除此之外，变量被声明为可空的(用`String?`)，因为它们将在运行时被 Spring 填充。

接下来，我们将覆盖`configure()`方法来定义认证配置，如下所示:

```java
@Throws(Exception::class)
override fun configure(auth: AuthenticationManagerBuilder?) {
    auth!!.jdbcAuthentication()
            .usersByUsernameQuery(usersQuery)
            .authoritiesByUsernameQuery(rolesQuery)
            .dataSource(dataSource)
            .passwordEncoder(passwordEncoder())
}
```

IntelliJ IDEA 的好处是，无论何时你传递任何 Java 代码，它都会提示转换成 Java。选择 yes，它会自动将 Java 代码转换成 Kotlin 代码。`!!`符号是非空断言操作符，它基本上将任何值转换为非空类型，如果变量为空，则抛出`NullPointerException`。这是 Kotlin 的无效安全功能的一部分。`dataSource`和`passwordEncoder`方法可以定义如下:

```java
@Autowired
private var dataSource: DataSource? = null

@Bean
fun passwordEncoder(): BCryptPasswordEncoder {
    return BCryptPasswordEncoder()
}
```

在运行时，`dataSource`将被 Spring 注入，所以它必须被声明为可空的(用`?`)。我们将使用`BCryptPasswordEncoder`和`bcrpt`算法对密码进行编码，这被认为是一种非常强大的编码算法。

不一定需要`userQuery`和`roleQuery`对象。如果您没有提供它们，那么您需要使用预定义的名称和列来设计表。用户表必须用一个名称— `users`创建，并带有列`username`、`password`和`enabled`，而**角色**表必须用一个名称— `authorities`创建。

这种方法有一定的限制。例如:`userQuery`必须以相同的顺序返回`username`、`password`和`enabled`列值，`roleQuery`必须以相同的顺序返回`username`和`role name`。如果这个序列发生任何变化，它可能无法正常工作。

# 用户详细信息服务方法

获取使用和角色信息的另一种方法是使用`UserDetailsService`接口。这是一种提取身份验证和授权细节的抽象方法。它有一个方法——`loadUserByUsername()`，将基于`username`返回用户详细信息。您可以覆盖它并编写自己的逻辑来检索用户详细信息。

Spring 提供了一个名为`DaoAuthenticationProvider`的类，它基本上使用`UserDetailsService`实现在认证过程中获取用户详细信息。这种方法的灵活性意味着我们可以定义一个定制的方法来获取用户的详细信息。我们将在 JPA 存储库中为`User`实体定义一个方法。JPA 是用 Java 对象与关系数据库交互的标准方式。该存储库如下所示:

```java
@Repository
interface UserRepository : JpaRepository<User, Int> {
   fun findByUsername(username: String): User?
}
```

`UserRepository`是一个 Kotlin 接口，它扩展了 Java `JpaRepository`接口。`@Repository`注释用于将该接口声明为 JPA 存储库。`findByUsername`方法是一个查询方法，它将获取用户。Spring Data JPA 有一个基于存储库方法名的内置查询构建机制。

对于`findByUsername`方法，它将首先删除前缀`findBy`,并用方法名的其余部分组成查询。在这种情况下，它会在内部创建一个查询，比如`select * from users where username=?`。这个方法返回一个`User`实体类的对象。接下来，我们需要提供一个定制的用户服务，为此我们将如下实现`UserDetailsService`:

```java
@Service
class CustomUserDetailsService : UserDetailsService {

    @Autowired
    private val userRepository: UserRepository? = null

    @Throws(UsernameNotFoundException::class)
    override fun loadUserByUsername(username: String): UserDetails {
      val user = userRepository?.findByUsername(username) ?: 
                     throw UsernameNotFoundException(username)
      return CustomUserPrinciple(user)
    }
}
```

用一个`@Service`注释声明了`CustomUserDetailsService`类，以将其声明为服务组件。它覆盖了一个`loadUserByUsername()`方法，在这里我们可以编写自定义逻辑来获取用户详细信息。我们创建的存储库`findByUsername()`方法在这里用于获取用户详细信息。

返回类型是`UserDetails`,它是一个实际存储用户信息的接口，用户信息随后被封装，以便稍后对对象进行身份验证。我们创建了一个`CustomUserPrinciple`类来提供`UserDetails`的实现，如下所示:

```java
class CustomUserPrinciple : UserDetails {
    constructor(user: User?) {
        this.user = user
    }
    private var user:User? = null

    override fun isEnabled(): Boolean {
        return true
    }
    override fun getUsername(): String {
        return this.user?.getUsername() ?: ""
    }
    override fun isCredentialsNonExpired(): Boolean {
        return true
    }
    override fun getPassword(): String {
       return this.user?.getPassword() ?: ""
    }
    override fun isAccountNonExpired(): Boolean {
        return true
    }
    override fun isAccountNonLocked(): Boolean {
        return true
    }
    override fun getAuthorities(): MutableCollection<out GrantedAuthority> {
         var userRoles:Set<Role>? = user?.getRoles() ?: null
         var authorities:MutableSet<GrantedAuthority> = HashSet<GrantedAuthority>()
         for(role in userRoles.orEmpty()){
             authorities.add(CustomGrantedAuthority(role))
         }
         return authorities
    }

}
```

`UserDetails`接口需要实现某些方法，如下所示:

*   `isEnable()`:这个方法基本上返回用户是否被激活。在实际场景中，必须有一个单独的数据库列来检查用户是否被启用。为了简单起见，我们简单地返回`true`,假设所有用户都被启用。如果用户返回`false`，Spring Security 将不允许登录。
*   `getUsername()`:这只是返回用户名。
*   `isCredentialsNonExpired()`:这是一个非常有用的方法，当你想对用户施加一个约束，让用户在一定的时间限制后更新密码。在这个方法中，您需要根据您的要求检查密码是否过期，并相应地返回值。为了简单起见，如果我们返回`true`，就意味着密码还没有过期。
*   应该会返回密码。
*   `isAccountNonExpired()`:表示用户账号是否过期。为了简单起见，我们只返回`true`。
*   `isAccountNonLocked()`:用于检查用户账号是否被锁定。同样，为了简单起见，我们只返回`true`。
*   `getAuthorities()`:该方法返回授予用户的权限。我们从用户对象中检索角色，并将它们包装在一个`GrantedAuthority`类型中。`GrantedAuthority`是一个接口。我们通过`CustomGrantedAuthority`类提供了一个实现，如下所示:

```java
class CustomGrantedAuthority : GrantedAuthority{
    private var role:Role?=null
    constructor( role:Role ){
        this.role = role
    }
    override fun getAuthority(): String {
        return role?.getRole() ?: ""
    }
}
```

*   我们通过构造函数注入一个用户对象，该对象可用于在每个方法中检索进一步的细节。

最后一部分是定义 Spring 安全配置。向`WebSecurityConfig`类添加方法，如下所示:

```java
@Throws(Exception::class)
override fun configure(auth: AuthenticationManagerBuilder?) {
    auth!!.authenticationProvider(authenticationProvider())
}

@Bean
fun authenticationProvider(): DaoAuthenticationProvider {
    val authProvider = DaoAuthenticationProvider()
    authProvider.setUserDetailsService(userDetailService)
    authProvider.setPasswordEncoder(passwordEncoder())
    return authProvider
}
```

`authenticationProvider()`方法简单地创建一个`DaoAuthenticationProvider`类型的对象，用用户详细信息服务对象和密码编码器对其进行配置，然后返回。然后在`configure()`方法中使用它来设置身份验证提供者。`UserDetailService`的对象可以在同一个类中注入，如下所示:

```java
@Autowired
private var userDetailService: CustomUserDetailsService? = null
```

这种方法更加灵活，允许以定制的方式获取用户详细信息，然后由 Spring 使用这些信息来执行各种安全约束。它只是将身份验证和授权逻辑从获取用户详细信息的机制中分离出来。这使得系统更加灵活。

# 定义 Spring MVC 控制器

我们的后端层已经准备好了，现在我们将设计控制器和视图层。我们决定在前端使用 Spring MVC，这是最适合基于 web 的 Spring 应用的。Kotlin 中 Spring MVC 控制器的声明类似于我们在 Java 中所做的，如下所示:

```java
@Controller
class TaskMgmtSystemController {

// Controller methods...
}
```

Kotlin `TaskMgmtSystemController`类是用`@Controller`注释声明的，该注释用于将该类定义为 Spring MVC 控制器。Kotlin 中定义控制器方法的方式也与 Java 类似。例如:可以通过以下控制器方法显示主页:

```java
@GetMapping("/")
fun showHomePage(model: Model): String  {
   logger.info("This will show home page ")
   setProcessingData(model, TaskMgmntConstant.TITLE_HOME_PAGE)
   return "home"
}
```

这个方法被映射到`/` URL(可以在 [http://localhost:8080](http://localhost:8080) 访问)并返回一个主页。如前所述，我们将使用百里香模板来构建一个视图层。

如果你对百里香不是很熟悉，它是一个用来产生视图的自然模板引擎，视图是在服务器端处理的。在本书的[第三章](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml)*《Blog press——一个简单的博客管理系统》*中有详细的解释。你可以参考它来了解百里香是如何与 Spring 一起工作的。

我们还定义了常量来访问预定义的值。与 Java 不同，我们不能在 Kotlin 接口中定义常量。为了定义常量，我们将使用单例类。在 Kotlin 中，我们可以通过对象声明特性创建一个 singleton 类。这可以通过关键字`object`来实现。`TaskMgmntConstant`单例类如下所示:

```java
object TaskMgmntConstant {
   const val ROLE_USER :String = "ROLE_USER"
   const val ROLE_ADMIN :String = "ROLE_ADMIN"
   const val TITLE_HOME_PAGE: String = "Home"
   const val TITLE_LOGIN_PAGE: String = "Login"
   const val TITLE_LANDING_CONTROL_PAGE:String = "Control Page"
   const val TITLE_ADD_TASK_PAGE:String = "Add Task"
   const val TITLE_UPDATE_TASK_PAGE:String = "Update Task"
   const val PAGE_TITLE: String = "pageTitle"
}
```

虽然这里没有使用`class`关键字，但是这段代码同时结合了`class`和 singleton 声明。在内部，Kotlin 将创建一个`TaskMgmntConstant`类的静态实例。`object`声明也可以包含函数，可以用`object`声明名直接访问。这类似于在 Java 中访问类类型的静态变量和方法。

`const`关键字用于定义常量。用`const`关键字声明的变量是编译时常量，这意味着它们必须在编译时被填充。因此，它们不能赋给函数或类构造函数，而只能赋给字符串或原语。

接下来，我们将看到如何为其他操作定义控制器方法，如下所示。

# 显示控制页面

当用户登录时，系统将进入一个叫做控制页面的页面。在此页面中，用户可以查看任务，并根据他们拥有的角色执行各种操作。例如:普通用户可以看到分配给它的任务列表，还可以为特定任务添加注释。管理员用户可以添加新任务、编辑和删除现有任务。这个控制器方法只是将用户重定向到登录(或控制)页面。代码如下所示:

```java
@GetMapping("/controlPage")
fun showControlPage(model:Model):String {
   logger.info("Showing control page ")
    setProcessingData(model, TaskMgmntConstant.TITLE_LANDING_CONTROL_PAGE)
    return "control-page"
}
```

在 *Spring Security* 部分，我们配置了普通用户和管理员用户都可以访问的`/controlPage`。不登录就无法访问。

# 显示登录页面

这个控制器方法会将用户重定向到登录页面。它看起来如下:

```java
@GetMapping("/login")
fun showLoginPage(@RequestParam(name = "error",required = false) error:String? ,
      @RequestParam(name = "logout", required = false) logout:String?, model:Model):String  {
   logger.info("This is login page URL   ")
   if (error != null) {
      model.addAttribute("error", "Invalid Credentials provided.")
   }
   if (logout != null) {
      model.addAttribute("message", "Logged out")
   }
   setProcessingData(model, TaskMgmntConstant.TITLE_LOGIN_PAGE);
   return "login"
}
```

可以从导航菜单中访问它。此方法还在凭据无效的情况下处理错误，并向用户显示适当的消息。

# 显示“添加新任务”页面

添加新任务功能被配置为仅允许管理员用户。它会将用户重定向到添加新任务页面。代码如下所示:

```java
@GetMapping("/showAddTask")
fun showAddTask(model:Model):String {
   logger.info("Going to show Add task page")
   setProcessingData(model, TaskMgmntConstant.TITLE_ADD_TASK_PAGE)
   return "task-add"
}
```

`/showAddTask` URL 被配置为控制页面中的导航菜单。

# 显示编辑任务页面

只有管理员用户可以编辑现有任务。管理员用户可以在任务列表屏幕上看到每个任务记录的编辑按钮。一旦点击它，这个方法就会被触发。看起来是这样的。

```java
@GetMapping("/showEditTask")
fun showEditTask(@RequestParam(name = "taskId",required = true) taskId: Int,
      model:Model):String {
   val task:Task? = taskRepository?.findById(taskId)?.get()
   if(task !=null){
      val userId: Int = task.getAssignedTo() ?: 0
      val user:User? = userRepository?.findById(userId)?.get()
      val taskDto = TaskDTO(task.getId(),task.getTitle(),
            task.getDetail(),userId,(user?.getFirstname() + " "+user?.getLastname()),task.getStatus(),null)
      model.addAttribute("task",taskDto)
   }
   logger.info("Going to show Edit task page")
   setProcessingData(model, TaskMgmntConstant.TITLE_UPDATE_TASK_PAGE)
   model.addAttribute("screenTitle","Edit Task")
   return "task-edit"
}
```

`taskId`参数将作为请求参数从任务列表屏幕发送。首先，我们用`taskRepository`从给定的`taskId`获取任务对象，然后将其复制到`TaskDTO`对象。你可以看到我们已经用`val`关键字声明了变量，该关键字用于声明常量。Kotlin 建议使用`val`，以防变量在赋值后没有改变。`TaskDTO`类是在 Kotlin 中定义的数据类，如下所示:

```java
class TaskDTO( var id :Int?, var title : String?,
               var detail : String?, var assignedTo : Int?, var assignedPerson:String?,
               var status : String?, var comments : Set<Comments>?)
```

编辑任务屏幕如下所示:

![](assets/95e80311-3475-48d1-93f3-96d63fb1f4bd.png)

# 添加新任务

只有管理员用户可以添加新任务。这个控制器方法将在数据库中插入任务记录。它看起来如下:

```java
@PostMapping("/addTask")
fun addTask(@RequestParam(name = "title",required = true) title:String,
         @RequestParam(name = "detail",required = true) detail:String,
         @RequestParam(name = "selectedUserId", required = true) selectedUserId:Int,
      model:Model):String {
   val task = Task()
   task.setTitle(title)
   task.setDetail(detail)
   task.setAssignedTo(selectedUserId)
   task.setStatus(TaskStatus.PENDING.getStatus())
   taskRepository?.save(task)

   logger.info("Goint to show Add task page")
   setProcessingData(model, TaskMgmntConstant.TITLE_ADD_TASK_PAGE)
   model.addAttribute("screenTitle","Add new Task")
   return "redirect:allTaskList"
}
```

从添加任务屏幕提供`title`、`detail`和`userId`参数(任务分配给谁)。这个方法简单地创建了一个`Task`类的实例，填充了它的值，并保存在`taskRepsitory`中。与 Java 不同，在 Kotlin 中可以不使用`new`关键字来创建实例。此外，Kotlin 尽可能推迟变量的类型。例如，我们没有定义`task`变量的类型，因为它被赋予了`Task`类型类的对象，所以 Kotlin 认为它只是`Task`类型。

我们不是重定向到一个特定的页面，而是重定向到另一个带有`/allTaskList` URL 模式的控制器方法，它基本上显示了一个任务列表。

# 更新任务

更新任务类似于添加新的任务方法。只有管理员用户可以更新现有任务。该方法如下所示:

```java
@PostMapping("/updateTask")
fun updateTask(@RequestParam(name = "taskId",required = true) taskId:Int,
         @RequestParam(name = "title",required = true) title:String,
         @RequestParam(name = "detail",required = true) detail:String,
         @RequestParam(name = "selectedUserId", required = true) selectedUserId:Int,
         model:Model):String {
   val task:Task? = taskRepository?.findById(taskId)?.get()
   if(task !=null) {
      task.setTitle(title)
      task.setDetail(detail)
      task.setAssignedTo(selectedUserId)
      taskRepository?.save(task)
   }

   logger.info("Going to show Add task page")
   model.addAttribute("screenTitle","Edit Task")
   setProcessingData(model, TaskMgmntConstant.TITLE_ADD_TASK_PAGE)
   return "redirect:allTaskList"
}
```

代码看起来类似于`addTask()`方法。唯一的区别是我们将现有任务的`taskId`作为一个附加参数。首先，我们检索它，更新它的值，最后用`taskRepository`保存它。该方法还重定向到另一个控制器方法，以显示带有`/allTaskList` URL 模式的任务列表。

# 添加任务注释

普通用户和管理员用户可以向现有任务添加注释。在查看模式下打开任务时，屏幕提供了添加注释的功能。添加任务注释的控制器方法的代码如下所示:

```java
@PostMapping("/addTaskComment")
fun addTask(@RequestParam(name = "taskId",required = true) taskId:Int,
         @RequestParam(name = "taskComment",required = true) taskComment:String,
         model:Model):String {
   val currentTask:Task? = taskRepository?.findById(taskId)?.get()
   if(currentTask !=null) {
      val principal = SecurityContextHolder.getContext().authentication.principal
      if (principal is CustomUserPrinciple) {
         val user = principal.getUser()
         var existingComments: MutableSet<Comments>? = currentTask.getComments()
         var comment:Comments?
         if(existingComments == null || existingComments.isEmpty()) {
            existingComments = mutableSetOf() // Inmitialize empty hash set
         }
            comment = Comments()
            comment.setTask(currentTask)
            if(user !=null) comment.setUser(user)
            comment.setComment(taskComment)
            comment = commentRepository?.save(comment)
            if(comment !=null) {
               existingComments.add(comment)
            }
            currentTask.setComments(existingComments)
            taskRepository?.save(currentTask)
      }
   }
   return "redirect:viewTask?taskId=$taskId"
}
```

在这种方法中，`taskId`和`taskComment`参数由查看任务屏幕提供，用户可以从这里添加注释。我们从`taskId`获取`Task`对象，并将其注释作为可变集合获取。

Kotlin 提供了一个 API 集合(list、set、map 等),明确区分了可变类型和不可变类型。这对于确保避免错误和设计清晰的 API 非常方便。当您声明任何集合时，比如说，`List<out T>`，它在默认情况下是不可变的，Kotlin 允许只读操作，比如`size()`、`get()`等等。您不能向其中添加任何元素。

如果您希望修改集合，您需要显式地使用可变类型，比如`MutableList<String>`、`MutableMap<String, String>`等等。在我们的例子中，我们需要在现有的集合中添加一个注释，所以我们使用了`MutableSet`类型。添加第一个注释时注释集是空的，所以我们用`mutableSetOf()`方法创建一个空集。这个方法用于动态创建一个`Set`类型的集合。

我们还需要将当前登录用户的`userId`添加到注释中。为此，我们调用`SecurityContextHolder.getContext().authentication.principal`。`SecurityContextHolder`类由 Spring Security 提供，用于获取各种与安全相关的信息。

# 获取所有用户

该方法将返回系统中所有可用的用户。它用于创建一个任务屏幕，以获取一个用户列表来选择任务分配。该方法如下:

```java
@GetMapping("/getAllUsers")
fun getUsers(model:Model):String{
   var users: List<User>? = userRepository?.findAll() ?: null;
   model.addAttribute("users",users)
   return "users"
}
```

我们从添加任务屏幕中的模型弹出菜单中调用它。UI 将由百里香模板— `users.html` *渲染。*

# 显示任务列表

该方法向普通用户和管理员用户显示任务列表。区别在于普通用户只能查看和添加评论，而管理员用户可以查看、编辑和删除任务记录。另一个区别是普通用户可以看到分配给它的任务列表，而管理员用户可以看到系统中所有可用的任务。该方法应该如下所示:

```java
@GetMapping("/allTaskList")
fun showAllTaskList(@RequestParam(name = "myTask",required = false) myTask:String?,
               model:Model):String{
   var taskLst:  List<Array<Any>>? = null
   if("true" == myTask){
      //get current user ID from Spring context
      val principal = SecurityContextHolder.getContext().authentication.principal
      if (principal is CustomUserPrinciple) {
         val user = principal.getUser()
         if(user !=null){
            taskLst = taskRepository?.findMyTasks(user.getId() ?: 0)
         }
         model.addAttribute("screenTitle","My Tasks")
      }
   }else {
      taskLst = taskRepository?.findAllTasks()
      model.addAttribute("screenTitle","All Tasks")
   }
   val taskDtoLst:MutableList<TaskDTO> = ArrayList()
   var taskDto:TaskDTO?
   for(row in taskLst.orEmpty()){
      taskDto = TaskDTO(row[0] as Int,row[1] as String,row[2] as String,
       null, row[3] as String,row[4] as String,null)
      taskDtoLst.add(taskDto)
   }
   model.addAttribute("tasks",taskDtoLst)
   return "task-list"
}
```

基于`myTask`请求参数，该方法提供两个操作。如果可用，则只提取分配给当前用户的任务，否则提取所有任务。具有管理员角色的用户可以获取所有任务。从数据库获取任务后，我们将它们映射到一个`TaskDTO`类的对象上。**数据传输对象** ( **DTO** )是 Kotlin 数据类，如下所示:

```java
class TaskDTO( var id :Int?, var title : String?,
               var detail : String?, var assignedTo : Int?, 
               var assignedPerson:String?, var status : String?, 
               var comments : Set<Comments>?)
```

在任务列表中，我们显示了任务被分配到的用户的姓名。在`task`表中，我们存储了`userId`，因此我们需要通过组合任务和用户表来获取用户名。Spring Data JAP 提供了一种通过`@Query`注释获取复杂查询结果的便捷方式。

这个注释用于定义一个使用 JAP 查询语言(甚至是原生 SQL 查询)的查询，并将其绑定到 JPA 存储库的方法。当我们调用存储库方法时，JPA 将执行附加到带有`@Query`注释的方法的查询。让我们在存储库接口上定义两个连接查询方法，如下所示:

```java
@Repository
interface TaskRepository : JpaRepository<Task,Int>{

    @Query("SELECT t.id, t.title, t.detail, concat(u.firstname,
            ' ',u.lastname) as assignedTo ,t.status FROM task t 
            inner join users u on t.assigned_to = u.id",
            nativeQuery = true)
    fun findAllTasks(): List<Array<Any>>

    @Query("SELECT t.id, t.title, t.detail, concat(u.firstname,
            ' ',u.lastname) as assignedTo ,t.status FROM task t 
            inner join users u on t.assigned_to = u.id and 
            u.id =:userId",nativeQuery = true)
    fun findMyTasks(userId : Int): List<Array<Any>>
}
```

第一种方法将获取系统中所有可用的任务，而第二种方法将只获取分配给特定用户的任务。`nativeQery`属性表明它是一个 SQL 查询。由于这个查询从多个表中返回列(在我们的例子中是 **task** 和 **users** ，它返回一个`Any`类型的数组列表，而不是一个特定的实体类对象。`List`对象表示记录行，`Array`的元素是列，`Any`表示 Kotlin 中任何可用的类型。`Any`相当于 Java 中的`Object`。

然后可以用它来填充控制器方法— `showAllTaskList`中的`TaskDTO`对象。关键字`as`用于将`Any`转换成相应的类型。Kotlin 编译器使用智能强制转换，所以你不需要明确检查给定的`Any`类型是否兼容。对于管理员用户，任务列表屏幕如下所示:

![](assets/03c35fa4-fe75-44f5-8a64-7994e74c3498.png)

对于普通用户，它看起来如下:

![](assets/7dae280f-8eba-41cd-9ecc-6d9e87392924.png)

# 查看任务

查看任务屏幕将以查看模式打开任务，这意味着它将显示任务的详细信息。它还允许您添加注释，并显示添加到所选任务的注释列表。用于查看任务的控制器方法将填充任务和注释数据，并重定向用户以查看任务屏幕。该方法如下所示:

```java
@GetMapping("/viewTask")
fun viewTask(@RequestParam(name = "taskId",required = true) 
                                        taskId:Int,model:Model):String{
   val selectedTask:Task? = taskRepository?.findById(taskId)?.get()
   val user:User? = userRepository?.
                    findById(selectedTask?.getAssignedTo() ?: 0)?.get()

   val taskDto= TaskDTO(selectedTask?.getId(),selectedTask?.getTitle(),
         selectedTask?.getDetail(),selectedTask?.getAssignedTo(),
         (user?.getFirstname() + " "+ user?.getLastname()),
         selectedTask?.getStatus(),selectedTask?.getComments())
   val commentLst:  List<Array<Any>>? = commentRepository?.findByTaskId(taskId)
   val commentDtoLst:MutableList<CommentDTO> = ArrayList()
   var commentDto:CommentDTO?
   for(row in commentLst.orEmpty()){
      commentDto = CommentDTO(row[0] as Int,row[1] as String,row[2] as String)
      commentDtoLst.add(commentDto)
   }
   model.addAttribute("task",taskDto)
   model.addAttribute("taskComments",commentDtoLst)
   model.addAttribute("screenTitle","Add Task Comment")
   return "task-view"
}
```

`taskId`参数将从任务列表屏幕发送。首先，我们从给定的`taskId`中获取任务细节。我们还从与`Task`对象相关联的用户 ID 中获取用户数据。对于评论，我们做同样的事情:从`commentRepository`获取带有给定`taskId`的评论。

我们从`commentRepository`获取注释，但是我们也可以从`Task`对象获取注释，因为它们有一对多的关系。我们不这样获取它们的原因是，我们希望显示任务分配给谁的用户名。如果我们从`Task`获取注释，它将返回`Comments`类型的对象集合，该集合有一个用户 ID，但没有名字和姓氏。因此，我们可能需要进行一轮额外的数据库调用来获取每个注释记录的用户名和姓。这可能会导致性能下降。

作为替代，我们使用 JPA 查询语言机制，通过将`join` SQL 查询与存储库方法相关联，如下所示:

```java
interface CommentRepository: JpaRepository<Comments, Int> {

    @Query("SELECT c.id, c.comment, concat(u.firstname,' ',u.lastname) 
           FROM comments c inner join users u on c.user_id=u.id inner join task t 
           on t. id = c.task_id and t.id =:taskId",nativeQuery = true)
    fun findByTaskId(taskId: Int):List<Array<Any>>
}
```

它作为`List<Array<Any>>`类型返回，因为数据是从多个表中提取的(**任务**和**注释**)。我们正在迭代它并填充列表`CommentDTO`，它被定义为一个数据类，如下所示:

```java
data class CommentDTO(var id:Int,var comment:String,var userName:String)
```

`TaskDTO`对象用于显示任务细节，而`CommentDTO`列表用于在查看任务屏幕中以表格形式显示注释。

# 删除任务

只有管理员用户可以删除现有任务。删除选项在任务列表屏幕中可见。删除任务的控制器方法如下:

```java
@PostMapping("/deleteTask")
fun deleteTask(@RequestParam(name = "taskId",required = true) taskId:Int,model:Model):String{
   var selectedTask:Task? = taskRepository?.findById(taskId)?.get()
   if(selectedTask !=null) {
      taskRepository?.delete(selectedTask)
   }
   return "redirect:allTaskList"
}
```

任务列表屏幕中提供了`taskId`参数。首先，我们从`taskRepository`中用`taskId`获取`Task`的对象，如果不为空则删除。最后，我们使用`/allTaskList` URL 重定向到另一个控制器方法来显示任务列表屏幕。

# 休息呼叫 onkotlin

让我们了解一下如何与科特林进行休息通话。我们公开 REST API 来向系统添加用户。需要提供基本的用户信息以及角色信息。在 Kotlin 中定义 REST 控制器类似于 Java，如下所示:

```java
@RestController
@RequestMapping("/api")
class TaskMgmntRESTController {
...
}
```

用`@RestController`将`TaskMgmntRESTController` Kotlin 类定义为 REST 控制器，并用`@RequestMapping`注释配置`/api` URL 模式。我们将编写一个处理用户注册的函数，如下所示:

```java
@PostMapping(value = "/register", consumes = [MediaType.APPLICATION_JSON_VALUE])
fun registerNewUser(@Valid @RequestBody userRegistrationDto: UserRegistrationDTO, 
                                    errors: Errors): ResponseEntity<List<String>> {
          // registration code...
}
```

这个函数是用`@PostMapping`注释定义的，所以数据必须用 HTTP POST 方法发送。另外，URL 映射是`/register`,所以访问这个函数(方法)的有效路径是`/api/register`。它使用 JSON 格式的数据。Spring 将从 JSON 输入中填充一个对象`UserRegistrationDTO`。Kotlin 数据类如下:

```java
data class UserRegistrationDTO(var username:String, var password:String,
                               var firstname:String, var lastname:String,
                               var roleList:List<String>)
```

`username`、`password`、`firstname`和`lastname`属性用于在用户表中插入一条记录，而`roleList`属性用于关联该用户拥有的角色。输入数据必须以 JSON 格式给出，并使用来自 REST 客户端的 HTTP POST 方法，如下所示:

```java
{
  "username":"dav",
  "password":"test",
  "firstname":"Dav",
  "lastname":"Patel",
  "roleList":["ROLE_USER","ROLE_ADMIN"]
}
```

用`registerNewUser`方法写的代码会分成以下两部分。

# 确认

用户以 JSON 格式发送数据，在进入系统之前必须进行验证，以避免任何后端错误。我们将实现一些基本的验证，而不是强加一个完整的验证列表。例如，验证现有用户名时，角色列表中除了`ROLR_USER`和`ROLE_ADMIN`之外还有其他无效值。代码如下所示:

```java
if (userRegistrationDto.username != null) {
    var existingUser : User? = userRepository?.findByUsername(
                                            userRegistrationDto.username) 
    if (existingUser != null) {
        errors.reject("Existing username","User is already exist with username 
                                        '${userRegistrationDto.username}'. ")
    }
}
if( userRegistrationDto.roleList.isEmpty()){
    errors.reject("No Roles provided","Please provide roles")
}else{
    var validRole = true
    var invalidRole:String?=null
    for(roleName in userRegistrationDto.roleList){
        if(!TaskMgmntConstant.getRolesLst().contains(roleName)){
            validRole=false
            invalidRole = roleName
            break
        }
    }
    if(!validRole){
        errors.reject("Invalid Roles"," $invalidRole is not a valid role")
    }
}
if (errors.hasErrors()) {
    val errorMsg = ArrayList<String>()
    errors.allErrors.forEach { a -> errorMsg.add(a.defaultMessage ?: "")
    }
    return ResponseEntity(errorMsg, HttpStatus.BAD_REQUEST)
} else {
 // .. User Registration code goes here
}
```

首先，我们检查 JSON 数据中发送的用户名是否已经存在于系统中。如果是，则返回适当的消息。第二个检查是关于角色列表。我们在`TaskMgmntConstant`类中创建了一个预定义的角色列表，函数声明如下:

```java
object TaskMgmntConstant {
   const val ROLE_USER :String = "ROLE_USER"
   const val ROLE_ADMIN :String = "ROLE_ADMIN"

   //... Other constant declaration

   fun getRolesLst():List<String>{
      return listOf(ROLE_ADMIN, ROLE_USER)
   }
}
```

让我们回忆一下`TaskMgmntConstant`是单例类，我们可以定义常量以外的函数。如果作为 JSON 字符串发送的`roleList`数据不同于这两个角色，那么我们显示一条适当的消息。您可以看到一个带有 lambda 表达式的`forEach`方法如何使用 for 循环。如果出现任何错误，我们将发送一条带有 HTTP 状态 401 的验证消息(`HttpStatus.BAD_REQUEST`)。

# 用户注册

如果所有验证都得到满足，那么我们将使用以下代码进行用户注册和角色映射:

```java
val userEntity = User()
userEntity.setUsername(userRegistrationDto.username)
userEntity.setEnabled(true)
val encodedPassword = passwordEncoder?.encode(userRegistrationDto.password)
userEntity.setPassword(encodedPassword ?: "")
userEntity.setFirstname(userRegistrationDto.firstname)
userEntity.setLastname(userRegistrationDto.lastname)

var role:Role?=null
var roles: MutableSet<Role> = mutableSetOf()
for(roleName in userRegistrationDto.roleList){
    role = roleRepository?.findByRole(roleName)
    if(role !=null) {
        roles.add(role)
    }
}
userEntity.setRoles(roles)
userRepository?.save(userEntity)

val msgLst = Arrays.asList("User registered successfully")
return ResponseEntity(msgLst, HttpStatus.OK)
```

在这段代码中，我们创建了`User`对象，并从`UserRegistrationDTO`对象中填充它的值。我们还创建了可变角色列表，并通过从 JSON 数据的`UserRegistrationDTO`中获取角色的`roleRepository`来填充它。最后，我们将可变集合与`User`对象相关联，并将其保存在`userRepository`中。

# 摘要

在这一章中，我们学习了 Kotlin 的基础知识及其各种特性，然后用 Spring Boot 和 Kotlin 创建了一个应用。在很短的时间内，Kotlin 由于其功能，如互操作性、简洁性、安全特性和对众所周知的 ide 的支持，获得了巨大的发展势头和知名度。

Spring 框架有很多特性，被广泛应用于开发现代企业应用。凭借对 Java、Scala、Groovy 和 Kotlin 等各种编程语言的一流支持，Spring Framework 已经成为企业应用开发框架中的主导者。

Spring Framework 具有模块化设计，并在系统的所有方面提供无缝集成，例如前端、控制器层、安全性、持久性、云支持、消息传递支持、web 流等等。随着 Spring Boot 的发明，开发基于 Spring 的应用变得比以往任何时候都容易。

在本书中，我们探索了 Spring 框架，通过在每一章开发一个示例应用展示了它的能力。这肯定会建立你的信心，鼓励你进一步探索这个框架。但是，我们建议您创建更多的示例应用，以便获得更多的实践经验，并真正从框架中获得最大收益。

这里有一个完美的方式来结束我们的旅程。要进一步阅读，可以参考 Spring 官方文档和论坛。Spring 有一个巨大的活跃的社区，你可以找到许多个人博客来帮助你学习和探索这些概念。