# 一、创建一个列出世界各国 GDP 的应用

Spring 是一个促进基于 JVM 的企业应用开发的生态系统。这是通过使用 Spring 提供的各种模块实现的。其中一个称为 Spring-core，是 Spring 生态系统中框架的核心，它为依赖注入、web 应用、数据访问、事务管理、测试等提供支持。

在这一章中，我们将从头开始，使用 Spring 框架开发一个简单的应用。不要求你熟悉 Spring 框架，我们会确保在本章结束时，你有足够的信心使用 Spring 框架。

以下是本章涵盖的主题:

*   应用简介
*   了解数据库结构
*   了解世界银行 API
*   设计线框
*   创建空应用
*   定义模型类
*   定义数据访问层
*   定义 API 控制器
*   部署到 Tomcat
*   定义视图控制器
*   定义视图

# 技术要求

本章用到的所有代码都可以从以下 GitHub 链接下载:[https://GitHub . com/packt publishing/Spring-5.0-Projects/tree/master/chapter 01](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01)。该代码可以在任何操作系统上执行，尽管它只在 Windows 上测试过。

# 应用简介

我们将开发一个应用来显示各个国家的 GDP 信息。我们将使用 mysql 提供的示例 World DB([https://dev . MySQL . com/doc/World-setup/en/World-setup-installation . html](https://dev.mysql.com/doc/world-setup/en/world-setup-installation.html))来列出国家并获得详细视图，以显示从世界银行 API([https://data help desk . World Bank . org/knowledge base/articles/898599-API-indicator-queries](https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries))获得的国家信息及其 GDP 信息。

该列表将利用世界数据库中可用的国家数据。在 detail 视图中，我们将利用 World DB 中可用的数据来列出城市和语言，并利用 World Bank API 来获取有关该国家的附加信息和 GDP 信息。

我们还将支持编辑国家条目的基本细节，从国家条目中添加和删除城市，以及从国家条目中添加和删除语言。我们将在此应用中使用以下工具和技术:

*   实现 MVC 模式的 Spring MVC 框架
*   与 MySQL 数据库的交互将使用 Spring JDBC 模板来完成
*   与世界银行 API 的交互将使用 RestTemplate 完成
*   这些视图将使用一个叫做百里香叶的模板框架来创建
*   前端将由 jQuery 和 Bootstrap 驱动

# 了解数据库结构

如果你还没有安装 MySQL，请访问 MySQL 链接([https://dev.mysql.com/downloads/installer](https://dev.mysql.com/downloads/installer))来安装它，如果世界数据库还没有的话，用世界数据库填充它。附录还将指导您如何使用 MySQL Workbench 和 MySQL 命令行工具运行查询。

下图描述了世界数据库模式:

![](assets/3c6b1066-91ef-4e5c-9435-cedc3d0bcfa7.png)

数据库模式很简单，包含如下三个表:

*   **city** :映射到 country 表中三个字符编码的 country 的城市列表。
*   **country** :主键为三字符国家代码的国家列表。有一列有 ISO 国家代码。
*   **countrylanguage** :映射到国家的语言列表，其中一种国家语言被标记为官方语言。

# 了解世界银行 API

世界银行公开了很多 API([http://www.worldbank.org/](http://www.worldbank.org/))，API 文档可以在这里找到([https://data help desk . World Bank . org/knowledge base/articles/889386-developer-information-overview](https://datahelpdesk.worldbank.org/knowledgebase/articles/889386-developer-information-overview))。在可用的 api 中，我们将使用指标 API([https://data help desk . world bank . org/knowledge base/articles/898599-API-Indicator-queries](https://datahelpdesk.worldbank.org/knowledgebase/articles/898599-api-indicator-queries))，这些 API 表示总人口、GDP、GNI、能源使用等信息。

使用 Indicator API，我们将获取数据库中过去 10 年可用国家的 GDP 信息。让我们看看 API 的 REST URL 和 API 返回的数据，如下所示:

```java
GET http://api.worldbank.org/countries/BR/indicators/NY.GDP.MKTP.CD?format=json&date=2007:2017
```

在这个 URL 中，`BR`是一个国家代码(*巴西*)。`NY.GDP.MKTP.CD`是词库 API 内部调用指标 API 使用的标志。请求参数`date`指示需要 GDP 信息的持续时间。

您将从前面的 API 得到的响应中摘录如下:

```java
[
    {
        "page": 1,
        "pages": 1,
        "per_page": "50",
        "total": 11
    },
    [
       ....// Other country data 
        {
            "indicator": {
                "id": "NY.GDP.MKTP.CD",
                "value": "GDP (current US$)"
            },
            "country": {
                "id": "BR",
                "value": "Brazil"
            },
            "value": "1796186586414.45",
            "decimal": "0",
            "date": "2016"
        }
    ]
]
```

前面的答复显示了 2016 年巴西以美元计算的国内生产总值指标。

# 设计应用屏幕的线框

线框是一个应用或网站的基本框架。它给出了最终应用外观的概念。它基本上有助于决定导航流程、理解功能、设计用户界面，甚至有助于在应用存在之前设定预期。这个过程极大地帮助开发人员、设计人员、产品所有者和客户以同步的方式工作，以避免他们之间的任何差距。我们将遵循相同的模型，我们将设计如下应用的各种线框。

# 国家列表页面

我们会让它变得简单。主页显示带有分页的国家列表，并允许按国家名称搜索和按洲/地区过滤。下面是我们应用的主页:

![](assets/821768fe-363a-4c5f-9274-460a06f4bd32.png)

# 国家详细信息页面

该屏幕将显示国家的详细信息，如城市、语言和从世界银行 API 获得的 GDP 信息。GDP 数据将在图形视图中可见。该页面如下所示:

![](assets/b435b5fd-2731-4946-b34f-89bd0aabe494.png)

# 国家编辑页面

在国家列表页面，会有一个按钮叫做**编辑**。点击它，系统将在编辑模式下显示该国家，允许更新该国家的基本详细信息。以下是用于编辑国家/地区基本详细信息的视图结构:

![](assets/6d68ffe7-8d04-41c3-b543-c63c78a0a226.png)

# 添加新的城市和语言

在 country detail 页面中，单击 new 按钮可以看到两个模态视图，一个用于添加新的城市，另一个用于添加新的语言。以下是用于添加新国家和语言的两个模式对话框的视图。它们将被单独打开:

![](assets/b9a78694-069d-4b01-b51f-b21327824eb4.png)

# 创建空应用

我们将使用 Maven 生成一个空应用，它具有基于 Java 的 web 应用所需的结构。如果你没有安装 Maven，请按照这里的说明([https://maven.apache.org/install.html](https://maven.apache.org/install.html))来安装 Maven。安装后，运行以下命令创建一个空应用:

```java
mvn archetype:generate -DgroupId=com.nilangpatel.worldgdp -DartifactId=worldgdp -Dversion=0.0.1-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp
```

运行前面的命令将显示命令行参数值以进行确认，如下面的屏幕截图所示:

![](assets/f914bc77-a56b-4996-afb2-e033aff461e2.png)

您必须在前面截图中显示的命令提示符中键入`Y`来完成空项目的创建。现在，您可以将这个项目导入到您选择的 IDE 中，并继续进行开发活动。为了简单起见，我们将使用 Eclipse，因为它是当今 Java 社区使用的最流行的 ide 之一。

成功创建应用后，您将看到文件夹结构，如下面的屏幕截图所示:

![](assets/c3b3a0ad-e578-412c-bd23-13511439466a.png)

在创建默认项目结构时，您将看到默认添加的`index.jsp`。您必须删除它，因为在这个应用中，我们将使用百里香叶-另一个模板引擎来开发登录页面。

# 定义模型类

现在，让我们创建 Java 类来建模数据库中的数据以及来自世界银行 API 的数据。我们的方法很简单。我们将为数据库中的每个表创建一个 Java 类，数据库的列将成为 Java 类的属性。

在生成的应用中，`main`目录下缺少`java`文件夹。我们将手动创建`java`文件夹并打包`com.nilangpatel.worldgdp`，这将是应用的根包。让我们继续实施我们决定的方法。但在此之前，让我们看看一个有趣的项目，叫做**项目龙目**。

Lombok 项目提供了用于生成 getters、setters、default 和重载构造函数以及其他样板代码的注释。关于如何与你的 IDE 集成的更多细节可以在他们的项目网站上找到([https://projectlombok.org/](https://projectlombok.org/))。

我们需要更新我们的`pom.xml`来包含对 Lombok 项目的依赖。以下是您需要复制并添加到 XML 中相关位置的`pom.xml`部分:

```java
<properties>
    <java.version>1.8</java.version>
    <lombok.version>1.16.18</lombok.version>
</properties>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
    <version>${lombok.version}</version>
</dependency>
```

我们接下来要创建的所有模型类都属于`com.nilangpatel.worldgdp.model`包。下面的代码给出了表示`Country`数据的模型类:

```java
@Data
@Setter
@Getter
public class Country {
    private String code;
    private String name;
    private String continent;
    private String region;
    private Double surfaceArea;
    private Short indepYear;
    private Long population;
    private Double lifeExpectancy;
    private Double gnp;
    private String localName;
    private String governmentForm;
    private String headOfState;
    private City capital;
    private String code2;
}
```

`City`类还没有创建，让我们继续创建它，如下所示:

```java
@Data
@Setter
@Getter
public class City {
    private Long id;
    private String name;
    private Country country;
    private String district;
    private Long population;
}
```

接下来是建模`CountryLanguage`类，它是一个国家所讲的语言，如下所示:

```java
@Data
@Setter
@Getter
public class CountryLanguage {
    private Country country;
    private String language;
    private String isOfficial;
    private Double percentage;
}
```

我们还需要一个模型类来映射从世界银行 API 获得的 GDP 信息。让我们继续创建一个`CountryGDP`类，如下面的代码所示:

```java
@Data
@Setter
@Getter
public class CountryGDP { 
    private Short year;
    private Double value;
}
```

此时此刻，一切都非常好。但是当您开始将这些模型类的 getter 和 setter 调用到其他类中时，您可能会遇到编译错误。这是因为我们需要再做一步来配置 Lombok。在您定义了 Maven 依赖项之后，您将会看到来自 IDE 的 JAR 引用。只需右击它并选择 Run As *|* Java 应用选项。或者，您可以在保存 Lombok JAR 文件的位置从终端执行以下命令，如下所示:

```java
java -jar lombok-1.16.18.jar 
```

这里，`lombok-1.16.18.jar`是 JAR 文件的名称。您将看到一个单独的窗口弹出，如下所示:

![](assets/d796b115-b20e-4fb2-b9b5-25beb17e150a.png)

通过单击指定位置来选择 IDE 的位置...按钮。选中后，单击安装/更新按钮进行安装。您将收到一条成功消息。只需重启 IDE 并重新构建项目，您将会看到，只需定义`@Setter`和`@Getter`，实际的 setters 和 getters 就可用于其他类。您不再需要显式添加它们。

# 使用 hibernate 验证器添加验证

我们需要向模型类添加一些检查，以便从 UI 发送的数据不会无效。为此，我们将利用 Hibernate 验证器。您需要添加 Hibernate 依赖项，如下所示:

```java
    <properties>
        <java.version>1.8</java.version>
        <lombok.version>1.16.18</lombok.version>
        <hibernate.validator.version>6.0.2.Final</hibernate.validator.version>
    </properties>    
    <dependency>
        <groupId>org.hibernate.validator</groupId>
        <artifactId>hibernate-validator</artifactId>
        <version>${hibernate.validator.version}</version>
    </dependency>
```

现在回到`com.nilangpatel.worldgdp.model.Country`，用以下内容更新它:

```java
@Data public class Country {

  @NotNull @Size(max = 3, min = 3) private String code;
  @NotNull @Size(max = 52) private String name;
  @NotNull private String continent;
  @NotNull @Size(max = 26) private String region;
  @NotNull private Double surfaceArea;
  private Short indepYear;
  @NotNull private Long population;
  private Double lifeExpectancy;
  private Double gnp;
  @NotNull private String localName;
  @NotNull private String governmentForm;
  private String headOfState;
  private City capital;
  @NotNull private String code2;
}
```

下一步是以类似的方式更新`com.nilangpatel.worldgdp.model.City`类，如下所示:

```java
@Data public class City {
  @NotNull private Long id;
  @NotNull @Size(max = 35) private String name;
  @NotNull @Size(max = 3, min = 3) private String countryCode;
  private Country country;
  @NotNull @Size(max = 20) private String district;
  @NotNull private Long population;
}
```

最后，也更新`com.nilangpatel.worldgdp.model.CountryLanguage`类，如下所示:

```java
@Data
public class CountryLanguage {
  private Country country;
  @NotNull private String countryCode;
  @NotNull @Size(max = 30) private String language;
  @NotNull @Size(max = 1, min = 1) private String isOfficial;
  @NotNull private Double percentage;
}
```

# 定义数据访问层-Spring JDBC 模板

我们有模型类来反映从世界银行 API 获得的数据库中的数据结构。现在我们需要开发一个数据访问层，它与我们的 MySQL 进行交互，并将存储在数据库中的数据填充到模型类的实例中。我们将使用 Spring JDBC 模板来实现所需的与数据库的交互。

首先，我们需要 JDBC 驱动程序将任何 Java 应用与 MySQL 连接起来。这可以通过向我们的`pom.xml`添加以下依赖项和版本属性来实现:

```java
    <properties>
        <java.version>1.8</java.version>
        <lombok.version>1.16.18</lombok.version>
        <hibernate.validator.version>6.0.2.Final</hibernate.validator.version>    
        <mysql.jdbc.driver.version>5.1.44</mysql.jdbc.driver.version>
    </properties> 
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>${mysql.jdbc.driver.version}</version>
    </dependency>
```

无论你在哪里看到`<something.version>1.5.6</something.version>`，它都应该在`<properties></properties>`标签内。这个就不反复提了。这是为了将使用的库版本保存在一个地方，便于维护和查找。

任何作为`<dependency></dependency>`出现的东西都在`<dependencies></dependencies>`列表之内。

现在我们需要为 Spring 核心 API 添加一个依赖项，并为我们的`pom.xml`添加 Spring JDBC API(包含 JDBC 模板)。关于这两个依赖项的简要介绍如下:

1.  Spring 核心 API:它为我们提供了核心的 Spring 特性，比如依赖注入和配置模型
2.  **Spring JDBC API:**它为我们提供了创建`DataSource`实例和与数据库交互所需的 API

由于这是一个示例应用，我们没有使用 Hibernate 或其他 ORM 库，因为除了基本的 CRUD 操作之外，它们还提供了很多功能。相反，我们将编写 SQL 查询，并将它们与 JDBC 模板一起使用，以使事情更简单。

以下代码显示了两个库的`dependency`信息:

```java
<dependency>
   <groupId>org.springframework</groupId>
   <artifactId>spring-core</artifactId>
   <version>${spring.version}</version>
</dependency>
<dependency>
   <groupId>org.springframework</groupId>
   <artifactId>spring-jdbc</artifactId>
   <version>${spring.version}</version>
</dependency>
```

除了前面的两个依赖项，我们还需要添加一些 Spring 依赖项来帮助我们使用注释(比如`@bean`、`@Service`、`@Configuration`、`@ComponentScan`等等)和使用注释的依赖项注入(`@Autowired`)来设置基于 Java 的配置。为此，我们将添加更多依赖项，如下所示:

```java
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
    <version>${spring.version}</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>${spring.version}</version>
</dependency>
```

# 定义 JDBC 连接属性

我们将在一个`application.properties`文件中定义 JDBC 连接属性，并将其放在`src/main/resources`中。我们定义的属性如下:

```java
dataSourceClassName=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/worldgdp
dataSource.user=root
dataSource.password=test
```

前面的属性假设 MySQL 运行在端口`3306`上，数据库用户名和密码分别是`root`和`test`。您可以根据本地配置更改这些属性。下一步是定义一个属性解析器，当在代码中使用时，它将能够解析属性。我们将使用`@PropertySource`注释，以及一个`PropertySourcesPlaceholderConfigurer`实例，如下面的代码所示:

```java
@Configuration
@PropertySource("classpath:application.properties")
public class PropertiesWithJavaConfig {

   @Bean
   public static PropertySourcesPlaceholderConfigurer
     propertySourcesPlaceholderConfigurer() {
      return new PropertySourcesPlaceholderConfigurer();
   }
}
```

我们将遵循将所有配置类放在`com.nilangpatel.worldgdp.config`中的惯例，任何根配置都将放在`com.nilangpatel.worldgdp`包中。

这个类从存储在类路径(`src/main/resources`)中的`application.properties`文件中读取所有属性。接下来是配置一个`javax.sql.DataSource`对象，它将使用`application.properties`文件中定义的属性连接到数据库。我们将使用 HikariCP 连接池库来创建我们的`DataSource`实例。这个`DataSource`实例然后被用来实例化`NamedParameterJdbcTemplate`。我们将使用`NamedParameterJdbcTemplate`来执行所有的 SQL 查询。此时，我们需要为 HikariCP 库添加一个必要的依赖项，如下所示:

```java
    <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
        <version>${hikari.version}</version>
    </dependency>
```

`DBConfiguration`数据源配置类应该如下所示:

```java
@Configuration
public class DBConfiguration {
  @Value("${jdbcUrl}") String jdbcUrl;
  @Value("${dataSource.user}") String username;
  @Value("${dataSource.password}") String password;
  @Value("${dataSourceClassName}") String className;

  @Bean
  public DataSource getDataSource() {
    HikariDataSource ds = new HikariDataSource();
    ds.setJdbcUrl(jdbcUrl);
    ds.setUsername(username);
    ds.setPassword(password);
    ds.setDriverClassName(className);
    return ds;
  }

  @Bean
  public NamedParameterJdbcTemplate namedParamJdbcTemplate() {
    NamedParameterJdbcTemplate namedParamJdbcTemplate = 
        new NamedParameterJdbcTemplate(getDataSource());
    return namedParamJdbcTemplate;
  }
}
```

让我们快速介绍一下这段代码中使用的一些新东西:

*   **`@Configuration` :** 这是向 Spring Framework 表明这个类创建了包含一些配置的 Java 对象
*   **`@Bean` :** 这是方法级的注释，用于向 Spring Framework 指示方法返回 Java 对象，这些对象的生命周期由 Spring Framework 管理，并被注入到声明其依赖关系的地方
*   **`@Value` :** 用于引用`application.properties`中定义的属性，由`PropertiesWithJavaConfig`类中定义的`PropertySourcesPlaceholderConfigurer` bean 解析

用 JUnit 编写单元测试用例总是一个好的实践。我们将为我们的应用编写测试用例。为此，我们需要创建相应的配置类来运行我们的 JUnit 测试。在下一节中，我们将看看如何设置测试环境。

# 设置测试环境

让我们在这里采用一种测试优先的方法。因此，在开始编写查询和 DAO 类之前，让我们为单元测试设置环境。如果您没有找到`src/test/java`和`src/test/resources`文件夹，那么请继续从您的 IDE 或您的 OS 文件资源管理器中创建它们。

文件夹`src/test/java`将包含所有的 Java 代码，而`src/test/resources`将包含测试用例所需的属性文件和其他资源。创建所需的文件夹后，项目结构类似于下面的屏幕截图:

![](assets/4f495b7e-63f6-40f6-adc4-4b26af1833a5.png)

我们将使用 H2 数据库作为测试环境的数据源。为此，我们将更新我们的 Maven 依赖项，添加 H2 和 JUnit 依赖项。H2 是最流行的嵌入式数据库之一。以下是您需要添加到`pom.xml`中的依赖信息:

```java
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>${spring.version}</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>${junit.version}</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.assertj</groupId>
    <artifactId>assertj-core</artifactId>
    <version>${assertj.version}</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>${h2.version}</version>
</dependency>
```

我们已经有了`spring.version`的属性，但是我们需要另外两个的版本属性，如下面的代码所示:

```java
<junit.version>4.12</junit.version>
<assertj.version>3.12.0</assertj.version>
<h2.version>1.4.198</h2.version>
```

MySQL 中可用的 World DB 模式与 H2 不兼容，但不用担心。本章的源代码中提供了 H2 兼容的 World DB 模式，您可以从 GitHub([https://GitHub . com/packt publishing/Spring-5.0-Projects/tree/master/chapter 01](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter01))下载。它保存在项目的`src/test/resources`文件夹中。文件名为`h2_world.sql`。我们将使用这个文件来引导我们的 H2 数据库，其中包含所需的表和数据，这些表和数据将在我们的测试中可用。

接下来是配置 H2，我们要配置的内容之一是包含模式和数据的 SQL 脚本文件的名称。这个 SQL 脚本文件应该可以在类路径中找到。下面是在`src/test/java`文件夹下的`com.nilangpatel.worldgdp.test.config`包中创建的配置类:

```java
@Configuration
public class TestDBConfiguration {

  @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .generateUniqueName(true)
            .setType(EmbeddedDatabaseType.H2)
            .setScriptEncoding("UTF-8")
            .ignoreFailedDrops(true)
            .addScript("h2_world.sql")
            .build();
    }

  @Bean("testTemplate")
  public NamedParameterJdbcTemplate namedParamJdbcTemplate() {
    NamedParameterJdbcTemplate namedParamJdbcTemplate = 
        new NamedParameterJdbcTemplate(dataSource());
    return namedParamJdbcTemplate;
  }
}
```

除了 H2 配置，我们还通过向它提供另一个方法中构建的 H2 数据源来初始化`NamedParameterJdbcTemplate`。

我们添加了一些特定于 JUnit 的其他依赖项。你可以通过下载源代码来参考它们。

# 定义行映射器

当我们使用 JDBC 模板时，我们需要一种将数据库中的数据行映射到 Java 对象的方法。这可以通过实现一个`RowMapper`接口来实现。我们将为所有三个实体定义映射器类。对于`Country`，原始映射器类如下所示:

```java
public class CountryRowMapper implements RowMapper<Country>{

  public Country mapRow(ResultSet rs, int rowNum) 
                            throws SQLException {
    Country country = new Country();
    country.setCode(rs.getString("code"));
    country.setName(rs.getString("name"));
    country.setContinent(rs.getString("continent"));
    country.setRegion(rs.getString("region"));
    country.setSurfaceArea(rs.getDouble("surface_area"));
    country.setIndepYear(rs.getShort("indep_year"));
    country.setPopulation(rs.getLong("population"));
    country.setLifeExpectancy(rs.getDouble("life_expectancy"));
    country.setGnp(rs.getDouble("gnp"));
    country.setLocalName(rs.getString("local_name"));
    country.setGovernmentForm(rs.getString("government_form"));
    country.setHeadOfState(rs.getString("head_of_state"));
    country.setCode2(rs.getString("code2"));
    if ( Long.valueOf(rs.getLong("capital")) != null ) {
      City city = new City();
      city.setId(rs.getLong("capital"));
      city.setName(rs.getString("capital_name"));
      country.setCapital(city);
    }
    return country;
  }
}
```

然后我们为`City`定义映射器类如下:

```java
public class CityRowMapper implements RowMapper<City>{
  public City mapRow(ResultSet rs, int rowNum) 
                    throws SQLException {
    City city = new City();
    city.setCountryCode(rs.getString("country_code"));
    city.setDistrict(rs.getString("district"));
    city.setId(rs.getLong("id"));
    city.setName(rs.getString("name"));
    city.setPopulation(rs.getLong("population"));
    return city;
  }
}
```

最后，我们将`CountryLanguage`定义如下:

```java
public class CountryLanguageRowMapper implements 
                       RowMapper<CountryLanguage> {
  public CountryLanguage mapRow(ResultSet rs, int rowNum) 
                                 throws SQLException {
    CountryLanguage countryLng = new CountryLanguage();
    countryLng.setCountryCode(rs.getString("countrycode"));
    countryLng.setIsOfficial(rs.getString("isofficial"));
    countryLng.setLanguage(rs.getString("language"));
    countryLng.setPercentage(rs.getDouble("percentage"));
    return countryLng;
  }
}
```

# 设计乡村道

让我们继续定义`com.nilangpatel.worldgdp.dao`包中的`CountryDAO`类以及所需的方法，从`getCountries`方法开始。这个方法将获取国家的详细信息，并在列表页面中显示出来。在筛选国家列表时也会调用此方法。基于列表、过滤和分页，我们将该方法中使用的查询分为以下几个部分:

1.  选择子句:

```java
private static final String SELECT_CLAUSE = "SELECT "
      + " c.Code, "
      + " c.Name, "
      + " c.Continent, "
      + " c.region, "
      + " c.SurfaceArea surface_area, "
      + " c.IndepYear indep_year, "
      + " c.Population, "
      + " c.LifeExpectancy life_expectancy, "
      + " c.GNP, "
      + " c.LocalName local_name, "
      + " c.GovernmentForm government_form, "
      + " c.HeadOfState head_of_state, "
      + " c.code2 ,"
      + " c.capital ,"
      + " cy.name capital_name "
      + " FROM country c"
      + " LEFT OUTER JOIN city cy ON cy.id = c.capital ";
```

2.  搜索 where 子句:

```java
private static final String SEARCH_WHERE_CLAUSE = " AND ( LOWER(c.name) "
      + " LIKE CONCAT('%', LOWER(:search), '%') ) ";
```

3.  洲过滤器 where 子句:

```java
private static final String CONTINENT_WHERE_CLAUSE = 
      " AND c.continent = :continent ";
```

4.  区域筛选器 where 子句:

```java
private static final String REGION_WHERE_CLAUSE = 
      " AND c.region = :region ";
```

5.  分页条款:

```java
private static final String PAGINATION_CLAUSE = " ORDER BY c.code "
      + " LIMIT :size OFFSET :offset ";
```

由`:<<variableName>>`定义的占位符由`Map`到`NamedParameterJdbcTemplate`中提供的值替换。这样，我们可以避免将值连接到 SQL 查询中，从而避免 SQL 注入的机会。`getCountries()`的定义现在如下:

```java
public List<Country> getCountries(Map<String, Object> params){
    int pageNo = 1;
    if ( params.containsKey("pageNo") ) {
      pageNo = Integer.parseInt(params.get("pageNo").toString());
    }
    Integer offset = (pageNo - 1) * PAGE_SIZE;
    params.put("offset", offset);
    params.put("size", PAGE_SIZE);
    return namedParamJdbcTemplate.query(SELECT_CLAUSE
        + " WHERE 1 = 1 "
        + (!StringUtils.isEmpty((String)params.get("search")) 
            ? SEARCH_WHERE_CLAUSE : "")
        + (!StringUtils.isEmpty((String)params.get("continent")) 
            ? CONTINENT_WHERE_CLAUSE : "")
        + (!StringUtils.isEmpty((String)params.get("region")) 
            ? REGION_WHERE_CLAUSE : "")
        + PAGINATION_CLAUSE,
        params, new CountryRowMapper());
  }
```

接下来是实现`getCountriesCount`方法，该方法类似于`getCountries`，除了它返回匹配`WHERE`子句的条目计数，而不应用分页。实现如下面的代码所示:

```java
public int getCountriesCount(Map<String, Object> params) {
  return namedParamJdbcTemplate.queryForObject(
          "SELECT COUNT(*) FROM country c" 
        + " WHERE 1 = 1 "
        + (!StringUtils.isEmpty((String)params.get("search")) 
            ? SEARCH_WHERE_CLAUSE : "")
        + (!StringUtils.isEmpty((String)params.get("continent")) 
            ? CONTINENT_WHERE_CLAUSE : "")
        + (!StringUtils.isEmpty((String)params.get("region")) 
            ? REGION_WHERE_CLAUSE : ""),
        params, Integer.class);
  }
```

然后，我们实现`getCountryDetail`方法来获取国家的详细信息，给定其代码，如下所示:

```java
public Country getCountryDetail(String code) {
  Map<String, String> params = new HashMap<String, String>();
  params.put("code", code);

  return namedParamJdbcTemplate.queryForObject(SELECT_CLAUSE 
      +" WHERE c.code = :code", params, 
      new CountryRowMapper());
}
```

在前面所有的 DAO 方法实现中，我们都使用了在定义行映射器一节中定义的`CountryRowMapper`。

最后，我们定义允许编辑国家信息的方法，如下面的代码所示:

```java
public void editCountryDetail(String code, Country country) {
    namedParamJdbcTemplate.update(" UPDATE country SET "
        + " name = :name, "
        + " localname = :localName, "
        + " capital = :capital, "
        + " continent = :continent, "
        + " region = :region, "
        + " HeadOfState = :headOfState, "
        + " GovernmentForm = :governmentForm, "
        + " IndepYear = :indepYear, "
        + " SurfaceArea = :surfaceArea, "
        + " population = :population, "
        + " LifeExpectancy = :lifeExpectancy "
        + "WHERE Code = :code ", 
        getCountryAsMap(code, country));
  }
```

前面的方法使用了一个助手方法，通过使用`Country`对象中的数据来构建一个`Map`对象。我们需要这张地图，因为我们将使用它作为我们`namedParamJdbcTemplate`的参数源。

helper 方法有一个简单的实现，如下面的代码所示:

```java
private Map<String, Object> getCountryAsMap(String code, Country country){
    Map<String, Object> countryMap = new HashMap<String, Object>();
    countryMap.put("name", country.getName());
    countryMap.put("localName", country.getLocalName());
    countryMap.put("capital", country.getCapital().getId());
    countryMap.put("continent", country.getContinent());
    countryMap.put("region", country.getRegion());
    countryMap.put("headOfState", country.getHeadOfState());
    countryMap.put("governmentForm", country.getGovernmentForm());
    countryMap.put("indepYear", country.getIndepYear());
    countryMap.put("surfaceArea", country.getSurfaceArea());
    countryMap.put("population", country.getPopulation());
    countryMap.put("lifeExpectancy", country.getLifeExpectancy());
    countryMap.put("code", code);
    return countryMap;
}
```

让我们为`CountryDAO`类编写 JUnit 测试，我们还没有创建它。将`CountryDAOTest`类创建到`com.nilangpatel.worldgdp.test.dao`包中，如下所示:

```java
@RunWith(SpringRunner.class)
@SpringJUnitConfig( classes = {
      TestDBConfiguration.class, CountryDAO.class})
public class CountryDAOTest {

  @Autowired CountryDAO countryDao;

  @Autowired @Qualifier("testTemplate")
  NamedParameterJdbcTemplate namedParamJdbcTemplate;

  @Before
  public void setup() {
    countryDao.setNamedParamJdbcTemplate(namedParamJdbcTemplate);
  }

  @Test
  public void testGetCountries() {
    List<Country> countries = countryDao.getCountries(new HashMap<>());
    //AssertJ assertions
    //Paginated List, so should have 20 entries
    assertThat(countries).hasSize(20);
  }

  @Test
  public void testGetCountries_searchByName() {
    Map<String, Object> params = new HashMap<>();
    params.put("search", "Aruba");
    List<Country> countries = countryDao.getCountries(params);
    assertThat(countries).hasSize(1);
  }

  @Test
  public void testGetCountries_searchByContinent() {
    Map<String, Object> params = new HashMap<>();
    params.put("continent", "Asia");
    List<Country> countries = countryDao.getCountries(params);

    assertThat(countries).hasSize(20);
  }

  @Test
  public void testGetCountryDetail() {
    Country c = countryDao.getCountryDetail("IND");
    assertThat(c).isNotNull();
    assertThat(c.toString()).isEqualTo("Country(code=IND, name=India, "
        + "continent=Asia, region=Southern and Central Asia, "
        + "surfaceArea=3287263.0, indepYear=1947, population=1013662000, "
        + "lifeExpectancy=62.5, gnp=447114.0, localName=Bharat/India, "
        + "governmentForm=Federal Republic, headOfState=Kocheril Raman Narayanan, "
        + "capital=City(id=1109, name=New Delhi, countryCode=null, "
        + "country=null, district=null, population=null), code2=IN)");
  }

  @Test public void testEditCountryDetail() {
    Country c = countryDao.getCountryDetail("IND");
    c.setHeadOfState("Ram Nath Kovind");
    c.setPopulation(1324171354l);
    countryDao.editCountryDetail("IND", c);

    c = countryDao.getCountryDetail("IND");
    assertThat(c.getHeadOfState()).isEqualTo("Ram Nath Kovind");
    assertThat(c.getPopulation()).isEqualTo(1324171354l);
  }

  @Test public void testGetCountriesCount() {
    Integer count = countryDao.getCountriesCount(Collections.EMPTY_MAP);
    assertThat(count).isEqualTo(239);
  }
}
```

在下面的测试中，有一些关于使用 Spring 测试框架配置 JUnit 测试的注意事项，包括:

*   `@RunWith`用于将 JUnit 的测试运行程序替换为定制的测试运行程序，在本例中是 Spring 的`SpringRunner`。Spring 的 test runner 有助于 JUnit 与 Spring 测试框架的集成。
*   `@SpringJUnitConfig`用于提供包含所需配置的类列表，以满足运行测试的依赖性。

许多选择 ORM 框架的人可能会觉得像这样编写复杂的 SQL 查询很笨拙。然而，从下一章开始，我们将开始使用 Spring 数据框架与各种数据源进行交互；该数据库是使用 Spring 数据 JPA 访问的数据库之一。这里，我们想展示 Spring JDBC 产品如何与数据库交互。

# 设计城市道

下面是一些由`com.nilangpatel.worldgdp.dao.CityDAO`类支持的重要操作:

*   获取国家的城市
*   获取给定 ID 的城市详细信息
*   向国家/地区添加新城市
*   从国家中删除给定的城市

让我们从`getCities`开始实施这些功能，如下所示:

```java
public List<City> getCities(String countryCode, Integer pageNo){
  Map<String, Object> params = new HashMap<String, Object>();
  params.put("code", countryCode);
  if ( pageNo != null ) {
    Integer offset = (pageNo - 1) * PAGE_SIZE;
    params.put("offset", offset);
    params.put("size", PAGE_SIZE);
  }

  return namedParamJdbcTemplate.query("SELECT "
      + " id, name, countrycode country_code, district, population "
      + " FROM city WHERE countrycode = :code"
      + " ORDER BY Population DESC"
      + ((pageNo != null) ? " LIMIT :offset , :size " : ""),
      params, new CityRowMapper());
}
```

我们使用分页查询来获取一个国家的城市列表。我们还需要这个方法的另一个重载版本，其中我们返回一个国家的所有城市，我们将使用这个查询来获取所有城市，同时编辑国家以选择其首都。重载版本如下:

```java
public List<City> getCities(String countryCode){
  return getCities(countryCode, null);
}
```

接下来是实现方法来获取城市详细信息，如下面的代码所示:

```java
public City getCityDetail(Long cityId) {
  Map<String, Object> params = new HashMap<String, Object>();
  params.put("id", cityId);
  return namedParamJdbcTemplate.queryForObject("SELECT id, "
      + " name, countrycode country_code, "
      + " district, population "
      + " FROM city WHERE id = :id", 
      params, new CityRowMapper());
}
```

然后，我们实现方法来添加一个城市，如下所示:

```java
public Long addCity(String countryCode, City city) {

  SqlParameterSource paramSource = new MapSqlParameterSource(
      getMapForCity(countryCode, city));
  KeyHolder keyHolder = new GeneratedKeyHolder();
  namedParamJdbcTemplate.update("INSERT INTO city("
      + " name, countrycode, "
      + " district, population) "
      + " VALUES (:name, :country_code, "
      + " :district, :population )", 
      paramSource, keyHolder);
  return keyHolder.getKey().longValue();
}
```

正如我们在添加国家/地区时看到的，这也将利用一个 helper 方法从`City`数据中返回一个`Map`，如下所示:

```java
private Map<String, Object> getMapForCity(String countryCode, City city){
  Map<String, Object> map = new HashMap<String, Object>();
  map.put("name", city.getName());
  map.put("country_code", countryCode);
  map.put("district", city.getDistrict());
  map.put("population", city.getPopulation());
  return map;
}
```

在`addCity`中需要注意的一件重要事情是使用`KeyHolder`和`GeneratedKeyHolder`返回生成的(由于自动递增)主键，即`cityId`，如下所示:

```java
 KeyHolder keyHolder = new GeneratedKeyHolder();
 //other code
 return keyHolder.getKey().longValue();
```

最后，我们实现了从国家中删除城市的方法，如下面的代码所示:

```java
public void deleteCity(Long cityId) {
  Map<String, Object> params = new HashMap<String, Object>();
  params.put("id", cityId);
  namedParamJdbcTemplate.update("DELETE FROM city WHERE id = :id", params);
}
```

现在让我们为`CityDAO`添加一个测试。在`src/test/java`文件夹下的`com.nilangpatel.worldgdp.test.dao`包中添加`CityDAOTest`类，如下所示:

```java
@RunWith(SpringRunner.class)
@SpringJUnitConfig( classes = {
  TestDBConfiguration.class, CityDAO.class})
public class CityDAOTest {

  @Autowired CityDAO cityDao;

  @Autowired @Qualifier("testTemplate")
  NamedParameterJdbcTemplate namedParamJdbcTemplate;

  @Before
  public void setup() {
    cityDao.setNamedParamJdbcTemplate(namedParamJdbcTemplate);
  }

  @Test public void testGetCities() {
    List<City> cities = cityDao.getCities("IND", 1);
    assertThat(cities).hasSize(10);
  }

  @Test public void testGetCityDetail() {
    Long cityId = 1024l;
    City city = cityDao.getCityDetail(cityId);
    assertThat(city.toString()).isEqualTo("City(id=1024, name=Mumbai (Bombay), "
      + "countryCode=IND, country=null, district=Maharashtra, population=10500000)");
  }

  @Test public void testAddCity() {
    String countryCode = "IND";
    City city = new City();
    city.setCountryCode(countryCode);
    city.setDistrict("District");
    city.setName("City Name");
    city.setPopulation(101010l);

    long cityId = cityDao.addCity(countryCode, city);
    assertThat(cityId).isNotNull();
    City cityFromDb = cityDao.getCityDetail(cityId);
    assertThat(cityFromDb).isNotNull();
    assertThat(cityFromDb.getName()).isEqualTo("City Name");
  }

  @Test (expected = EmptyResultDataAccessException.class)
  public void testDeleteCity() {
    Long cityId = addCity();
    cityDao.deleteCity(cityId);
    City cityFromDb = cityDao.getCityDetail(cityId);
    assertThat(cityFromDb).isNull();
  }

  private Long addCity() {
    String countryCode = "IND";
    City city = new City();
    city.setCountryCode(countryCode);
    city.setDistrict("District");
    city.setName("City Name");
    city.setPopulation(101010l);

    return cityDao.addCity(countryCode, city);
  }
}
```

# 设计国家语言道

我们需要公开以下 API 来与`countrylanguage`表交互:

*   获取给定国家代码的语言列表
*   通过检查语言是否已经存在，为某个国家添加新语言
*   删除某个国家的语言

为了简短起见，我们将展示涵盖这三种场景的方法实现。完整的代码可以在本书下载的代码中的`com.nilangpatel.worldgdp.dao.CountryLanguageDAO`类中找到。以下是这些方法实现的代码:

```java
public List<CountryLanguage> getLanguages(String countryCode, Integer pageNo){
  Map<String, Object> params = new HashMap<String, Object>();
  params.put("code", countryCode);

  Integer offset = (pageNo - 1) * PAGE_SIZE;
  params.put("offset", offset);
  params.put("size", PAGE_SIZE);

  return namedParamJdbcTemplate.query("SELECT * FROM countrylanguage"
      + " WHERE countrycode = :code"
      + " ORDER BY percentage DESC "
      + " LIMIT :size OFFSET :offset ", 
      params, new CountryLanguageRowMapper());
}

public void addLanguage(String countryCode, CountryLanguage cl) {
  namedParamJdbcTemplate.update("INSERT INTO countrylanguage ( "
      + " countrycode, language, isofficial, percentage ) "
      + " VALUES ( :country_code, :language, "
      + " :is_official, :percentage ) ", 
      getAsMap(countryCode, cl));
}

public boolean languageExists(String countryCode, String language) {
  Map<String, Object> params = new HashMap<String, Object>();
  params.put("code", countryCode);
  params.put("lang", language);

  Integer langCount = namedParamJdbcTemplate.queryForObject(
    "SELECT COUNT(*) FROM countrylanguage"
    + " WHERE countrycode = :code "
    + " AND language = :lang", params, Integer.class);
  return langCount > 0;
}

public void deleteLanguage (String countryCode, String language ) {
  Map<String, Object> params = new HashMap<String, Object>();
  params.put("code", countryCode);
  params.put("lang", language);
  namedParamJdbcTemplate.update("DELETE FROM countrylanguage "
      + " WHERE countrycode = :code AND "
      + " language = :lang ", params);
}

private Map<String, Object> getAsMap(String countryCode, CountryLanguage cl){
  Map<String, Object> map = new HashMap<String, Object>();
  map.put("country_code", countryCode);
  map.put("language", cl.getLanguage());
  map.put("is_official", cl.getIsOfficial());
  map.put("percentage", cl.getPercentage());
  return map;
}
```

# 为世界银行 API 设计客户端

我们需要从世界银行 API 获取 GDP 数据。正如我们所讨论的，它是 REST 端点，在这里我们必须发送几个参数并得到响应。为此，我们将使用 RestTemplate 进行 REST 调用。下面是对`com.packt.external.WorldBankApiClient`类的定义，该类用于调用世界银行 API 并处理其响应以返回`List<CountryGDP>`:

```java
@Service
public class WorldBankApiClient {

  String GDP_URL = "http://api.worldbank.org/countries/%s/indicators/NY.GDP.MKTP.CD?"
      + "format=json&date=2008:2018";

  public List<CountryGDP> getGDP(String countryCode) throws ParseException {
    RestTemplate worldBankRestTmplt = new RestTemplate();
    ResponseEntity<String> response
      = worldBankRestTmplt.getForEntity(String.format(GDP_URL, countryCode), String.class);

    //the second element is the actual data and its an array of object
    JSONParser parser = new JSONParser();
    JSONArray responseData = (JSONArray) parser.parse(response.getBody()); 
    JSONArray countryDataArr = (JSONArray) responseData.get(1);

    List<CountryGDP> data = new ArrayList<CountryGDP>();
    JSONObject countryDataYearWise=null;
    for (int index=0; index < countryDataArr.size(); index++) {
      countryDataYearWise = (JSONObject) countryDataArr.get(index);

      String valueStr = "0";
      if(countryDataYearWise.get("value") !=null) {
        valueStr = countryDataYearWise.get("value").toString();
      }
      String yearStr = countryDataYearWise.get("date").toString();
      CountryGDP gdp = new CountryGDP();
      gdp.setValue(valueStr != null ? Double.valueOf(valueStr) : null);
      gdp.setYear(Short.valueOf(yearStr));
      data.add(gdp);
    }
    return data;
  }
}
```

# 定义 API 控制器

到目前为止，我们已经编写了与数据库交互的代码。下一步是编写控制器的代码。我们将拥有两种类型的控制器——一种返回视图名称(在我们的例子中是百里香模板),并在模型对象中填充视图数据，另一种公开 RESTful APIs。我们需要将以下依赖项添加到`pom.xml`:

```java
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>${spring.version}</version>
</dependency>
```

将`spring-webmvc`添加到依赖项将自动包括`spring-core`、`spring-beans`和`spring-context`依赖项。这样我们就可以把它们从`pom.xml`中移除。

# 使用@EnableWebMvc 启用 Web MVC

为了能够利用 Spring MVC 特性，我们需要有一个用`@Configuration`注释的类，用`@EnableWebMvc`注释。`@EnableWebMvc`注释从 Spring MVC 框架中的`WebMvcConfigurationSupport`类导入 Spring MVC 配置。如果我们需要覆盖任何默认的导入配置，我们必须实现 Spring MVC 框架中的`WebMvcConfigurer`接口，并覆盖所需的方法。

我们将用下面的定义创建一个`AppConfiguration`类:

```java
@EnableWebMvc
@Configuration
@ComponentScan(basePackages = "com.nilangpatel.worldgdp")
public class AppConfiguration implements WebMvcConfigurer{

  @Override
  public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/static/**").addResourceLocations("/static/");
  }
}
```

在前面的配置中，需要注意以下几点:

*   `@EnableWebMvc`:导入 Spring MVC 相关配置。
*   `@ComponentScan`:用于申报需要扫描 Spring 组件的包(可以是`@Configuration`、`@Service`、`@Controller`、`@Component`等)。如果没有定义包，那么它从定义该类的包开始扫描。
*   `WebMvcConfigurer`:我们将实现这个接口来覆盖前面代码中的一些默认 Spring MVC 配置。

# 不使用 web.xml 部署到 Tomcat 的配置

因为我们将把应用部署到 Tomcat，所以我们需要向应用服务器提供 servlet 配置。我们将在单独的一节中讨论如何部署到 Tomcat，但是现在我们将讨论 Java 配置，它足以将应用部署到 Tomcat 或任何应用服务器，而不需要额外的`web.xml`。Java 类定义如下所示:

```java
public class WorldApplicationInitializer extends
  AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected Class<?>[] getRootConfigClasses() {
    return null;
  }
  @Override
  protected Class<?>[] getServletConfigClasses() {
    return new Class[] {AppConfiguration.class};
  }
  @Override
  protected String[] getServletMappings() {
    return new String[] { "/" };
  }
}
```

`AbstractAnnotationConfigDispatcherServletInitializer`抽象类是`WebApplicationInitializer`接口的实现，用于注册 Spring 的`DispatcherServlet`实例，并使用其他`@Configuration`类来配置`DispatcherServlet`。

我们只需要覆盖`getRootConfigClasses()`、`getServletConfigClasses()`和`getServletMappings()`方法。前两个方法指向需要加载到 servlet 上下文中的配置类，最后一个方法用于为`DispatcherServlet`提供 servlet 映射。

`DispatcherServlet`遵循前端控制器模式，注册一个 servlet 来处理所有的 web 请求。这个 servlet 使用`RequestHandlerMapping`并基于映射到实现的 URL 调用相应的实现。

我们需要对 Maven WAR 插件做一个小小的更新，这样如果没有找到`web.xml`就不会失败。这可以通过更新`pom.xml`文件中的`<plugins>`标签来完成，如下所示:

```java
<build>
  <finalName>worldgdp</finalName>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-war-plugin</artifactId>
      <executions>
        <execution>
          <id>default-war</id>
          <phase>prepare-package</phase>
          <configuration>
            <failOnMissingWebXml>false</failOnMissingWebXml>
          </configuration>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
```

现在我们已经准备好实现我们的控制器了。一旦我们实现了所有 RESTful API 控制器，我们将向您展示如何部署到 Tomcat。

# 为国家资源定义 RESTful API 控制器

让我们为 country 资源定义 RESTful API 控制器。以下是控制器的模板:

```java
@RestController
@RequestMapping("/api/countries")
@Slf4j
public class CountryAPIController {

  @Autowired CountryDAO countryDao;
  @Autowired WorldBankApiClient worldBankApiClient;

  @GetMapping
  public ResponseEntity<?> getCountries(
    @RequestParam(name="search", required = false) String searchTerm,
    @RequestParam(name="continent", required = false) String continent,
    @RequestParam(name="region", required = false) String region,
    @RequestParam(name="pageNo", required = false) Integer pageNo
  ){
    //logic to fetch contries from CountryDAO
    return ResponseEntity.ok();
  }

  @PostMapping(value = "/{countryCode}", 
      consumes = {MediaType.APPLICATION_JSON_VALUE})
  public ResponseEntity<?> editCountry(
    @PathVariable String countryCode, @Valid @RequestBody Country country ){
    //logic to edit existing country 
    return ResponseEntity.ok();
  }

  @GetMapping("/{countryCode}/gdp")
  public ResponseEntity<?> getGDP(@PathVariable String countryCode){
    //logic to get GDP by using external client
    return ResponseEntity.ok();
  }

}
```

以下是前面代码中需要注意的一些事项:

*   `@RestController`:这用于将类注释为控制器，每个 RESTful 方法在响应体中返回数据。
*   `@RequestMapping`:用于分配访问资源的根 URL。
*   `@GetMapping`和`@PostMapping`:它们用于分配将用于调用资源的 HTTP 动词。资源的 URL 在注释中传递，同时传递的还有其他消耗和产生信息的请求头。

让我们从`getCountries()`开始，依次实现每个方法，如下面的代码所示:

```java
@GetMapping
public ResponseEntity<?> getCountries(
  @RequestParam(name="search", required = false) String searchTerm,
  @RequestParam(name="continent", required = false) String continent,
  @RequestParam(name="region", required = false) String region,
  @RequestParam(name="pageNo", required = false) Integer pageNo
){
  try {
    Map<String, Object> params = new HashMap<String, Object>();
    params.put("search", searchTerm);
    params.put("continent", continent);
    params.put("region", region);
    if ( pageNo != null ) {
      params.put("pageNo", pageNo.toString());
    }

    List<Country> countries = countryDao.getCountries(params);
    Map<String, Object> response = new HashMap<String, Object>();
    response.put("list", countries);
    response.put("count", countryDao.getCountriesCount(params));
    return ResponseEntity.ok(response);
  }catch(Exception ex) {
    log.error("Error while getting countries", ex);
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
          .body("Error while getting countries");
  }
}
```

以下是前面代码中需要注意的一些事项:

*   `@RequestParam`:该注释用于声明控制器端点接受的请求参数。这些参数可以提供默认值，也可以是强制性的。
*   `ResponseEntity`:这个类用于返回响应体，以及其他响应参数，如状态、头等。

接下来是用于编辑国家详细信息的 API，如下所示:

```java
@PostMapping("/{countryCode}")
public ResponseEntity<?> editCountry(
  @PathVariable String countryCode, @Valid @RequestBody Country country ){
  try {
    countryDao.editCountryDetail(countryCode, country);
    Country countryFromDb = countryDao.getCountryDetail(countryCode);
    return ResponseEntity.ok(countryFromDb);
  }catch(Exception ex) {
    log.error("Error while editing the country: {} with data: {}", 
       countryCode, country, ex);
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
        .body("Error while editing the country");
  }
}
```

以下是前面代码实现中需要注意的一些事项:

*   `@PathVariable`:用于声明任何需要成为控制器端点 URL 路径一部分的变量。在我们的例子中，我们希望国家代码是 URL 的一部分。因此 URL 将采用`/api/countries/IND`的形式。
*   `@Valid`:这将触发 Bean 验证 API 来检查每个类属性的限制。如果来自客户端的数据无效，它将返回 400。
*   `@RequestBody`:用于捕获请求体中发送的数据，`Jackson`库用于将请求体中的 JSON 数据转换成相应的 Java 对象。

API 实现的其余部分可以在`CountryAPIController`类中找到。API 控制器的测试可以在本书的源代码中的`CountryAPIControllerTest`类中找到。

# 为城市资源定义 RESTful API 控制器

对于城市资源，我们需要以下 API:

*   获取给定国家的城市
*   给这个国家增加一个新城市
*   从国家中删除城市

这个控制器的代码可以在`CityAPIController`类中找到，API 控制器的测试可以在本书的源代码中的`CityAPIControllerTest`类中找到。

# 为国家语言资源定义 RESTful API 控制器

对于`CountryLanguage`资源，我们需要以下 API:

*   获取某个国家的语言
*   为国家添加语言
*   从该国删除一种语言

这个控制器的代码可以在`CountryLanguageAPIController`类中找到，API 控制器的测试可以在本书的源代码中的`CountryLanguageAPIControllerTest`类中找到。

# 部署到 Tomcat

在我们继续使用视图和控制器来处理视图之前，我们将把目前开发的应用部署到 Tomcat 上。你可以从这里下载 Tomcat 8.5([https://tomcat.apache.org/download-80.cgi](https://tomcat.apache.org/download-80.cgi))。安装非常简单，只需将 ZIP/TAR 文件解压缩到您的文件系统中。

让我们在 Tomcat 中创建一个用户`admin`和`manager-gui`角色。为此，必须编辑`apache-tomcat-8.5.23/conf/tomcat-users.xml`并添加下面一行:

```java
<role rolename="manager-gui" />
<user username="admin" password="admin" roles="manager-gui" />
```

启动 Tomcat 很简单，如下所示:

1.  导航至`apache-tomcat-8.5.23/bin`
2.  运行`startup.bat`

导航到`http://localhost:8080/manager/html`并分别输入`admin`和`admin`作为用户名和密码，以便能够查看 Tomcat 的管理器控制台。页面的初始部分将列出当前实例中部署的应用，在页面的后面部分，您将看到一个上传 WAR 文件以部署应用的选项，如下面的屏幕截图所示:

![](assets/6c21e48b-e79b-4804-a73c-91ec6b6abaa9.png)

我们可以上传运行`mvn package`后生成的 WAR 文件，或者更新 Tomcat 实例的`server.xml`来引用项目的目标目录，以便能够自动部署。后一种方法可用于开发，而前一种方法即战争部署可用于生产。

在生产系统中，您可以让连续部署服务器生成一个 WAR 文件并部署到远程 Tomcat 实例。在这个场景中，我们将使用后一种方法来更新 Tomcat 的配置。您必须在位于`TOMCAT_HOME/conf/server.xml`的 Tomcat 的`server.xml`文件中添加以下代码行:

```java
<Context path="/world" docBase="<<Directory path where you keep WAR file>>" 
          reloadable="true" />
```

必须在`<Host></Host>`标签之间添加前一行。或者，您可以在您的 IDE 中配置 Tomcat(例如，Eclipse)，这对于开发目的来说更方便。我们将使用 Maven 构建项目，但在此之前，请将以下配置添加到`pom.xml`的`<properties></properties>`部分:

```java
<maven.compiler.target>1.8</maven.compiler.target>
<maven.compiler.source>1.8</maven.compiler.source>
```

这将确保在从命令行用 Maven 构建(打包)应用时选择正确的 Java 编译器版本。接下来是使用`mvn package`构建项目并使用`TOMCAT_HOME/bin/startup.bat`运行 Tomcat，一旦服务器启动，您可以在浏览器中访问 API `http://localhost:8080/worldgdp/api/countries`来查看以下输入:

![](assets/253a8a32-c15a-418a-8929-a9e7717d2c0e.png)

# 定义视图控制器

我们将有一个视图控制器，`com.nilangpatel.worldgdp.controller.view`中定义的`ViewController.java`。视图控制器将负责填充视图模板所需的数据，并将 URL 映射到相应的视图模板。

我们将使用百里香叶([www.thymeleaf.org](https://www.thymeleaf.org/))作为服务器端模板引擎，小胡子. js([https://github.com/janl/mustache.js](https://github.com/janl/mustache.js))作为我们的客户端模板引擎。使用客户端模板引擎的优点是，任何以 JSON 形式异步加载的数据都可以通过使用客户端模板生成 HTML 轻松地添加到 DOM 中。我们将在[第三章](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml)、*blog press——一个简单的博客管理系统*中探索更多关于百里香和 Mustache.js 的内容。

通过使用 Vue.js、React.js、Angular.js 等框架，有更好的方法来做到这一点。我们将在下一节中查看视图模板。让我们继续关于视图控制器的讨论。视图控制器应该为以下场景映射正确的视图模板和数据:

*   国家列表
*   查看国家详细信息
*   编辑国家详细信息

让我们看看下面的`ViewController`类的框架结构定义:

```java
@Controller
@RequestMapping("/")
public class ViewController {

  @Autowired CountryDAO countryDao;
  @Autowired LookupDAO lookupDao;
  @Autowired CityDAO cityDao;

  @GetMapping({"/countries", "/"})
  public String countries(Model model, 
    @RequestParam Map<String, Object> params
  ) {
    //logic to fetch country list
    return "countries";
  }

  @GetMapping("/countries/{code}")
  public String countryDetail(@PathVariable String code, Model model) {
    //Logic to Populate the country detail in model
    return "country";
  }

  @GetMapping("/countries/{code}/form")
  public String editCountry(@PathVariable String code, 
    Model model) {
    //Logic to call CountryDAO to update the country
    return "country-form";
  }
}
```

以下是前面代码中的一些重要内容:

*   `@Controller`:该注释用于声明一个控制器，该控制器可以返回视图模板名称以呈现视图，并在响应体中返回 JSON/XML 数据。
*   `@ResponseBody`:当这个注释出现在控制器的方法上时，表示该方法将返回响应体中的数据，因此，Spring 不会使用视图解析器来解析要呈现的视图。默认情况下,`@RestController`注释将这个注释添加到它的所有方法中。
*   `Model`:这个实例用于传递构建视图所需的数据。

在列出国家的情况下，使用百里香模板引擎在服务器上呈现完整的 HTML，因此我们需要获取请求参数(如果 URL 中存在的话),并获取经过过滤和分页的国家列表。我们还需要填充作为`<select>`控件数据的查找，它将用于过滤数据。让我们看看它的实现如下:

```java
@GetMapping({"/countries", "/"})
public String countries(Model model, 
  @RequestParam Map<String, Object> params
) {
  model.addAttribute("continents", lookupDao.getContinents());
  model.addAttribute("regions", lookupDao.getRegions());
  model.addAttribute("countries", countryDao.getCountries(params));
  model.addAttribute("count", countryDao.getCountriesCount(params));

  return "countries";
}
```

前面的代码非常简单。我们使用 DAO 类将所需的数据填充到`Model`实例中，然后返回视图名，在本例中是`countries`。类似地，其余的方法实现可以在`ViewController`控制器类中找到。

# 定义视图模板

我们将使用百里香模板引擎来处理服务器端模板。百里香提供了各种方言和条件块，用于在静态 HTML 中呈现动态内容。让我们看看百里香的一些简单的语法元素，如下所示:

```java
<!-- Dynamic content in HTML tag -->
<div class="alert alert-info">[[${country.name}]]</div>

<!-- Dynamic attributes -->
<span th:class="|alert ${error ? 'alert-danger': _}|">[[${errorMsg}]]</span>

<!-- Looping -->
<ol>
  <li th:each="c : ${countries}">
     [[${c.name}]]
  </li>
</ol>

<!-- Conditionals -->
<div class="alert alert-warning" th:if="${count == 0}">No results found</div>

<!-- Custom attributes -->
<div th:attr="data-count=${count}"></div>

<!-- Form element value -->
<input type="text" th:value="${country.name}" name="name" />
```

从前面的例子中，我们可以观察到百里香要评估的项目以`th:`为前缀，标记之间要呈现的任何内容都可以使用`th:text`或`[[${variable}]]`来完成。后一种语法已经在百里香 3 中引入。这是一本非常短的入门书，因为深入研究百里香叶超出了本书的范围。解释模板不同部分的漂亮指南可以在[http://www . thyme leaf . org/doc/tutorials/3.0/using thyme leaf . html](http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)找到。

# 配置百里香模板引擎

为了将百里香模板引擎与 Spring MVC 一起使用，我们需要做一些配置，其中我们设置了百里香模板引擎并更新了 Spring 的视图解析器，以使用模板引擎来解析任何视图。在继续之前，我们需要在`pom.xml`中定义所需的依赖关系，如下所示:

```java
    <dependency>
      <groupId>org.thymeleaf</groupId>
      <artifactId>thymeleaf-spring5</artifactId>
      <version>${thymeleaf.version}</version>
    </dependency>
    <dependency>
      <groupId>nz.net.ultraq.thymeleaf</groupId>
      <artifactId>thymeleaf-layout-dialect</artifactId>
      <version>${thymeleaf-layout-dialect.version}</version>
    </dependency>
```

让我们按顺序定义配置视图解析器，从如下设置模板解析器开始:

```java
@Bean
public ClassLoaderTemplateResolver templateResolver() {
  ClassLoaderTemplateResolver templateResolver 
     = new ClassLoaderTemplateResolver();
  templateResolver.setPrefix("templates/");
  templateResolver.setSuffix(".html");
  templateResolver.setTemplateMode(TemplateMode.HTML);
  templateResolver.setCacheable(false);
  return templateResolver;
}
```

前面的配置设置了模板引擎将用来解析模板文件的模板位置。接下来是定义模板引擎，它将利用前面定义的`SpringTemplateEngine`和模板解析器，如下所示:

```java
@Bean
public SpringTemplateEngine templateEngine() {
  SpringTemplateEngine templateEngine = new SpringTemplateEngine();
  templateEngine.setTemplateResolver(templateResolver());
  templateEngine.addDialect(new LayoutDialect());
  return templateEngine;
}
```

在前面的配置中，我们使用了由*伊曼纽尔·拉比纳*创造的百里香布局方言(【https://github.com/ultraq/thymeleaf-layout-dialect】T2)。这种布局方言有助于我们创建一个视图装饰框架，其中所有的模板都用一个基本模板来装饰，而装饰模板只提供完成页面所需的内容。因此，所有的页眉、页脚、CSS、脚本和其他常见的 HTML 都可以放在基本模板中。这在很大程度上防止了冗余。在我们的示例应用中，`worldgdp/src/main/resources/templates`中的`base.html`文件是其他模板使用的基础模板。

下一步是定义一个百里香叶视图解析器，它将覆盖 Spring 的默认视图解析器，如下所示:

```java
@Bean
public ViewResolver viewResolver() {
  ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
  viewResolver.setTemplateEngine(templateEngine());
  viewResolver.setCharacterEncoding("UTF-8");
  return viewResolver;
}
```

先前的配置在`com.packt.config.ViewConfiguration`级中可用。

# 管理静态资源

如果你回头看一下`com.nilangpatel.worldgdp.AppConfiguration`类，你会发现我们已经覆盖了`WebMvcConfigurer`接口的`addResourceHandlers`方法。在以下代码所示的方法实现中，我们将静态资源前缀 URL `/static/**`映射到了`webapp`目录中的静态资源位置`/static/`:

```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
  registry.addResourceHandler("/static/**")
    .addResourceLocations("/static/");
}
```

我们在项目的`/src/main/webapp/static`文件夹中添加了一些静态资源(CSS 和 JavaScript)。请下载本章的代码并并排参考。

# 创建基础模板

我们之前提到过，我们将使用百里香布局方言来创建一个基础模板，并使用该基础模板来装饰所有其他模板。基本模板将包含所有 CSS 链接、JavaScript 源文件链接、页眉和页脚，如以下代码所示:

```java
<!DOCTYPE html>
<html 
  xmlns:th="http://www.thymeleaf.org" 
  xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout">
  <head>

    <title layout:title-pattern="$CONTENT_TITLE - $LAYOUT_TITLE">World In Numbers</title>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <!-- Include all the CSS links -->
  </head>

  <body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
      <a class="navbar-brand" href="#">WORLD IN NUMBERS</a>
      <div class="collapse navbar-collapse" id="navbarColor01">
          <ul class="navbar-nav mr-auto">
          <li class="nav-item active">
            <a class="nav-link" th:href="@{/countries}">Countries</a>
          </li>
        </ul>
      </div>
    </nav>
    <div class="container">
      <div class="content">
        <div layout:fragment="page_content">
          <!-- Placeholder for content -->
        </div>

      </div>
    </div>

    <div class="modal" id="worldModal" >
    </div>
    <footer id="footer"></footer>
    <!-- /.container -->

    <!-- Include all the Javascript source files -->
    <th:block layout:fragment="scripts">
      <!-- Placeholder for page related javascript -->
    </th:block>
  </body>

</html>

```

以下模板的两个主要重要部分如下:

*   使用基础模板作为装饰者的其他模板在这个部分中提供它们的 HTML。运行时的百里香布局方言用来自基本模板的内容来修饰这个 HTML。
*   `<th:block layout:fragment="scripts"></th:block>`:与 HTML 之前的内容类似，任何特定于页面的 JavaScript 或指向任何特定 JavaScript 源文件的链接都可以添加到这个部分中。这有助于将特定于页面的 JavaScript 隔离在它们自己的页面中。

任何想要使用基模板作为装饰器的模板都会在`<html>`标签中声明这个属性`layout:decorate="~{base}"`。我们不会深入到单个模板的内容，因为它主要是 HTML。所有的模板都可以在`worldgdp/src/main/resources/templates`找到。我们有三个模板:

*   `countries.html`:显示国家列表，过滤分页
*   这是用于编辑一个国家的详细信息
*   这是用来显示一个国家的细节

# 日志记录配置

在我们进入开发应用的其余步骤之前，定义一个日志级别和格式是一个很好的实践。但是，以期望的格式打印日志以及各种日志记录级别是可选的，但也是很好的做法。为此，添加一个名为`logback.xml`的 XML 文件，其中包含以下内容:

```java
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <layout class="ch.qos.logback.classic.PatternLayout">
      <Pattern>
        %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
      </Pattern>
    </layout>
  </appender>
  <logger name="com.nilangpatel.worldgdp" level="debug" additivity="false">
    <appender-ref ref="STDOUT" />
  </logger>
  <root level="debug">
    <appender-ref ref="STDOUT" />
  </root>
</configuration>
```

Logback 是作为流行的 Log4j 项目的继承者开发的，并被用作 Java 应用的日志框架。该配置定义了模式以及日志记录级别。要在您的应用中启用回退，您需要向`pom.xml`添加以下依赖项:

```java
  <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
      <version>${logback.version}</version>
  </dependency>
  <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-core</artifactId>
      <version>${logback.version}</version>
  </dependency>
```

# 运行应用

因为我们已经将部署配置到 Tomcat，所以您现在应该可以运行应用了。你可以随时下载这本书的源代码；在`worldgdp`文件夹下找到源代码。下载后，您必须使用 Maven 构建它，如下所示:

```java
$ mvn package 
```

前面的命令也将运行测试。`target`中的 WAR 文件`worldgdp.war`，可以通过管理器 app 上传到 Tomcat，也可以复制到`TOMCAT_HOME/webapps`文件夹。然后，Tomcat 将展开归档文件并部署应用。

下面是应用运行时的一些屏幕截图，从列表页面开始:

![](assets/ea8a1112-6b0f-4c4e-b506-465aa9138f3c.png)

接下来是显示国家详细信息的页面:

![](assets/f99e0a4f-5bf4-494c-928b-23fadf61b223.png)

用于编辑国家详细信息的表单显示在下面的屏幕截图中:

![](assets/945cadbf-de57-4099-8259-b4c044f59bc8.png)

然后我们有弹出窗口，用于向国家添加一个新的城市，如下面的屏幕截图所示:

![](assets/00f915d1-38c2-428d-bec6-a22d2df2df8e.png)

类似地，我们有另一个弹出窗口来添加新的国家语言，如下所示:

![](assets/07f46f66-80d6-40ef-aff2-09fbf2303055.png)

# 摘要

这一章的目的是让你开始使用 Spring 框架。我们讨论了各种主题，从头开始创建项目结构和设计视图模板。它包含了在 Spring 中构建基于 web 的应用的各种技术和工具。

多做动手练习来详细理解概念总是好的做法。接下来，您可以考虑通过采用一些其他的世界银行 API 来进一步增强应用，并将它们集成到这个应用中。在这一章中，我们已经用自己的配置了大部分的东西。

然而，Spring 提供了一个名为 **Spring Boot** 的工具，它真正有助于以自动化的方式完成大部分配置，让您可以专注于开发应用。在接下来的章节中，我们将更详细地探讨如何使用 Spring Boot 在 Spring 中开发 web 应用。

在下一章，我们将使用 WebFlux 探索 Spring 框架中另一个伟大的特性，叫做反应式编程。我们将学习反应范式的基础知识，有什么好处，并探索各种反应库。Spring 使用`Reactor`——一个提供 Reactive Stream 实现的库来开发基于 web 的应用。所以，准备好在第二章探索所有这些新的和令人兴奋的话题。